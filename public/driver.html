<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RideSync Driver</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- QR code library for boarding / dropoff codes -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

  <script type="importmap">
    {
      "imports": {
        "@/lib/firebase": "/src/lib/firebase.js",
        "firebase/app": "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js",
        "firebase/auth": "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js"
      }
    }
  </script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1d4ed8, #020617 55%);
      color: #f9fafb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 10px;
    }
    .site-footer {
      width: 100%;
      max-width: 640px;
      margin-top: auto;
      text-align: center;
      font-size: 0.75rem;
      color: #94a3b8;
      padding: 8px 0 calc(env(safe-area-inset-bottom, 0px) + 6px);
    }
    .site-footer p {
      margin: 0;
      color: inherit;
    }
    .card {
      background: rgba(2,6,23,0.92);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.45);
      box-shadow: 0 24px 60px rgba(0,0,0,0.6);
      width: 100%;
      max-width: 640px;
      max-height: 96vh;
      padding: 20px 16px 16px;
      overflow-y: auto;
      position: relative;
      z-index: 2;
      backdrop-filter: blur(12px);
    }
    h1, h2 { margin: 0 0 8px; text-align: center; }
    h1 { font-size: 1.6rem; }
    h2 { font-size: 1.1rem; }
    .subtitle {
      margin: 0 0 16px;
      text-align: center;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    label {
      font-size: 0.8rem;
      display: block;
      margin-bottom: 4px;
      color: #e5e7eb;
    }
    input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #f9fafb;
      font-size: 0.9rem;
      margin-bottom: 8px;
    }
    input:focus {
      outline: 2px solid #2563eb;
      outline-offset: 1px;
    }
    button {
      padding: 9px 12px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
    }
      .btn-primary { background: #22c55e; color: #022c22; }
      .btn-secondary {
        background: #020617;
        color: #e5e7eb;
        border: 1px solid #4b5563;
      }
      .btn-danger {
        background: #7f1d1d;
        color: #fee2e2;
        border: 1px solid #fca5a5;
      }
    .btn-small { font-size: 0.78rem; padding: 6px 10px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .row > div { flex: 1 1 150px; }
    .error { color: #fecaca; font-size: 0.8rem; min-height: 18px; margin-top: 2px; }
    .success { color: #bbf7d0; font-size: 0.8rem; min-height: 18px; margin-top: 2px; }
    .small { font-size: 0.75rem; color: #9ca3af; margin-top: 4px; }

    #authView, #driverView { display: none; }
    #authView.active, #driverView.active { display: block; }

    .driver-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .driver-avatar-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }
    .driver-avatar {
      width: 58px;
      height: 58px;
      border-radius: 999px;
      border: 2px solid rgba(148,163,184,0.8);
      object-fit: cover;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #9ca3af;
      font-size: 1.1rem;
      overflow: hidden;
      cursor: pointer;
      position: relative;
    }
    .driver-avatar[role="button"]:focus-visible {
      outline: 2px solid #2563eb;
      outline-offset: 2px;
    }
    .driver-header-text { flex: 1 1 auto; min-width: 0; }
    .driver-name { font-size: 1rem; font-weight: 600; }
    .driver-detail { font-size: 0.8rem; color: #9ca3af; }
    .driver-header-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }
    .driver-header-actions button {
      flex: 1 1 140px;
    }
    .driver-view-nav {
      display: flex;
      gap: 8px;
      padding: 4px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.85);
      margin: 12px 0 0;
    }
    .driver-nav-button {
      flex: 1 1 0;
      border: none;
      border-radius: 999px;
      background: transparent;
      color: #94a3b8;
      padding: 8px 10px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .driver-nav-button.active {
      background: #22c55e;
      color: #022c22;
    }
    .driver-section {
      display: none;
      margin-top: 16px;
    }
    .driver-section.active {
      display: block;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #ef4444;
      display: inline-block;
      margin-right: 4px;
    }
    .status-dot.online { background: #22c55e; }

    #map {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin: 12px 0 6px;
      border-top: 1px solid rgba(148,163,184,0.4);
      padding-top: 8px;
    }

    .ride-card {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.5);
      padding: 8px 10px;
      margin-bottom: 8px;
      background: rgba(15,23,42,0.95);
      font-size: 0.8rem;
    }
    .ride-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
      font-weight: 600;
    }
    .ride-line { margin-bottom: 2px; }
    .ride-meta { color: #9ca3af; }
    .tag {
      display: inline-flex;
      align-items: center;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid rgba(148,163,184,0.6);
      margin-right: 4px;
      margin-bottom: 2px;
    }
    .tag-basic { border-color:#3b82f6; color:#bfdbfe; }
    .tag-uofa { border-color:#22c55e; color:#bbf7d0; }
    .tag-nwa { border-color:#f97316; color:#fed7aa; }
    .tag-pooled { border-color:#a855f7; color:#e9d5ff; }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(2,6,23,0.92);
      backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 50;
    }
    .overlay.active { display: flex; }
    .driver-overlay-shell {
      width: min(520px, 100%);
      max-height: 100%;
      overflow-y: auto;
      background: rgba(2,6,23,0.95);
      border: 1px solid rgba(148,163,184,0.45);
      border-radius: 20px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.65);
      position: relative;
    }
    .driver-overlay-top {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: flex-start;
    }
    .driver-cancel-button {
      position: sticky;
      bottom: 0;
      width: 100%;
      margin-top: auto;
      z-index: 5;
      box-shadow: 0 -8px 18px rgba(2,6,23,0.85);
    }
    .driver-rider-bar {
      flex: 1 1 auto;
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .driver-rider-avatars {
      display: flex;
      gap: 4px;
    }
    .driver-top-avatar {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.5);
      overflow: hidden;
      background: #0f172a;
      position: relative;
      flex-shrink: 0;
    }
    .driver-top-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .driver-top-avatar .avatar-initials {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #94a3b8;
      font-size: 0.78rem;
    }
    .driver-top-avatar.has-photo .avatar-initials {
      display: none;
    }
    .driver-rider-meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .driver-rider-names {
      font-size: 1rem;
      font-weight: 600;
    }
    .driver-rider-membership {
      font-size: 0.78rem;
      color: #cbd5f5;
    }
    .driver-rider-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .driver-chip {
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      font-size: 0.72rem;
      color: #e5e7eb;
    }
    .overlay-close {
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #e5e7eb;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 0.78rem;
      flex-shrink: 0;
    }
    .driver-state {
      display: none;
      flex-direction: column;
      gap: 12px;
    }
    .driver-state.active { display: flex; }
    .driver-state h3 {
      margin: 0;
      font-size: 1.3rem;
    }
    .driver-state .state-subtitle {
      color: #9ca3af;
      font-size: 0.9rem;
    }
    .driver-state .info-box {
      background: rgba(15,23,42,0.9);
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      padding: 12px;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    .driver-state input {
      background: #020617;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.5);
      padding: 10px 12px;
      color: #f9fafb;
      font-size: 1.1rem;
      letter-spacing: 0.2em;
      text-align: center;
    }
    .driver-state .button-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .driver-state .button-row button {
      flex: 1 1 160px;
    }
    .ride-chat-card {
      display: flex;
      flex-direction: column;
      gap: 10px;
      border: 1px solid rgba(148,163,184,0.45);
      border-radius: 18px;
      padding: 14px;
      background: rgba(2,6,23,0.95);
      box-shadow: inset 0 0 0 rgba(0,0,0,0);
    }
    .ride-chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .ride-chat-title {
      font-size: 0.95rem;
      font-weight: 600;
    }
    .ride-chat-note {
      font-size: 0.75rem;
      color: #94a3b8;
      display: none;
    }
    .ride-chat-messages {
      min-height: 160px;
      max-height: 220px;
      overflow-y: auto;
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 14px;
      padding: 12px;
      background: rgba(15,23,42,0.8);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .ride-chat-message {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-width: 90%;
    }
    .ride-chat-message.from-self {
      align-self: flex-end;
      text-align: right;
    }
    .ride-chat-message.from-peer {
      align-self: flex-start;
      text-align: left;
    }
    .ride-chat-bubble {
      display: inline-flex;
      padding: 8px 12px;
      border-radius: 14px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.4);
      color: #f9fafb;
      font-size: 0.9rem;
      line-height: 1.35;
      word-break: break-word;
      white-space: pre-wrap;
    }
    .ride-chat-message.from-self .ride-chat-bubble {
      background: rgba(59,130,246,0.18);
      border-color: rgba(59,130,246,0.45);
    }
    .ride-chat-message.from-peer .ride-chat-bubble {
      background: rgba(15,23,42,0.95);
    }
    .ride-chat-meta {
      font-size: 0.7rem;
      color: #94a3b8;
    }
    .ride-chat-placeholder {
      text-align: center;
      font-size: 0.85rem;
      color: #94a3b8;
      padding: 12px 0;
    }
    .ride-chat-input-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .ride-chat-input {
      flex: 1 1 auto;
      border-radius: 12px;
      border: 1px solid #4b5563;
      padding: 10px 12px;
      background: #020617;
      color: #f9fafb;
      font-size: 0.9rem;
    }
    .ride-chat-input:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .ride-chat-send {
      flex: 0 0 auto;
    }
    .driver-geofence-status {
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .driver-geofence-status.armed {
      color: #bbf7d0;
    }
    .next-ride-box {
      margin-top: 10px;
      border-color: rgba(34,197,94,0.4);
      background: rgba(34,197,94,0.08);
      color: #bbf7d0;
      font-size: 0.85rem;
    }
    .driver-spinner {
      width: 36px;
      height: 36px;
      border-radius: 999px;
      border: 4px solid rgba(148,163,184,0.3);
      border-top-color: #22c55e;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }
    @keyframes spin { to { transform: rotate(360deg);} }

    .pill {
      display:inline-flex;
      padding:2px 7px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,0.5);
      font-size:0.7rem;
      margin-left:4px;
    }
    .driver-riders-container {
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:6px;
    }
    .driver-rider-card {
      display:flex;
      gap:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(148,163,184,0.45);
      background:rgba(2,6,23,0.9);
    }
    .driver-rider-avatar {
      width:54px;
      height:54px;
      border-radius:14px;
      border:1px solid rgba(148,163,184,0.6);
      background:#0f172a;
      overflow:hidden;
      position:relative;
      flex-shrink:0;
    }
    .driver-rider-avatar img {
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .driver-rider-avatar .avatar-initials {
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:600;
      color:#94a3af;
      font-size:0.8rem;
      background:#0f172a;
    }
    .driver-rider-avatar.has-photo .avatar-initials {
      display:none;
    }
    .driver-rider-body { flex:1 1 auto; min-width:0; }
    .driver-rider-label {
      font-size:0.7rem;
      color:#94a3af;
      text-transform:uppercase;
      letter-spacing:0.06em;
      margin-bottom:2px;
    }
    .driver-rider-name {
      font-weight:600;
      font-size:0.95rem;
      margin-bottom:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .driver-rider-line {
      font-size:0.78rem;
      color:#cbd5f5;
      margin-bottom:1px;
    }
    .support-panel {
      border:1px solid rgba(148,163,184,0.4);
      border-radius:14px;
      padding:12px;
      background:rgba(2,6,23,0.92);
      margin-top:8px;
      display:none;
    }
    .support-panel.active { display:block; }
    .support-panel-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:6px;
    }
    .support-panel-text {
      font-size:0.8rem;
      color:#cbd5f5;
      margin-bottom:8px;
    }
    .support-actions {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .support-actions a {
      flex:1 1 140px;
      text-align:center;
      text-decoration:none;
    }
    .driver-profile-editor {
      border-radius:14px;
      border:1px solid rgba(148,163,184,0.35);
      background:rgba(2,6,23,0.9);
      padding:12px;
      margin-bottom:10px;
    }
    .profile-photo-row {
      display:flex;
      gap:12px;
      align-items:center;
      margin-bottom:12px;
    }
    .profile-photo-preview {
      width:72px;
      height:72px;
      border-radius:18px;
      border:1px solid rgba(148,163,184,0.6);
      background:#0f172a;
      overflow:hidden;
      position:relative;
      flex-shrink:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:600;
      color:#94a3af;
      font-size:0.9rem;
    }
    .profile-photo-preview img {
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .profile-photo-actions {
      flex:1 1 auto;
    }
    .profile-photo-buttons {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:6px;
    }
    .driver-nav-map-shell {
      border-radius:16px;
      border:1px solid rgba(148,163,184,0.35);
      overflow:hidden;
      position:relative;
      background:#0f172a;
      height:220px;
    }
    .driver-nav-map {
      width:100%;
      height:100%;
    }
    .driver-nav-map-status {
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:12px;
      color:#cbd5f5;
      font-size:0.85rem;
      background:rgba(2,6,23,0.82);
      opacity:0;
      transition:opacity 0.2s ease;
      pointer-events:none;
    }
    .driver-nav-map-status.visible {
      opacity:1;
    }
    .driver-profile-editor .row > div {
      flex:1 1 140px;
    }
    .driver-profile-editor-actions {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
      margin-top:8px;
    }
    .driver-profile-editor-actions button {
      flex:1 1 140px;
    }
    .sr-only-input {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      border: 0;
      clip: rect(0 0 0 0);
      overflow: hidden;
      white-space: nowrap;
    }
    .hidden { display:none !important; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="card">
    <!-- AUTH VIEW -->
    <div id="authView" class="active">
      <h1>RideSync Driver</h1>
      <p class="subtitle">Sign in to start receiving RideSync requests.</p>

      <label for="email">Email</label>
      <input id="email" type="email" placeholder="driver@example.com" autocomplete="email" />

      <label for="password">Password</label>
      <input id="password" type="password" placeholder="••••••••" autocomplete="current-password" />

      <button id="loginButton" class="btn-primary" style="width:100%;margin-top:6px;">Log in</button>
      <div id="authError" class="error"></div>
      <p class="small">Use your driver account (separate from rider login).</p>
    </div>

    <!-- DRIVER VIEW -->
    <div id="driverView">
      <h2>Driver console</h2>
      <p class="subtitle">Go online to start receiving RideSync requests.</p>

      <div class="driver-header">
        <div class="driver-avatar-column">
          <div
            id="driverAvatar"
            class="driver-avatar"
            role="button"
            tabindex="0"
            aria-label="Change profile photo"
          >
            DR
          </div>
          <button
            id="driverAvatarChangeButton"
            class="btn-secondary btn-small driver-avatar-trigger"
            type="button"
          >
            Change photo
          </button>
          <input
            id="driverAvatarUploadInput"
            class="sr-only-input"
            type="file"
            accept="image/*"
          />
        </div>
        <div class="driver-header-text">
          <div class="driver-name" id="driverName">Driver</div>
          <div class="driver-detail" id="driverDetail"></div>
          <div class="driver-detail">
            <span id="onlineDot" class="status-dot"></span>
            <span id="onlineLabel">Offline</span>
          </div>
        </div>
      </div>

      <div class="driver-header-actions">
        <button id="logoutButton" class="btn-secondary btn-small" type="button">Log out</button>
      </div>

      <div class="driver-view-nav" role="tablist" aria-label="Driver sections">
        <button
          id="driverNavSync"
          class="driver-nav-button active"
          type="button"
          role="tab"
          aria-selected="true"
          data-section="sync"
        >
          Sync rides
        </button>
        <button
          id="driverNavProfile"
          class="driver-nav-button"
          type="button"
          role="tab"
          aria-selected="false"
          data-section="profile"
        >
          Driver profile
        </button>
      </div>

      <div
        id="driverSyncSection"
        class="driver-section active"
        role="tabpanel"
        aria-labelledby="driverNavSync"
        aria-hidden="false"
      >
        <div class="section-title">Available rides</div>
        <div id="ridesList"></div>
        <div class="small" id="ridesHint">
          Rides with no driver and status pending/pooled will appear here while you are online.
        </div>

        <button id="toggleOnlineButton" class="btn-primary" style="width:100%;margin-top:12px;">
          Sync online
        </button>
        <div id="driverMessage" class="success"></div>
        <div id="driverError" class="error"></div>
      </div>

      <div
        id="driverProfileSection"
        class="driver-section"
        role="tabpanel"
        aria-labelledby="driverNavProfile"
        aria-hidden="true"
      >
        <div id="driverProfileEditor" class="driver-profile-editor">
          <div class="section-title" style="margin-top:0;border-top:none;padding-top:0;">
            Driver profile
          </div>
          <label for="driverEditName">Full name</label>
          <input id="driverEditName" type="text" placeholder="Driver Name" />

          <div class="profile-photo-row">
            <div id="driverPhotoPreview" class="profile-photo-preview">
              <span class="avatar-initials">DR</span>
            </div>
            <div class="profile-photo-actions">
              <label for="driverPhotoInput">Profile photo</label>
              <input id="driverPhotoInput" type="file" accept="image/*" />
              <div class="profile-photo-buttons">
                <button
                  id="driverPhotoRemoveButton"
                  class="btn-secondary btn-small"
                  type="button"
                >
                  Remove photo
                </button>
              </div>
              <div class="small">Square photo recommended. Images are resized to 512px max.</div>
              <div id="driverPhotoError" class="error"></div>
            </div>
          </div>

          <div class="row">
            <div>
              <label for="driverEditPhone">Phone</label>
              <input id="driverEditPhone" type="tel" placeholder="555-123-4567" />
            </div>
            <div>
              <label for="driverEditVehicleYear">Vehicle year</label>
              <input id="driverEditVehicleYear" type="text" placeholder="2022" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="driverEditVehicleMake">Vehicle make</label>
              <input id="driverEditVehicleMake" type="text" placeholder="Toyota" />
            </div>
            <div>
              <label for="driverEditVehicleModel">Vehicle model</label>
              <input id="driverEditVehicleModel" type="text" placeholder="Camry" />
            </div>
          </div>

          <div class="row">
            <div>
              <label for="driverEditVehicleColor">Vehicle color</label>
              <input id="driverEditVehicleColor" type="text" placeholder="Blue" />
            </div>
            <div>
              <label for="driverEditLicensePlate">License plate</label>
              <input id="driverEditLicensePlate" type="text" placeholder="ABC123" />
            </div>
          </div>

          <div class="driver-profile-editor-actions">
            <button id="driverProfileSaveButton" class="btn-primary btn-small" type="button">
              Save changes
            </button>
          </div>
          <div id="driverProfileEditorMessage" class="success"></div>
          <div id="driverProfileEditorError" class="error"></div>
        </div>
      </div>
    </div>

    <!-- ACTIVE RIDE OVERLAY -->
    <div id="activeRideOverlay" class="overlay">
      <div class="driver-overlay-shell">
        <div class="driver-overlay-top">
          <div class="driver-rider-bar">
            <div id="driverOverlayAvatarRow" class="driver-rider-avatars"></div>
            <div class="driver-rider-meta">
              <div id="driverOverlayRiderNames" class="driver-rider-names">Rider</div>
              <div id="driverOverlayMembership" class="driver-rider-membership"></div>
              <div id="driverOverlayChips" class="driver-rider-chips"></div>
            </div>
          </div>
          <button id="closeActiveRideButton" class="overlay-close" type="button">Hide</button>
        </div>

        <div
          id="driverChatCard"
          class="ride-chat-card"
          style="display:none;"
        >
          <div class="ride-chat-header">
            <div class="ride-chat-title">Chat with your rider</div>
            <div id="driverChatOfflineNote" class="ride-chat-note">
              Chat is available only while the ride is active.
            </div>
          </div>
          <div
            id="driverChatMessages"
            class="ride-chat-messages"
            role="log"
            aria-live="polite"
          ></div>
          <div class="ride-chat-input-row">
            <input
              id="driverChatInput"
              class="ride-chat-input"
              type="text"
              inputmode="text"
              maxlength="500"
              autocomplete="off"
              placeholder="Type a message…"
              aria-label="Message your rider"
            />
            <button
              id="driverChatSendButton"
              type="button"
              class="ride-chat-send btn-primary btn-small"
            >
              Send
            </button>
          </div>
        </div>

        <div id="driverStateOffer" class="driver-state">
          <h3>New ride request</h3>
          <div class="state-subtitle">Review the details before accepting.</div>
          <div class="info-box">
            <div><strong>Pickup:</strong> <span id="driverOfferPickupText"></span></div>
            <div><strong>Dropoff:</strong> <span id="driverOfferDropoffText"></span></div>
            <div><strong>Riders:</strong> <span id="driverOfferRiderCount"></span></div>
            <div id="driverOfferReserveRow" style="display:none;">
              <strong>Pickup time:</strong> <span id="driverOfferPickupTime"></span>
            </div>
          </div>
          <div class="button-row">
            <button id="driverOfferRejectButton" class="btn-secondary" type="button">Decline</button>
            <button id="driverOfferAcceptButton" class="btn-primary" type="button">Accept</button>
          </div>
        </div>

        <div id="driverStateNavPickup" class="driver-state">
          <h3>Navigate to pickup</h3>
          <div class="state-subtitle">Keep the rider updated while en route.</div>
          <div class="info-box">
            <div><strong>Pickup:</strong> <span id="driverNavPickupAddress"></span></div>
            <div id="driverNavPickupEta"></div>
          </div>
          <div class="driver-nav-map-shell">
            <div id="driverPickupMap" class="driver-nav-map"></div>
            <div id="driverPickupMapStatus" class="driver-nav-map-status">Loading map…</div>
          </div>
          <div class="button-row">
            <button id="driverPickupNavigateButton" class="btn-secondary" type="button">
              Open in Google Maps
            </button>
            <button id="driverArriveButton" class="btn-primary" type="button">Arrive</button>
          </div>
        </div>

        <div id="driverStateEnterPickup" class="driver-state">
          <h3>Verify rider</h3>
          <div class="state-subtitle">Ask for their pickup code and enter it below.</div>
          <input id="pickupCodeInput" type="text" inputmode="numeric" maxlength="6" placeholder="••••" />
          <div id="pickupCodeError" class="error"></div>
          <div class="button-row">
            <button id="driverPickupBackButton" class="btn-secondary" type="button">Back</button>
            <button id="driverPickupConfirmButton" class="btn-primary" type="button">Confirm code</button>
          </div>
        </div>

        <div id="driverStateNavDropoff" class="driver-state">
          <h3>On the way to destination</h3>
          <div class="state-subtitle">Complete ride once you reach the dropoff.</div>
          <div class="info-box">
            <div><strong>Destination:</strong> <span id="driverNavDropoffAddress"></span></div>
            <div id="driverDropoffEta"></div>
          </div>
          <div class="driver-nav-map-shell">
            <div id="driverDropoffMap" class="driver-nav-map"></div>
            <div id="driverDropoffMapStatus" class="driver-nav-map-status">Loading map…</div>
          </div>
          <div id="driverGeofenceStatus" class="driver-geofence-status"></div>
          <div
            id="driverNextRideSummary"
            class="info-box next-ride-box"
            style="display:none;"
            aria-live="polite"
          ></div>
          <div class="button-row">
            <button id="driverDropoffNavigateButton" class="btn-secondary" type="button">
              Open in Google Maps
            </button>
            <button id="driverCompleteButton" class="btn-primary" type="button" disabled>
              Complete ride
            </button>
          </div>
          <button
            id="driverCompleteOverrideButton"
            class="btn-secondary btn-small"
            type="button"
            style="align-self:flex-start; display:none;"
          >
            Override geofence
          </button>
        </div>

        <div id="driverStateEnterDropoff" class="driver-state">
          <h3>Confirm dropoff</h3>
          <div class="state-subtitle">Enter the rider's dropoff code to finish.</div>
          <input id="dropoffCodeInput" type="text" inputmode="numeric" maxlength="6" placeholder="••••" />
          <div id="dropoffCodeError" class="error"></div>
          <button id="driverDropoffConfirmButton" class="btn-primary" type="button">Confirm code</button>
        </div>

        <div id="driverStateComplete" class="driver-state">
          <h3>Ride complete</h3>
          <div id="driverWaitingStatus" class="state-subtitle">Waiting for rider rating and tip…</div>
          <div class="driver-spinner"></div>
          <div id="driverRatingResult" class="info-box" style="display:none;"></div>
          <div id="driverTipResult" class="info-box" style="display:none;"></div>
          <button
            id="driverCompleteDismissButton"
            class="btn-primary"
            type="button"
            style="display:none;"
          >
            Close &amp; return to idle
          </button>
        </div>

        <button id="driverCancelRideLink" class="btn-danger driver-cancel-button" type="button">
          Cancel ride
        </button>
        <div id="activeRideError" class="error"></div>
      </div>
    </div>
  </div>

  <footer class="site-footer" aria-label="Copyright notice">
    <p>&copy; 2025 RideSync. All rights reserved.</p>
  </footer>

  <script type="module">
    import { auth, db } from "@/lib/firebase";
    import {
      onAuthStateChanged,
      signInWithEmailAndPassword,
      signOut,
      setPersistence,
      browserLocalPersistence
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";
    import {
      collection,
      doc,
      getDoc,
      setDoc,
      updateDoc,
      onSnapshot,
      query,
      orderBy,
      limit,
      where,
      getDocs,
      serverTimestamp,
      writeBatch
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";
    import {
      getMessaging,
      getToken,
      onMessage
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-messaging.js";

    async function loadAppConfig() {
      if (window.__rideSyncConfigPromise) {
        return window.__rideSyncConfigPromise;
      }

      window.__rideSyncConfigPromise = fetch("/app-config.json", {
        cache: "no-store"
      })
        .then((res) => {
          if (!res.ok) {
            throw new Error(`Failed to load app config: ${res.status}`);
          }
          return res.json();
        })
        .catch((err) => {
          console.error("App config load failed", err);
          throw err;
        });

      return window.__rideSyncConfigPromise;
    }

    function loadGoogleMapsSdk({ apiKey, libraries = [] } = {}) {
      if (window.__rideSyncMapsPromise) {
        return window.__rideSyncMapsPromise;
      }

      window.__rideSyncMapsPromise = new Promise((resolve, reject) => {
        if (window.google && window.google.maps) {
          resolve(window.google.maps);
          return;
        }

        if (!apiKey) {
          reject(new Error("Missing Google Maps API key"));
          return;
        }

        const params = new URLSearchParams({ key: apiKey });
        if (libraries.length) {
          params.set("libraries", libraries.join(","));
        }

        const script = document.createElement("script");
        script.src = `https://maps.googleapis.com/maps/api/js?${params.toString()}`;
        script.async = true;
        script.defer = true;
        script.onload = () => {
          if (window.google && window.google.maps) {
            resolve(window.google.maps);
          } else {
            reject(new Error("Google Maps SDK loaded without maps namespace."));
          }
        };
        script.onerror = () => reject(new Error("Google Maps SDK failed to load."));
        document.head.appendChild(script);
      }).catch((err) => {
        window.__rideSyncMapsPromise = null;
        throw err;
      });

      return window.__rideSyncMapsPromise;
    }

    const APP_CONFIG = await loadAppConfig();
    const geoConfig = APP_CONFIG.geo || {};
    const placeholderConfig = APP_CONFIG.placeholders || {};
    const supportConfig = APP_CONFIG.support || {};
    const messagingConfig = APP_CONFIG.messaging || {};
    const mapsConfig = APP_CONFIG.maps || APP_CONFIG.googleMaps || {};
    const DEFAULT_MAPS_API_KEY = "AIzaSyDlYSl5rfovahECuBSbkELw2uyC6-Ucmr0";
    const mapsApiKey = mapsConfig.apiKey || DEFAULT_MAPS_API_KEY;
    const mapsLibraries =
      Array.isArray(mapsConfig.libraries) && mapsConfig.libraries.length
        ? mapsConfig.libraries
        : [];
    let googleMapsLoadFailed = false;

    const SUPPORT_PHONE_NUMBER = supportConfig.phoneNumber || "";
    const SUPPORT_TEL_LINK = SUPPORT_PHONE_NUMBER
      ? `tel:${SUPPORT_PHONE_NUMBER}`
      : "#";
    const SUPPORT_SMS_LINK = SUPPORT_PHONE_NUMBER
      ? `sms:${SUPPORT_PHONE_NUMBER}`
      : "#";
    const RIDER_PLACEHOLDER_AVATAR = placeholderConfig.riderAvatar || "";
    const DROPOFF_GEOFENCE_METERS =
      geoConfig.dropoffGeofenceMeters ?? 45; // ~150ft
    const PROFILE_PHOTO_MAX_BYTES = 4 * 1024 * 1024;
    const PROFILE_PHOTO_MAX_DIMENSION = 512;

    try {
      await setPersistence(auth, browserLocalPersistence);
    } catch (err) {
      console.warn("Failed to set driver auth persistence", err);
    }
    const messagingPublicVapidKey = messagingConfig.publicVapidKey || "";
    const messaging = (() => {
      try {
        return getMessaging(auth.app);
      } catch (err) {
        console.warn("Messaging init failed", err);
        return null;
      }
    })();
    let messagingToken = null;
    let messagingServiceWorkerRegistration = null;

    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("/firebase-messaging-sw.js")
        .then((registration) => {
          messagingServiceWorkerRegistration = registration;
        })
        .catch((err) => console.warn("Service worker registration failed", err));
    }

    const authView = document.getElementById("authView");
    const driverView = document.getElementById("driverView");
    const loginButton = document.getElementById("loginButton");
    const logoutButton = document.getElementById("logoutButton");
    const authError = document.getElementById("authError");
    const emailEl = document.getElementById("email");
    const passwordEl = document.getElementById("password");

    const driverAvatar = document.getElementById("driverAvatar");
    const driverAvatarChangeButton = document.getElementById("driverAvatarChangeButton");
    const driverAvatarUploadInput = document.getElementById("driverAvatarUploadInput");
    const driverNameEl = document.getElementById("driverName");
    const driverDetailEl = document.getElementById("driverDetail");
    const onlineDot = document.getElementById("onlineDot");
    const onlineLabel = document.getElementById("onlineLabel");
    const toggleOnlineButton = document.getElementById("toggleOnlineButton");
    const driverMessage = document.getElementById("driverMessage");
    const driverError = document.getElementById("driverError");
    const ridesList = document.getElementById("ridesList");
    const driverSyncSection = document.getElementById("driverSyncSection");
    const driverProfileSection = document.getElementById("driverProfileSection");
    const driverNavSyncButton = document.getElementById("driverNavSync");
    const driverNavProfileButton = document.getElementById("driverNavProfile");
    const driverProfileEditor = document.getElementById("driverProfileEditor");
    const driverEditNameInput = document.getElementById("driverEditName");
    const driverEditPhoneInput = document.getElementById("driverEditPhone");
    const driverEditVehicleYearInput = document.getElementById("driverEditVehicleYear");
    const driverEditVehicleMakeInput = document.getElementById("driverEditVehicleMake");
    const driverEditVehicleModelInput = document.getElementById("driverEditVehicleModel");
    const driverEditVehicleColorInput = document.getElementById("driverEditVehicleColor");
    const driverEditLicensePlateInput = document.getElementById("driverEditLicensePlate");
    const driverProfileSaveButton = document.getElementById("driverProfileSaveButton");
    const driverProfileEditorMessage = document.getElementById("driverProfileEditorMessage");
    const driverProfileEditorError = document.getElementById("driverProfileEditorError");
    const driverPhotoInput = document.getElementById("driverPhotoInput");
    const driverPhotoPreview = document.getElementById("driverPhotoPreview");
    const driverPhotoRemoveButton = document.getElementById("driverPhotoRemoveButton");
    const driverPhotoError = document.getElementById("driverPhotoError");

    try {
      await loadGoogleMapsSdk({ apiKey: mapsApiKey, libraries: mapsLibraries });
    } catch (err) {
      googleMapsLoadFailed = true;
      console.error("Google Maps SDK failed to load", err);
      if (driverError) {
        driverError.textContent = "Unable to load maps. Refresh or update the Maps API key.";
      }
    }

    const activeRideOverlay = document.getElementById("activeRideOverlay");
    const driverOverlayAvatarRow = document.getElementById("driverOverlayAvatarRow");
    const driverOverlayRiderNames = document.getElementById("driverOverlayRiderNames");
    const driverOverlayMembership = document.getElementById("driverOverlayMembership");
    const driverOverlayChips = document.getElementById("driverOverlayChips");
    const driverChatCard = document.getElementById("driverChatCard");
    const driverChatMessagesEl = document.getElementById("driverChatMessages");
    const driverChatInputEl = document.getElementById("driverChatInput");
    const driverChatSendButton = document.getElementById("driverChatSendButton");
    const driverChatOfflineNote = document.getElementById("driverChatOfflineNote");
    const driverStateOffer = document.getElementById("driverStateOffer");
    const driverStateNavPickup = document.getElementById("driverStateNavPickup");
    const driverStateEnterPickup = document.getElementById("driverStateEnterPickup");
    const driverStateNavDropoff = document.getElementById("driverStateNavDropoff");
    const driverStateEnterDropoff = document.getElementById("driverStateEnterDropoff");
    const driverStateComplete = document.getElementById("driverStateComplete");
    const driverOfferPickupText = document.getElementById("driverOfferPickupText");
    const driverOfferDropoffText = document.getElementById("driverOfferDropoffText");
    const driverOfferRiderCount = document.getElementById("driverOfferRiderCount");
    const driverOfferReserveRow = document.getElementById("driverOfferReserveRow");
    const driverOfferPickupTime = document.getElementById("driverOfferPickupTime");
    const driverOfferAcceptButton = document.getElementById("driverOfferAcceptButton");
    const driverOfferRejectButton = document.getElementById("driverOfferRejectButton");
    const driverNavPickupAddress = document.getElementById("driverNavPickupAddress");
    const driverNavPickupEta = document.getElementById("driverNavPickupEta");
    const driverNavDropoffAddress = document.getElementById("driverNavDropoffAddress");
    const driverDropoffEta = document.getElementById("driverDropoffEta");
    const driverArriveButton = document.getElementById("driverArriveButton");
    const pickupCodeInput = document.getElementById("pickupCodeInput");
    const pickupCodeError = document.getElementById("pickupCodeError");
    const driverPickupBackButton = document.getElementById("driverPickupBackButton");
    const driverPickupConfirmButton = document.getElementById("driverPickupConfirmButton");
    const driverGeofenceStatusEl = document.getElementById("driverGeofenceStatus");
    const driverCompleteButton = document.getElementById("driverCompleteButton");
    const driverCompleteOverrideButton = document.getElementById("driverCompleteOverrideButton");
    const dropoffCodeInput = document.getElementById("dropoffCodeInput");
    const dropoffCodeError = document.getElementById("dropoffCodeError");
    const driverDropoffConfirmButton = document.getElementById("driverDropoffConfirmButton");
    const driverWaitingStatus = document.getElementById("driverWaitingStatus");
    const driverRatingResult = document.getElementById("driverRatingResult");
    const driverTipResult = document.getElementById("driverTipResult");
    const driverCompleteDismissButton = document.getElementById("driverCompleteDismissButton");
    const driverCancelRideLink = document.getElementById("driverCancelRideLink");
    const activeRideError = document.getElementById("activeRideError");
    const closeActiveRideButton = document.getElementById("closeActiveRideButton");
    const driverPickupMapEl = document.getElementById("driverPickupMap");
    const driverPickupMapStatus = document.getElementById("driverPickupMapStatus");
    const driverPickupNavigateButton = document.getElementById("driverPickupNavigateButton");
    const driverDropoffMapEl = document.getElementById("driverDropoffMap");
    const driverDropoffMapStatus = document.getElementById("driverDropoffMapStatus");
    const driverDropoffNavigateButton = document.getElementById("driverDropoffNavigateButton");
    const driverNextRideSummary = document.getElementById("driverNextRideSummary");

    let currentUser = null;
    let currentDriverProfile = null;
    const driverSections = {
      sync: driverSyncSection,
      profile: driverProfileSection
    };
    const driverNavButtons = {
      sync: driverNavSyncButton,
      profile: driverNavProfileButton
    };
    let activeDriverSection = driverSyncSection ? "sync" : "profile";
    let map;
    let driverMarker;
    let pendingProfilePhotoDataUrl = null;
    let pendingProfilePhotoRemoved = false;
    let ridesUnsub = null;
    let isOnline = false;

    const DRIVER_STATES = {
      HIDDEN: "HIDDEN",
      OFFER: "DRIVER_RIDE_OFFER",
      NAV_PICKUP: "DRIVER_NAV_TO_PICKUP",
      ENTER_PICKUP: "DRIVER_ENTER_PICKUP_CODE",
      NAV_DROPOFF: "DRIVER_NAV_TO_DROPOFF",
      ENTER_DROPOFF: "DRIVER_ENTER_DROPOFF_CODE",
      COMPLETE: "DRIVER_RIDE_COMPLETE_WAITING_RATING"
    };

    let activeRideGroup = [];
    let activeRideWatchers = [];
    let pendingRideOffer = null;
    let driverOverlayState = DRIVER_STATES.HIDDEN;
    let driverOverlayDismissed = false;
    let driverCurrentPosition = null;
    let driverLocationWatcherId = null;
    let pickupNavMap;
    let pickupDirectionsRenderer;
    let pickupDirectionsService;
    let dropoffNavMap;
    let dropoffDirectionsRenderer;
    let dropoffDirectionsService;
    let activePickupLocation = null;
    let activeDropoffLocation = null;
    let geofenceOverride = false;
    const DRIVER_LOCATION_PUSH_INTERVAL_MS = 5000;
    const DRIVER_LOCATION_MIN_DELTA_METERS = 8;
    let lastDriverLocationPushAt = 0;
    let lastDriverLocationSent = null;
    let driverLocationUpdatePromise = null;
    let rideOfferQueue = [];
    const seenRideOfferIds = new Set();
    const NAV_ROUTE_REFRESH_MS = 15000;
    let lastPickupRouteAt = 0;
    let lastDropoffRouteAt = 0;
    const DRIVER_CHAT_ACTIVE_STATUSES = new Set([
      "driver_assigned",
      "driver_arrived",
      "arrived_at_pickup",
      "pickup_code_verified",
      "in_progress",
      "arrived_at_dropoff"
    ]);
    const DRIVER_CHAT_TERMINAL_STATUSES = new Set([
      "completed",
      "dropoff_code_verified",
      "canceled",
      "canceled_by_driver",
      "canceled_by_rider",
      "driver_declined"
    ]);
    const DRIVER_CHAT_MAX_LENGTH = 500;
    const DRIVER_CHAT_RATE_LIMIT_MS = 1200;
    const DRIVER_CHAT_FETCH_LIMIT = 200;
    let driverChatUnsub = null;
    let driverChatCurrentRideId = null;
    let driverChatLastSendAt = 0;
    // Web Audio tone to alert drivers when a new ride offer arrives.
    const rideAlertUnlockEvents = ["pointerdown", "touchstart", "keydown"];
    const AudioContextClass = window.AudioContext || window.webkitAudioContext || null;
    const rideAlertAudioContext =
      typeof AudioContextClass === "function" ? new AudioContextClass() : null;
    let rideAlertAudioUnlocked = !rideAlertAudioContext;

    function handleRideAlertUnlockEvent() {
      if (!rideAlertAudioContext || rideAlertAudioUnlocked) return;
      rideAlertAudioContext
        .resume()
        .then(() => {
          rideAlertAudioUnlocked = true;
          rideAlertUnlockEvents.forEach((evt) =>
            document.removeEventListener(evt, handleRideAlertUnlockEvent, true)
          );
        })
        .catch(() => {});
    }

    function registerRideAlertUnlockListeners() {
      if (!rideAlertAudioContext || rideAlertAudioUnlocked) return;
      rideAlertUnlockEvents.forEach((evt) => {
        document.addEventListener(evt, handleRideAlertUnlockEvent, {
          passive: true,
          capture: true
        });
      });
    }

    registerRideAlertUnlockListeners();

    function playRideAlertSound() {
      if (!rideAlertAudioContext || !rideAlertAudioUnlocked) return;
      if (rideAlertAudioContext.state === "suspended") {
        rideAlertAudioContext.resume().catch(() => {});
      }
      const ctx = rideAlertAudioContext;
      const now = ctx.currentTime;
      const oscillator = ctx.createOscillator();
      const gain = ctx.createGain();
      oscillator.type = "triangle";
      oscillator.frequency.setValueAtTime(880, now);
      oscillator.frequency.setValueAtTime(1320, now + 0.35);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.3, now + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.2);
      oscillator.connect(gain);
      gain.connect(ctx.destination);
      oscillator.start(now);
      oscillator.stop(now + 1.2);
    }
    const EARLY_ASSIGNMENT_MINUTES = 6;
    const RESERVED_DRIVER_RELEASE_MINUTES = 40;
    const RESERVED_VISIBILITY_REFRESH_MS = 30000;
    let queuedRideGroups = [];
    let latestVisiblePendingRides = [];
    let latestRideSnapshot = [];
    let hasScheduledPendingRides = false;
    let latestDropoffEtaMinutes = null;
    let rideAutoReservePromise = null;
    let earlyAssignmentRideId = null;
    let earlyAssignmentTriggered = false;

    function showAuth() {
      authView.classList.add("active");
      driverView.classList.remove("active");
    }
    function showDriver() {
      authView.classList.remove("active");
      driverView.classList.add("active");
    }

    function setDriverSection(section, { force = false } = {}) {
      if (!driverSections[section]) return;
      if (!force && activeDriverSection === section) return;

      Object.entries(driverSections).forEach(([key, el]) => {
        if (!el) return;
        const isActive = key === section;
        el.classList.toggle("active", isActive);
        el.setAttribute("aria-hidden", isActive ? "false" : "true");
      });

      Object.entries(driverNavButtons).forEach(([key, btn]) => {
        if (!btn) return;
        const isActive = key === section;
        btn.classList.toggle("active", isActive);
        btn.setAttribute("aria-selected", isActive ? "true" : "false");
        btn.tabIndex = isActive ? 0 : -1;
      });

      if (section === "profile") {
        if (driverProfileEditorMessage) driverProfileEditorMessage.textContent = "";
        if (driverProfileEditorError) driverProfileEditorError.textContent = "";
        driverProfileSection?.scrollIntoView({ behavior: "smooth", block: "start" });
      }

      activeDriverSection = section;
    }

    setDriverSection("sync", { force: true });

    function driverInitials(name) {
      return (name || "Driver")
        .split(" ")
        .filter(Boolean)
        .map((part) => part[0])
        .join("")
        .slice(0, 2)
        .toUpperCase() || "DR";
    }

    function getDriverDisplayName() {
      return currentDriverProfile?.fullName || currentUser?.email || "Driver";
    }

    function renderDriverAvatar(name, photoUrl) {
      if (!driverAvatar) return;
      driverAvatar.innerHTML = "";
      const safeUrl = safeImageUrl(photoUrl);
      if (safeUrl) {
        const img = document.createElement("img");
        img.src = safeUrl;
        img.alt = name || "Driver avatar";
        img.onerror = () => {
          driverAvatar.textContent = driverInitials(name);
        };
        driverAvatar.appendChild(img);
        return;
      }
      driverAvatar.textContent = driverInitials(name);
    }

    function updateDriverPhotoPreview(name, photoUrl) {
      if (!driverPhotoPreview) return;
      driverPhotoPreview.innerHTML = "";
      const safeUrl = safeImageUrl(photoUrl);
      if (safeUrl) {
        const img = document.createElement("img");
        img.src = safeUrl;
        img.alt = name || "Driver avatar";
        img.onerror = () => {
          driverPhotoPreview.textContent = driverInitials(name);
        };
        driverPhotoPreview.appendChild(img);
        return;
      }
      const span = document.createElement("span");
      span.className = "avatar-initials";
      span.textContent = driverInitials(name);
      driverPhotoPreview.appendChild(span);
    }

    function resetProfilePhotoDraft() {
      pendingProfilePhotoDataUrl = null;
      pendingProfilePhotoRemoved = false;
      if (driverPhotoInput) {
        driverPhotoInput.value = "";
      }
      if (driverPhotoError) {
        driverPhotoError.textContent = "";
      }
    }

    function getEditorPhotoPreviewUrl() {
      if (pendingProfilePhotoRemoved) return null;
      if (pendingProfilePhotoDataUrl) return pendingProfilePhotoDataUrl;
      return safeImageUrl(currentDriverProfile?.profilePicUrl) || null;
    }

    loginButton.addEventListener("click", async () => {
      authError.textContent = "";
      try {
        await signInWithEmailAndPassword(
          auth,
          emailEl.value.trim(),
          passwordEl.value.trim()
        );
      } catch (err) {
        console.error(err);
        authError.textContent = err.message || "Login failed.";
      }
    });

    logoutButton.addEventListener("click", async () => {
      try {
        await signOut(auth);
      } catch (err) {
        console.error(err);
      }
    });

    if (driverChatSendButton) {
      driverChatSendButton.addEventListener("click", handleDriverChatSend);
    }
    if (driverChatInputEl) {
      driverChatInputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          handleDriverChatSend();
        }
      });
    }

    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      if (!user) {
        showAuth();
        setOnline(false);
        driverAvatar.textContent = "DR";
        driverNameEl.textContent = "Driver";
        driverDetailEl.textContent = "";
        queuedRideGroups = [];
        clearActiveRideFlow({ skipQueuedRideStart: true });
        updateQueuedRideNotice();
        if (ridesUnsub) {
          ridesUnsub();
          ridesUnsub = null;
        }
        ridesList.innerHTML = "";
        resetProfilePhotoDraft();
        updateDriverPhotoPreview("Driver", null);
        if (driverProfileEditorMessage) driverProfileEditorMessage.textContent = "";
        if (driverProfileEditorError) driverProfileEditorError.textContent = "";
        setDriverSection("sync", { force: true });
        return;
      }

      showDriver();
      await loadDriverProfile();
      initMap();
      subscribeToRides();
      await ensureDriverMessaging();
    });

    async function loadDriverProfile() {
      try {
        const ref = doc(db, "drivers", currentUser.uid);
        const snap = await getDoc(ref);
        if (snap.exists()) {
          currentDriverProfile = snap.data();
        } else {
          currentDriverProfile = {
            fullName: currentUser.email || "Driver",
            phone: "",
            vehicleMake: "",
            vehicleModel: "",
            vehicleColor: "",
            licensePlate: ""
          };
          await setDoc(ref, {
            ...currentDriverProfile,
            createdAt: serverTimestamp()
          }, { merge: true });
        }

        const name = currentDriverProfile.fullName || currentUser.email || "Driver";
        driverNameEl.textContent = name;
        driverDetailEl.textContent =
          `${currentDriverProfile.vehicleYear || ""} ${currentDriverProfile.vehicleColor || ""} ${currentDriverProfile.vehicleMake || ""} ${currentDriverProfile.vehicleModel || ""}`.trim();

        renderDriverAvatar(name, currentDriverProfile.profilePicUrl);
        resetProfilePhotoDraft();
        populateDriverProfileEditor();
        updateDriverPhotoPreview(name, getEditorPhotoPreviewUrl());
      } catch (err) {
        console.error("loadDriverProfile error", err);
      }
    }

    function populateDriverProfileEditor() {
      if (!driverProfileEditor) return;
      const profile = currentDriverProfile || {};
      if (driverEditNameInput) {
        driverEditNameInput.value =
          profile.fullName ||
          currentUser?.email ||
          "";
      }
      if (driverEditPhoneInput) {
        driverEditPhoneInput.value = profile.phone || "";
      }
      if (driverEditVehicleYearInput) {
        driverEditVehicleYearInput.value = profile.vehicleYear || "";
      }
      if (driverEditVehicleMakeInput) {
        driverEditVehicleMakeInput.value = profile.vehicleMake || "";
      }
      if (driverEditVehicleModelInput) {
        driverEditVehicleModelInput.value = profile.vehicleModel || "";
      }
      if (driverEditVehicleColorInput) {
        driverEditVehicleColorInput.value = profile.vehicleColor || "";
      }
      if (driverEditLicensePlateInput) {
        driverEditLicensePlateInput.value = profile.licensePlate || "";
      }

      updateDriverPhotoPreview(
        profile.fullName ||
          currentUser?.email ||
          "Driver",
        getEditorPhotoPreviewUrl()
      );
    }

    async function saveDriverProfileChanges() {
      if (!driverProfileEditor) return;
      if (!currentUser) {
        if (driverProfileEditorError) {
          driverProfileEditorError.textContent = "Sign in to update your profile.";
        }
        return;
      }

      if (driverProfileEditorError) driverProfileEditorError.textContent = "";
      if (driverProfileEditorMessage) driverProfileEditorMessage.textContent = "";

      const fullName = (driverEditNameInput?.value || "").trim();
      if (!fullName) {
        if (driverProfileEditorError) {
          driverProfileEditorError.textContent = "Full name is required.";
        }
        return;
      }

      const payload = {
        fullName,
        phone: (driverEditPhoneInput?.value || "").trim(),
        vehicleYear: (driverEditVehicleYearInput?.value || "").trim(),
        vehicleMake: (driverEditVehicleMakeInput?.value || "").trim(),
        vehicleModel: (driverEditVehicleModelInput?.value || "").trim(),
        vehicleColor: (driverEditVehicleColorInput?.value || "").trim(),
        licensePlate: (driverEditLicensePlateInput?.value || "").trim(),
        updatedAt: serverTimestamp()
      };

      if (pendingProfilePhotoRemoved) {
        payload.profilePicUrl = null;
      } else if (pendingProfilePhotoDataUrl) {
        payload.profilePicUrl = pendingProfilePhotoDataUrl;
      }

      try {
        const ref = doc(db, "drivers", currentUser.uid);
        await updateDoc(ref, payload);
        driverMessage.textContent = "Driver profile updated.";
        driverError.textContent = "";
        await loadDriverProfile();
        if (driverProfileEditorMessage) {
          driverProfileEditorMessage.textContent = "Profile updated.";
        }
      } catch (err) {
        console.error("saveDriverProfileChanges error", err);
        if (driverProfileEditorError) {
          driverProfileEditorError.textContent =
            err.message || "Could not update driver profile.";
        }
      }
    }

    async function handleDriverPhotoSelected(event) {
      const file = event?.target?.files?.[0];
      if (!file) return;
      if (driverPhotoError) driverPhotoError.textContent = "";
      if (file.size > PROFILE_PHOTO_MAX_BYTES) {
        if (driverPhotoError) {
          driverPhotoError.textContent = "Choose a photo smaller than 4 MB.";
        }
        return;
      }
      try {
        const dataUrl = await prepareProfilePhoto(file);
        pendingProfilePhotoDataUrl = dataUrl;
        pendingProfilePhotoRemoved = false;
        updateDriverPhotoPreview(
          driverEditNameInput?.value?.trim() || getDriverDisplayName(),
          dataUrl
        );
      } catch (err) {
        console.error("handleDriverPhotoSelected error", err);
        if (driverPhotoError) {
          driverPhotoError.textContent = "Unable to process that photo. Try a smaller image.";
        }
      }
    }

    function handleDriverPhotoRemove() {
      pendingProfilePhotoDataUrl = null;
      pendingProfilePhotoRemoved = true;
      if (driverPhotoInput) driverPhotoInput.value = "";
      updateDriverPhotoPreview(
        driverEditNameInput?.value?.trim() || getDriverDisplayName(),
        null
      );
    }

    function handleDriverNameInputChange() {
      if (getEditorPhotoPreviewUrl()) return;
      updateDriverPhotoPreview(
        driverEditNameInput?.value?.trim() || getDriverDisplayName(),
        null
      );
    }

    function openDriverAvatarPicker() {
      if (!currentUser) {
        driverError.textContent = "Sign in to update your photo.";
        return;
      }
      driverAvatarUploadInput?.click();
    }

    function resetDriverAvatarPicker() {
      if (driverAvatarUploadInput) {
        driverAvatarUploadInput.value = "";
      }
    }

    async function handleDriverAvatarUpload(event) {
      const file = event?.target?.files?.[0];
      if (!file) return;
      if (!currentUser) {
        driverError.textContent = "Sign in to update your photo.";
        resetDriverAvatarPicker();
        return;
      }
      if (file.size > PROFILE_PHOTO_MAX_BYTES) {
        driverError.textContent = "Choose a photo smaller than 4 MB.";
        resetDriverAvatarPicker();
        return;
      }
      try {
        const dataUrl = await prepareProfilePhoto(file);
        const ref = doc(db, "drivers", currentUser.uid);
        await updateDoc(ref, {
          profilePicUrl: dataUrl,
          avatarUrl: dataUrl,
          photoURL: dataUrl,
          updatedAt: serverTimestamp()
        });
        driverMessage.textContent = "Profile photo updated.";
        driverError.textContent = "";
        resetDriverAvatarPicker();
        await loadDriverProfile();
      } catch (err) {
        console.error("handleDriverAvatarUpload error", err);
        driverError.textContent = err.message || "Unable to update photo.";
      }
    }

    async function prepareProfilePhoto(file) {
      const dataUrl = await readFileAsDataUrl(file);
      return resizeImageDataUrl(dataUrl, PROFILE_PHOTO_MAX_DIMENSION);
    }

    function readFileAsDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error || new Error("Failed to read file."));
        reader.readAsDataURL(file);
      });
    }

    function resizeImageDataUrl(dataUrl, maxDimension) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement("canvas");
          const scale = Math.min(1, maxDimension / Math.max(img.width, img.height));
          const width = Math.max(1, Math.round(img.width * scale));
          const height = Math.max(1, Math.round(img.height * scale));
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          if (!ctx) {
            reject(new Error("Could not process image."));
            return;
          }
          ctx.drawImage(img, 0, 0, width, height);
          resolve(canvas.toDataURL("image/jpeg", 0.9));
        };
        img.onerror = () => reject(new Error("Image failed to load."));
        img.src = dataUrl;
      });
    }

    function initMap() {
      if (googleMapsLoadFailed) return;
      if (!window.google || !google.maps) return;
      if (map) return;
      map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: 36.0626, lng: -94.1574 },
        zoom: 11,
        disableDefaultUI: true
      });

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const { latitude, longitude } = pos.coords;
            const loc = { lat: latitude, lng: longitude };
            map.setCenter(loc);
            driverCurrentPosition = loc;
            driverMarker = new google.maps.Marker({
              map,
              position: loc,
              title: "You"
            });
            evaluateDropoffGeofence();
            pushDriverLocationToFirestore(pos);
          },
          () => {}
        );
        startDriverLocationWatch();
      }
    }

    function setOnline(val) {
      isOnline = val;
      if (val) {
        onlineDot.classList.add("online");
        onlineLabel.textContent = "Online";
        toggleOnlineButton.textContent = "Sync offline";
      } else {
        onlineDot.classList.remove("online");
        onlineLabel.textContent = "Offline";
        toggleOnlineButton.textContent = "Sync online";
        resetRideOfferQueue();
        if (pendingRideOffer) {
          pendingRideOffer = null;
          if (driverOverlayState === DRIVER_STATES.OFFER) {
            setDriverOverlayState(DRIVER_STATES.HIDDEN);
          }
        }
      }
      refreshDriverRideVisibility();
    }

    async function ensureDriverMessaging() {
      if (!messaging || !messagingPublicVapidKey || !auth.currentUser) {
        return;
      }
      try {
        if (Notification.permission !== "granted") {
          const permission = await Notification.requestPermission();
          if (permission !== "granted") {
            return;
          }
        }
        const token = await getToken(messaging, {
          vapidKey: messagingPublicVapidKey,
          serviceWorkerRegistration: messagingServiceWorkerRegistration || undefined,
        });
        if (token && token !== messagingToken) {
          messagingToken = token;
          await setDoc(
            doc(db, "drivers", auth.currentUser.uid),
            {
              fcmToken: token,
              fcmTokenUpdatedAt: serverTimestamp(),
            },
            { merge: true }
          );
        }
      } catch (err) {
        console.warn("Unable to register driver messaging token", err);
      }
    }

    if (messaging) {
      onMessage(messaging, (payload) => {
        console.log("[RideSync][Driver] foreground notification", payload);
      });
    }

    function refreshDriverRideVisibility() {
      renderRides(latestRideSnapshot);
    }
    setInterval(() => {
      refreshDriverRideVisibility();
    }, RESERVED_VISIBILITY_REFRESH_MS);

    toggleOnlineButton.addEventListener("click", async () => {
      setOnline(!isOnline);
      driverMessage.textContent = isOnline ? "You are now online." : "You are offline.";
      driverError.textContent = "";
      try {
        const ref = doc(db, "drivers", currentUser.uid);
        await updateDoc(ref, {
          isOnline,
          lastOnlineAt: serverTimestamp()
        });
        if (isOnline) {
          await ensureDriverMessaging();
        }
      } catch (err) {
        console.error(err);
      }
    });

    function subscribeToRides() {
      if (ridesUnsub) {
        ridesUnsub();
        ridesUnsub = null;
      }
      const ridesRef = collection(db, "rideRequests");
      const q = query(ridesRef, orderBy("createdAt", "desc"), limit(40));
      ridesUnsub = onSnapshot(
        q,
        (snap) => {
          const rides = [];
          snap.forEach((docSnap) => {
            const d = docSnap.data();
            rides.push({ id: docSnap.id, ...d });
          });
          renderRides(rides);
        },
        (err) => {
          console.error("rides snapshot error", err);
          driverError.textContent = err.message || "Error loading rides.";
        }
      );
    }

    function membershipTag(m) {
      if (m === "uofa_unlimited") return '<span class="tag tag-uofa">U OF A STUDENT — UNLIMITED</span>';
      if (m === "nwa_unlimited") return '<span class="tag tag-nwa">NORTHWEST ARKANSAS — UNLIMITED</span>';
      if (m === "basic") return '<span class="tag tag-basic">Basic</span>';
      if (!m) return '<span class="tag tag-basic">Unknown</span>';
      return `<span class="tag tag-basic">${m}</span>`;
    }

    function safeImageUrl(url) {
      if (!url && url !== 0) return null;
      const value = String(url).trim();
      if (!value || value === "null" || value === "undefined") return null;
      return value;
    }

    function membershipLabel(value) {
      if (value === "uofa_unlimited") return "Membership: U OF A STUDENT — UNLIMITED";
      if (value === "nwa_unlimited") return "Membership: NORTHWEST ARKANSAS — UNLIMITED";
      if (value === "basic") return "Membership: Basic";
      if (!value) return "";
      return `Membership: ${value}`;
    }

    function pickupLabel(rider) {
      if (rider?.pickupAddress) return rider.pickupAddress;
      if (rider?.fromAddress) return rider.fromAddress;
      const loc = rider?.fromLocation;
      if (loc && typeof loc.lat === "number" && typeof loc.lng === "number") {
        return `${loc.lat.toFixed(4)}, ${loc.lng.toFixed(4)}`;
      }
      return "";
    }

    function dropoffLabel(rider) {
      return rider?.toDestination || rider?.toAddress || rider?.destAddress || "";
    }

    function resolveTimestampMillis(value) {
      if (!value && value !== 0) return null;
      if (typeof value.toMillis === "function") {
        const ms = value.toMillis();
        return Number.isFinite(ms) ? ms : null;
      }
      if (typeof value.toDate === "function") {
        const date = value.toDate();
        const ms = date?.getTime?.();
        return Number.isFinite(ms) ? ms : null;
      }
      if (typeof value === "number") {
        return Number.isFinite(value) ? value : null;
      }
      if (typeof value === "string") {
        const parsed = Date.parse(value);
        return Number.isNaN(parsed) ? null : parsed;
      }
      if (typeof value.seconds === "number") {
        const nanos =
          typeof value.nanoseconds === "number"
            ? value.nanoseconds
            : typeof value.nanosecond === "number"
            ? value.nanosecond
            : 0;
        return value.seconds * 1000 + Math.round(nanos / 1e6);
      }
      return null;
    }

    function resolveRideReserveDate(ride) {
      if (!ride) return null;
      const reserveDate =
        resolveTimestampMillis(ride.reservePickupAt) ??
        (ride.reserveTimeIso ? Date.parse(ride.reserveTimeIso) : null);
      if (!reserveDate || Number.isNaN(reserveDate)) {
        return null;
      }
      const date = new Date(reserveDate);
      return Number.isNaN(date.getTime()) ? null : date;
    }

    function formatReserveDisplay(date) {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
        return "";
      }
      return date.toLocaleString([], {
        weekday: "short",
        hour: "numeric",
        minute: "2-digit"
      });
    }

    function isRideReadyForDrivers(ride, nowMillis = Date.now()) {
      const reserveDate = resolveRideReserveDate(ride);
      if (!reserveDate) {
        return true;
      }
      const diffMs = reserveDate.getTime() - nowMillis;
      return diffMs <= RESERVED_DRIVER_RELEASE_MINUTES * 60000;
    }

    function riderInitials(name) {
      return (name || "RS")
        .split(" ")
        .filter(Boolean)
        .map((part) => part[0])
        .join("")
        .slice(0, 2)
        .toUpperCase() || "RS";
    }

    function renderDriverTopBar(riders) {
      if (!driverOverlayAvatarRow) return;
      const list = Array.isArray(riders) ? riders : [];
      driverOverlayAvatarRow.innerHTML = "";
      driverOverlayChips.innerHTML = "";

      if (!list.length) {
        driverOverlayRiderNames.textContent = "Awaiting rider";
        driverOverlayMembership.textContent = "";
        return;
      }

      const nameList = list
        .map((r, idx) => r?.riderName || `Rider ${idx + 1}`)
        .join(", ");
      driverOverlayRiderNames.textContent = nameList;

      const membershipText = membershipLabel(
        list[0]?.membershipType || list[0]?.membership
      )
        ?.replace("Membership: ", "") || "";
      driverOverlayMembership.textContent = membershipText;

      list.forEach((rider, index) => {
        const displayName = rider?.riderName || `Rider ${index + 1}`;
        const avatarWrapper = document.createElement("div");
        avatarWrapper.className = "driver-top-avatar";

        const avatarImg = document.createElement("img");
        avatarImg.alt = displayName;
        const fallback = document.createElement("div");
        fallback.className = "avatar-initials";
        fallback.textContent = riderInitials(displayName);

        const photoUrl =
          safeImageUrl(rider?.riderProfilePicUrl) ||
          safeImageUrl(rider?.riderPhotoUrl) ||
          safeImageUrl(rider?.riderAvatarUrl) ||
          safeImageUrl(rider?.riderImageUrl) ||
          null;
        if (photoUrl) {
          avatarImg.src = photoUrl;
          avatarImg.onerror = () => {
            avatarWrapper.classList.remove("has-photo");
            avatarImg.remove();
          };
          avatarWrapper.classList.add("has-photo");
          avatarWrapper.appendChild(avatarImg);
        }
        avatarWrapper.appendChild(fallback);
        driverOverlayAvatarRow.appendChild(avatarWrapper);

        const chip = document.createElement("span");
        chip.className = "driver-chip";
        chip.textContent = `Rider ${index + 1}`;
        driverOverlayChips.appendChild(chip);
      });
    }

    function renderDriverOfferReserveInfo(ride) {
      if (!driverOfferReserveRow || !driverOfferPickupTime) return;
      const reserveDate = resolveRideReserveDate(ride);
      if (!reserveDate) {
        driverOfferReserveRow.style.display = "none";
        driverOfferPickupTime.textContent = "";
        return;
      }
      const label = formatReserveDisplay(reserveDate);
      if (!label) {
        driverOfferReserveRow.style.display = "none";
        driverOfferPickupTime.textContent = "";
        return;
      }
      driverOfferPickupTime.textContent = label;
      driverOfferReserveRow.style.display = "block";
    }

    function sanitizeDriverChatText(value) {
      if (typeof value !== "string") return "";
      return value.replace(/[&<>]/g, (char) => {
        switch (char) {
          case "&":
            return "&amp;";
          case "<":
            return "&lt;";
          case ">":
            return "&gt;";
          default:
            return char;
        }
      });
    }

    function formatDriverChatTimestamp(ts) {
      if (!ts) return "";
      try {
        const date =
          typeof ts.toDate === "function"
            ? ts.toDate()
            : typeof ts.seconds === "number"
            ? new Date(ts.seconds * 1000)
            : new Date(ts);
        if (Number.isNaN(date.getTime())) return "";
        return date.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
      } catch (_) {
        return "";
      }
    }

    function ensureDriverChatCardVisible() {
      if (driverChatCard) {
        driverChatCard.style.display = "flex";
      }
    }

    function hideDriverChatCard() {
      if (driverChatCard) {
        driverChatCard.style.display = "none";
      }
    }

    function setDriverChatNote(message = "") {
      if (!driverChatOfflineNote) return;
      if (message) {
        driverChatOfflineNote.textContent = message;
        driverChatOfflineNote.style.display = "block";
      } else {
        driverChatOfflineNote.textContent = "";
        driverChatOfflineNote.style.display = "none";
      }
    }

    function setDriverChatUiEnabled(enabled, noteMessage = "") {
      if (driverChatInputEl) {
        driverChatInputEl.disabled = !enabled;
      }
      if (driverChatSendButton) {
        driverChatSendButton.disabled = !enabled;
      }
      if (!enabled && noteMessage) {
        setDriverChatNote(noteMessage);
      } else if (enabled) {
        setDriverChatNote("");
      }
    }

    function renderDriverChatMessages(docs) {
      if (!driverChatMessagesEl) return;
      const atBottom =
        driverChatMessagesEl.scrollHeight -
          driverChatMessagesEl.scrollTop -
          driverChatMessagesEl.clientHeight <
        40;
      driverChatMessagesEl.innerHTML = "";
      if (!docs?.length) {
        const placeholder = document.createElement("div");
        placeholder.className = "ride-chat-placeholder";
        placeholder.textContent = "No messages yet. Keep your rider updated.";
        driverChatMessagesEl.appendChild(placeholder);
        return;
      }
      docs.forEach((docSnap) => {
        const data = docSnap.data() || {};
        const senderId = data.senderUserId || "";
        const isSelf = Boolean(senderId && senderId === currentUser?.uid);
        const item = document.createElement("div");
        item.className = `ride-chat-message ${isSelf ? "from-self" : "from-peer"}`;

        const bubble = document.createElement("div");
        bubble.className = "ride-chat-bubble";
        bubble.innerHTML = sanitizeDriverChatText(data.text || "");

        const meta = document.createElement("div");
        meta.className = "ride-chat-meta";
        const nameLabel = isSelf ? "You" : "Rider";
        const timeLabel = formatDriverChatTimestamp(data.createdAt);
        meta.textContent = timeLabel ? `${nameLabel} • ${timeLabel}` : nameLabel;

        item.appendChild(bubble);
        item.appendChild(meta);
        driverChatMessagesEl.appendChild(item);
      });
      if (atBottom) {
        driverChatMessagesEl.scrollTop = driverChatMessagesEl.scrollHeight;
      }
    }

    function teardownDriverChat(hideCard = false) {
      if (driverChatUnsub) {
        driverChatUnsub();
        driverChatUnsub = null;
      }
      driverChatCurrentRideId = null;
      if (driverChatMessagesEl) {
        driverChatMessagesEl.innerHTML = "";
      }
      setDriverChatUiEnabled(false);
      if (hideCard) {
        hideDriverChatCard();
      }
    }

    function initDriverChat(rideId) {
      if (!rideId || !driverChatMessagesEl) {
        teardownDriverChat(true);
        return;
      }
      if (driverChatCurrentRideId === rideId && driverChatUnsub) {
        ensureDriverChatCardVisible();
        setDriverChatUiEnabled(true);
        return;
      }
      teardownDriverChat();
      driverChatCurrentRideId = rideId;
      ensureDriverChatCardVisible();
      const messagesRef = collection(db, "ride_chats", rideId, "messages");
      const chatQuery = query(messagesRef, orderBy("createdAt", "asc"), limit(DRIVER_CHAT_FETCH_LIMIT));
      driverChatUnsub = onSnapshot(
        chatQuery,
        (snapshot) => {
          renderDriverChatMessages(snapshot.docs);
        },
        (err) => {
          console.warn("driver chat watcher error", err);
          setDriverChatUiEnabled(false, "Chat is unavailable right now.");
        }
      );
    }

    function updateDriverChatState(rideId, status) {
      const normalizedStatus = (status || "").toLowerCase();
      const isActive = rideId && DRIVER_CHAT_ACTIVE_STATUSES.has(normalizedStatus);
      if (isActive) {
        initDriverChat(rideId);
        setDriverChatUiEnabled(true);
        return;
      }
      if (!rideId || DRIVER_CHAT_TERMINAL_STATUSES.has(normalizedStatus)) {
        teardownDriverChat(true);
        return;
      }
      teardownDriverChat(true);
      setDriverChatUiEnabled(false, "Chat becomes available once you accept the ride.");
    }

    async function handleDriverChatSend() {
      if (!driverChatInputEl || !driverChatSendButton) return;
      if (!driverChatCurrentRideId) return;
      const user = auth.currentUser;
      if (!user) {
        setDriverChatUiEnabled(false, "Sign in to chat with riders.");
        return;
      }
      const rawValue = driverChatInputEl.value || "";
      const trimmed = rawValue.trim();
      if (!trimmed) return;
      const normalized = trimmed.slice(0, DRIVER_CHAT_MAX_LENGTH);
      const now = Date.now();
      if (now - driverChatLastSendAt < DRIVER_CHAT_RATE_LIMIT_MS) {
        setDriverChatNote("Please wait a moment before sending another message.");
        return;
      }
      driverChatSendButton.disabled = true;
      driverChatInputEl.disabled = true;
      try {
        const messagesRef = collection(db, "ride_chats", driverChatCurrentRideId, "messages");
        const messageRef = doc(messagesRef);
        await setDoc(messageRef, {
          rideId: driverChatCurrentRideId,
          messageId: messageRef.id,
          senderRole: "driver",
          senderUserId: user.uid,
          text: normalized,
          createdAt: serverTimestamp()
        });
        driverChatLastSendAt = now;
        driverChatInputEl.value = "";
        setDriverChatUiEnabled(true);
        setDriverChatNote("");
        if (driverChatMessagesEl) {
          driverChatMessagesEl.scrollTop = driverChatMessagesEl.scrollHeight;
        }
      } catch (err) {
        console.error("driver chat send error", err);
        setDriverChatNote("Unable to send message. Try again in a moment.");
      } finally {
        driverChatInputEl.disabled = false;
        driverChatSendButton.disabled = false;
      }
    }

    function setDriverOverlayState(state, options = {}) {
      const { forceReveal = false } = options;
      driverOverlayState = state;
      if (state === DRIVER_STATES.HIDDEN) {
        activeRideOverlay?.classList.remove("active");
        return;
      }
      if (forceReveal) {
        driverOverlayDismissed = false;
      }
      const pairs = [
        [driverStateOffer, DRIVER_STATES.OFFER],
        [driverStateNavPickup, DRIVER_STATES.NAV_PICKUP],
        [driverStateEnterPickup, DRIVER_STATES.ENTER_PICKUP],
        [driverStateNavDropoff, DRIVER_STATES.NAV_DROPOFF],
        [driverStateEnterDropoff, DRIVER_STATES.ENTER_DROPOFF],
        [driverStateComplete, DRIVER_STATES.COMPLETE]
      ];
      pairs.forEach(([el, key]) => {
        if (!el) return;
        if (state === key) {
          el.classList.add("active");
        } else {
          el.classList.remove("active");
        }
      });
      if (!driverOverlayDismissed) {
        activeRideOverlay?.classList.add("active");
      }
      evaluateDropoffGeofence();
      if (driverCompleteOverrideButton && state !== DRIVER_STATES.NAV_DROPOFF) {
        driverCompleteOverrideButton.style.display = "none";
      }
      if (state === DRIVER_STATES.NAV_PICKUP) {
        resizeInsetMap(pickupNavMap);
        refreshNavigationRoutes({ force: true });
      }
      if (state === DRIVER_STATES.NAV_DROPOFF) {
        resizeInsetMap(dropoffNavMap);
        refreshNavigationRoutes({ force: true });
      }
    }

    function openRideOfferOverlay(ride) {
      if (!ride) return;
      pendingRideOffer = ride;
      activeRideError.textContent = "";
      renderDriverTopBar([ride]);
      driverOfferPickupText.textContent = pickupLabel(ride) || "Pickup pending";
      driverOfferDropoffText.textContent = dropoffLabel(ride) || "Dropoff pending";
      const riderCount = ride?.numRiders || ride?.riderCount || ride?.currentRiderCount || 1;
      driverOfferRiderCount.textContent = `${riderCount} rider${riderCount === 1 ? "" : "s"}`;
      renderDriverOfferReserveInfo(ride);
      setDriverOverlayState(DRIVER_STATES.OFFER, { forceReveal: true });
      playRideAlertSound();
    }

    function renderRides(allRides) {
      const sourceRides = Array.isArray(allRides) ? allRides : [];
      latestRideSnapshot = sourceRides.slice();
      const allowedStatuses = ["pending_driver", "pool_searching", "pooled_pending_driver", "pending"];
      const now = Date.now();
      const visible = sourceRides.filter((r) => {
        if (!isOnline) return false;
        if (r.driverId) return false;
        const st = r.status || "pending";
        if (!allowedStatuses.includes(st)) return false;
        return isRideReadyForDrivers(r, now);
      });
      const scheduledPending = sourceRides.some((ride) => {
        if (ride.driverId) return false;
        const st = ride.status || "pending";
        if (!allowedStatuses.includes(st)) return false;
        return !isRideReadyForDrivers(ride, now);
      });
      hasScheduledPendingRides = scheduledPending;

      latestVisiblePendingRides = visible;
      syncRideOfferQueue(visible);
      updateRidesListMessage(visible, { scheduledPending });
      maybeTriggerEarlyNextRide();
      maybeShowNextRideOffer();
    }

    function updateRidesListMessage(visibleRides, { scheduledPending } = {}) {
      if (!ridesList) return;
      if (!isOnline) {
        ridesList.innerHTML = '<div class="small">Go online to receive ride requests.</div>';
        return;
      }
      const pendingScheduled =
        typeof scheduledPending === "boolean" ? scheduledPending : hasScheduledPendingRides;
      const pendingCount = rideOfferQueue.length + (pendingRideOffer ? 1 : 0);
      if (!visibleRides.length && pendingCount === 0) {
        ridesList.innerHTML = pendingScheduled
          ? '<div class="small">Next reserved ride is scheduled for later. We\'ll alert you 40 minutes before pickup.</div>'
          : '<div class="small">Awaiting new ride requests… they will appear as overlays.</div>';
        return;
      }
      ridesList.innerHTML = `<div class="small">Ride offers pop up automatically. ${
        pendingCount
          ? `Reviewing ${pendingCount} ride request${pendingCount === 1 ? "" : "s"}…`
          : "Processing latest ride data…"
      }</div>`;
    }

    function syncRideOfferQueue(visibleRides) {
      const visibleMap = new Map();
      visibleRides.forEach((ride) => {
        visibleMap.set(ride.id, ride);
      });

      rideOfferQueue = rideOfferQueue.filter((ride) => visibleMap.has(ride.id));

      if (pendingRideOffer && !visibleMap.has(pendingRideOffer.id)) {
        pendingRideOffer = null;
        if (!activeRideGroup.length) {
          setDriverOverlayState(DRIVER_STATES.HIDDEN);
          maybeShowNextRideOffer();
        }
      }

      visibleRides.forEach((ride) => {
        if (!seenRideOfferIds.has(ride.id)) {
          seenRideOfferIds.add(ride.id);
          rideOfferQueue.push(ride);
        }
      });

      pruneSeenRideOffers(visibleMap);
    }

    function pruneSeenRideOffers(visibleMap) {
      if (seenRideOfferIds.size <= 200) return;
      seenRideOfferIds.forEach((id) => {
        if (!visibleMap.has(id)) {
          seenRideOfferIds.delete(id);
        }
      });
    }

    function resetRideOfferQueue() {
      rideOfferQueue = [];
      seenRideOfferIds.clear();
    }

    function updateQueuedRideNotice() {
      if (!driverNextRideSummary) return;
      if (!queuedRideGroups.length) {
        driverNextRideSummary.style.display = "none";
        driverNextRideSummary.textContent = "";
        return;
      }
      const nextGroup = queuedRideGroups[0];
      if (!Array.isArray(nextGroup) || !nextGroup.length) {
        driverNextRideSummary.style.display = "none";
        driverNextRideSummary.textContent = "";
        return;
      }
      const names = nextGroup
        .map((ride, idx) => ride?.riderName || `Rider ${idx + 1}`)
        .join(", ");
      const pickup = pickupLabel(nextGroup[0]) || "Pickup pending";
      driverNextRideSummary.textContent = `Next rider queued: ${names} — pickup ${pickup}`;
      driverNextRideSummary.style.display = "block";
    }

    function queueRideGroup(group) {
      if (!Array.isArray(group) || !group.length) return;
      queuedRideGroups.push(group);
      updateQueuedRideNotice();
    }

    function startQueuedRideIfAvailable() {
      if (activeRideGroup.length) {
        updateQueuedRideNotice();
        return;
      }
      if (!queuedRideGroups.length) {
        updateQueuedRideNotice();
        maybeShowNextRideOffer();
        return;
      }
      const nextGroup = queuedRideGroups.shift();
      updateQueuedRideNotice();
      if (Array.isArray(nextGroup) && nextGroup.length) {
        beginDriverRideFlow(nextGroup);
      } else {
        startQueuedRideIfAvailable();
      }
    }

    function handleRideAssignment(group) {
      if (!Array.isArray(group) || !group.length) {
        maybeShowNextRideOffer();
        return;
      }
      if (activeRideGroup.length) {
        queueRideGroup(group);
        driverMessage.textContent = "Next rider reserved. Finish current trip first.";
        return;
      }
      beginDriverRideFlow(group);
    }

    function maybeShowNextRideOffer() {
      if (pendingRideOffer) return;
      if (activeRideGroup.length) return;
      if (!rideOfferQueue.length) return;
      const nextRide = rideOfferQueue.shift();
      if (nextRide) {
        openRideOfferOverlay(nextRide);
      }
    }

    function setLatestDropoffEta(minutes) {
      if (Number.isFinite(minutes)) {
        latestDropoffEtaMinutes = Math.max(0, minutes);
      } else {
        latestDropoffEtaMinutes = null;
      }
      maybeTriggerEarlyNextRide();
    }

    function maybeTriggerEarlyNextRide() {
      if (!activeRideGroup.length) return;
      if (queuedRideGroups.length) return;
      if (!rideOfferQueue.length) return;
      if (
        driverOverlayState !== DRIVER_STATES.NAV_DROPOFF &&
        driverOverlayState !== DRIVER_STATES.ENTER_DROPOFF
      ) {
        return;
      }
      if (!Number.isFinite(latestDropoffEtaMinutes)) return;
      if (latestDropoffEtaMinutes > EARLY_ASSIGNMENT_MINUTES) return;
      const rideId = getPrimaryRideId();
      if (!rideId) return;
      if (earlyAssignmentRideId !== rideId) {
        earlyAssignmentRideId = rideId;
        earlyAssignmentTriggered = false;
      }
      if (earlyAssignmentTriggered) return;
      reserveNextRideFromQueue({ reason: "auto" });
    }

    function reserveNextRideFromQueue({ reason = "manual" } = {}) {
      if (!rideOfferQueue.length) return;
      if (rideAutoReservePromise) return;
      const ride = rideOfferQueue.shift();
      rideAutoReservePromise = (async () => {
        try {
          const group = await acceptRide(ride);
          if (Array.isArray(group) && group.length) {
            queueRideGroup(group);
            if (reason === "auto") {
              earlyAssignmentTriggered = true;
              driverMessage.textContent =
                "Reserved the next rider while you finish this trip.";
            }
          }
        } catch (err) {
          console.error("reserveNextRideFromQueue error", err);
          rideOfferQueue.unshift(ride);
        } finally {
          rideAutoReservePromise = null;
          updateRidesListMessage(latestVisiblePendingRides, {
            scheduledPending: hasScheduledPendingRides
          });
          maybeTriggerEarlyNextRide();
        }
      })();
    }

    async function getUnassignedGroupRides(ride) {
      if (!ride) return [];
      if (!(ride.isGroupRide || ride.groupId) || !ride.groupId) {
        return [ride];
      }

      try {
        const q = query(
          collection(db, "rideRequests"),
          where("groupId", "==", ride.groupId)
        );
        const snap = await getDocs(q);
        const rides = [];
        snap.forEach((docSnap) => {
          const data = docSnap.data();
          if (!data.driverId) {
            rides.push({ id: docSnap.id, ...data });
          }
        });
        return rides.length ? rides : [ride];
      } catch (err) {
        console.error("getUnassignedGroupRides error", err);
        return [ride];
      }
    }

    async function declineRide(ride) {
      if (!currentUser) return;
      driverError.textContent = "";
      driverMessage.textContent = "";

      try {
        const groupRides = await getUnassignedGroupRides(ride);

        const batch = writeBatch(db);
        groupRides.forEach((r) => {
          const ref = doc(db, "rideRequests", r.id);
          batch.update(ref, {
            status: "driver_declined",
            driverId: null,
            driverDeclinedAt: serverTimestamp()
          });
        });

        await batch.commit();
        driverMessage.textContent = `Declined ${groupRides.length} ride(s).`;
      } catch (err) {
        console.error("declineRide error", err);
        driverError.textContent = err.message || "Error declining ride.";
      }
    }

    async function acceptRide(ride) {
      if (!currentUser) return null;
      driverError.textContent = "";
      driverMessage.textContent = "";

      try {
        const groupRides = await getUnassignedGroupRides(ride);

        const batch = writeBatch(db);
        const driverRef = doc(db, "drivers", currentUser.uid);
        const driverSnap = await getDoc(driverRef);
        if (driverSnap.exists()) {
          currentDriverProfile = { ...currentDriverProfile, ...driverSnap.data() };
        }

        const driverPhotoUrl =
          currentDriverProfile?.profilePicUrl ||
          currentDriverProfile?.avatarUrl ||
          currentDriverProfile?.photoURL ||
          null;
        const driverVehicleName = [
          currentDriverProfile?.vehicleYear,
          currentDriverProfile?.vehicleColor,
          currentDriverProfile?.vehicleMake,
          currentDriverProfile?.vehicleModel
        ]
          .filter(Boolean)
          .join(" ")
          .replace(/\s+/g, " ")
          .trim();
        const driverVehiclePhoto =
          currentDriverProfile?.vehiclePhotoUrl ||
          currentDriverProfile?.vehicleImageUrl ||
          null;
        const driverLicenseImage =
          currentDriverProfile?.licensePicUrl ||
          currentDriverProfile?.licenseImageUrl ||
          null;
        const driverPhone = currentDriverProfile?.phone || "";
        const driverRating =
          typeof currentDriverProfile?.rating === "number"
            ? currentDriverProfile.rating
            : null;
        const driverRatingCount =
          typeof currentDriverProfile?.ratingCount === "number"
            ? currentDriverProfile.ratingCount
            : null;

        const driverInfo = {
          driverId: currentUser.uid,
          driverEmail: currentUser.email || "",
          driverName: currentDriverProfile?.fullName || currentUser.email || "Driver",
          driverPhone,
          driverPhotoUrl,
          driverAvatarUrl: driverPhotoUrl,
          driverProfilePicUrl: driverPhotoUrl,
          driverVehicleMake: currentDriverProfile?.vehicleMake || "",
          driverVehicleModel: currentDriverProfile?.vehicleModel || "",
          driverVehicleColor: currentDriverProfile?.vehicleColor || "",
          driverVehicleYear: currentDriverProfile?.vehicleYear || "",
          driverVehicleName,
          driverVehicleDisplayName: driverVehicleName,
          driverVehiclePhotoUrl: driverVehiclePhoto,
          driverVehiclePlate: currentDriverProfile?.licensePlate || "",
          driverLicensePlate: currentDriverProfile?.licensePlate || "",
          driverLicenseStatus: currentDriverProfile?.licenseStatus || null,
          driverLicenseSummary: currentDriverProfile?.licenseStatus || null,
          driverLicenseMeta: currentDriverProfile?.licenseMeta || null,
          driverLicenseLast4: currentDriverProfile?.licenseLast4 || null,
          driverLicenseImageUrl: driverLicenseImage,
          driverLicensePhotoUrl: driverLicenseImage,
          driverLicenseVerified: !!currentDriverProfile?.licenseVerified,
          driverRating,
          driverRatingCount,
          driverVerifiedId: !!currentDriverProfile?.verifiedId,
          driverDrugTestCleared: !!currentDriverProfile?.drugTestCleared,
          driverBackgroundCheckCleared: !!currentDriverProfile?.backgroundCheckCleared,
          driverContactViaRideSync: !driverPhone,
          status: "driver_assigned",
          assignedAt: serverTimestamp()
        };

        groupRides.forEach((r) => {
          const ref = doc(db, "rideRequests", r.id);
          batch.update(ref, driverInfo);
        });

        await batch.commit();

        driverMessage.textContent = `Assigned to ${groupRides.length} rider(s).`;

        return groupRides.map((r) => ({
          ...r,
          ...driverInfo
        }));
      } catch (err) {
        console.error("acceptRide error", err);
        driverError.textContent = err.message || "Error accepting ride.";
        throw err;
      }
    }

    function clearActiveRideWatchers() {
      activeRideWatchers.forEach((unsub) => {
        if (typeof unsub === "function") unsub();
      });
      activeRideWatchers = [];
    }

    function getPrimaryRide() {
      return activeRideGroup.length ? activeRideGroup[0] : null;
    }

    function getPrimaryRideId() {
      const primary = getPrimaryRide();
      return primary ? primary.id : null;
    }

    function beginDriverRideFlow(groupRides) {
      if (!Array.isArray(groupRides) || !groupRides.length) return;
      driverOverlayDismissed = false;
      earlyAssignmentRideId = groupRides[0]?.id || null;
      earlyAssignmentTriggered = false;
      latestDropoffEtaMinutes = null;
      subscribeToActiveRideGroup(groupRides);
      setDriverOverlayState(DRIVER_STATES.NAV_PICKUP, { forceReveal: true });
    }

    function subscribeToActiveRideGroup(group) {
      clearActiveRideWatchers();
      activeRideGroup = group.slice();
      if (!activeRideGroup.length) {
        setDriverOverlayState(DRIVER_STATES.HIDDEN);
        return;
      }
      renderDriverTopBar(activeRideGroup);
      updateDriverStateFromRide(activeRideGroup[0]);
      activeRideWatchers = activeRideGroup.map((ride, index) => {
        const ref = doc(db, "rideRequests", ride.id);
        return onSnapshot(ref, (snap) => {
          if (!snap.exists()) return;
          const data = { id: snap.id, ...snap.data() };
          activeRideGroup[index] = data;
          renderDriverTopBar(activeRideGroup);
          if (index === 0) {
            updateDriverStateFromRide(data);
          }
        });
      });
    }

    function clearActiveRideFlow(options = {}) {
      const { skipQueuedRideStart = false } = options;
      clearActiveRideWatchers();
      activeRideGroup = [];
      activePickupLocation = null;
      activeDropoffLocation = null;
      lastPickupRouteAt = 0;
      lastDropoffRouteAt = 0;
      geofenceOverride = false;
      pendingRideOffer = null;
      driverOverlayDismissed = false;
      activeRideError.textContent = "";
      latestDropoffEtaMinutes = null;
      earlyAssignmentRideId = null;
      earlyAssignmentTriggered = false;
      teardownDriverChat(true);
      setDriverOverlayState(DRIVER_STATES.HIDDEN);
      if (!skipQueuedRideStart) {
        startQueuedRideIfAvailable();
      }
    }

    function normalizedRideStatus(ride) {
      const status = (ride?.status || "").toLowerCase();
      if (status === "driver_arrived") return "arrived_at_pickup";
      if (status === "in_progress") return "pickup_code_verified";
      return status;
    }

    function updateDriverStateFromRide(ride) {
      if (!ride) {
        setDriverOverlayState(DRIVER_STATES.HIDDEN);
        return;
      }

      const status = normalizedRideStatus(ride);

      switch (status) {
        case "driver_assigned":
        case "pending_driver":
        case "pool_searching":
        case "pooled_pending_driver":
          updateNavPickupView(ride);
          setDriverOverlayState(DRIVER_STATES.NAV_PICKUP, { forceReveal: true });
          break;
        case "arrived_at_pickup": {
          const enteringPickup = driverOverlayState !== DRIVER_STATES.ENTER_PICKUP;
          if (enteringPickup) {
            updatePickupCodeView(ride);
          }
          setDriverOverlayState(DRIVER_STATES.ENTER_PICKUP, { forceReveal: true });
          break;
        }
        case "pickup_code_verified":
          updateNavDropoffView(ride);
          setDriverOverlayState(DRIVER_STATES.NAV_DROPOFF, { forceReveal: true });
          break;
        case "arrived_at_dropoff": {
          const enteringDropoff = driverOverlayState !== DRIVER_STATES.ENTER_DROPOFF;
          if (enteringDropoff) {
            updateDropoffCodeView();
          }
          setDriverOverlayState(DRIVER_STATES.ENTER_DROPOFF, { forceReveal: true });
          break;
        }
        case "dropoff_code_verified":
        case "completed":
          updateCompleteState(ride);
          setDriverOverlayState(DRIVER_STATES.COMPLETE, { forceReveal: true });
          break;
        case "canceled_by_rider":
          driverMessage.textContent = "Rider canceled the ride.";
          clearActiveRideFlow();
          break;
        default:
          updateNavPickupView(ride);
          setDriverOverlayState(DRIVER_STATES.NAV_PICKUP, { forceReveal: true });
      }
      const rideId = ride?.id || ride?.rideId || null;
      updateDriverChatState(rideId, status);
    }

    function updateNavPickupView(ride) {
      driverNavPickupAddress.textContent = pickupLabel(ride) || "Pickup pending";
      const etaMinutes =
        ride?.driverEtaMinutes ??
        ride?.pickupEtaMinutes ??
        ride?.estimatedDurationMinutes ??
        null;
      driverNavPickupEta.textContent = etaMinutes
        ? `Approx. ${Math.max(1, Math.round(etaMinutes))} min away`
        : "";
      activePickupLocation = extractPickupLocation(ride);
      renderPickupNavigation(ride, { force: true });
    }

    function updatePickupCodeView() {
      pickupCodeInput.value = "";
      pickupCodeError.textContent = "";
    }

    function updateNavDropoffView(ride) {
      driverNavDropoffAddress.textContent = dropoffLabel(ride) || "Destination pending";
      const etaMinutes =
        ride?.remainingEtaMinutes ??
        ride?.estimatedDurationMinutes ??
        null;
      if (Number.isFinite(etaMinutes)) {
        driverDropoffEta.textContent = `Arriving in about ${Math.max(
          1,
          Math.round(etaMinutes)
        )} min`;
      } else {
        driverDropoffEta.textContent = "";
      }
      setLatestDropoffEta(etaMinutes);
      activeDropoffLocation = extractDropoffLocation(ride);
      geofenceOverride = false;
      driverCompleteOverrideButton.style.display = activeDropoffLocation ? "none" : "inline-flex";
      evaluateDropoffGeofence();
      renderDropoffNavigation(ride, { force: true });
    }

    function updateDropoffCodeView() {
      dropoffCodeInput.value = "";
      dropoffCodeError.textContent = "";
    }

    function updateCompleteState(ride) {
      driverWaitingStatus.textContent =
        ride?.rating || ride?.riderRating
          ? "Rider feedback received."
          : "Waiting for rider rating and tip…";

      const ratingValue =
        ride?.rating ??
        ride?.riderRating ??
        ride?.driverRating ??
        null;
      if (typeof ratingValue === "number") {
        driverRatingResult.style.display = "block";
        driverRatingResult.textContent = `Rider rating: ${ratingValue.toFixed(1)} ★`;
      } else {
        driverRatingResult.style.display = "none";
      }

      const tipValue =
        ride?.tip ??
        ride?.tipAmount ??
        ride?.tip_value ??
        ride?.riderTip ??
        null;
      if (typeof tipValue === "number" && !Number.isNaN(tipValue) && tipValue > 0) {
        driverTipResult.style.display = "block";
        driverTipResult.textContent = `Tip: $${Number(tipValue).toFixed(2)}`;
      } else {
        driverTipResult.style.display = "none";
      }

      if (driverRatingResult.style.display === "block" || driverTipResult.style.display === "block") {
        driverCompleteDismissButton.style.display = "block";
      } else {
        driverCompleteDismissButton.style.display = "none";
      }
    }

    function getPickupCodeFromRide(ride) {
      return (
        ride?.pickupCode ??
        ride?.pickup_code ??
        ride?.pickupPin ??
        ride?.pickupPIN ??
        ride?.boardingCode ??
        null
      );
    }

    function getDropoffCodeFromRide(ride) {
      return (
        ride?.dropoffCode ??
        ride?.dropoff_code ??
        ride?.dropoffPin ??
        ride?.dropoffPIN ??
        ride?.dropoffBoardingCode ??
        null
      );
    }

    function normalizeRideCode(value) {
      if (value == null) return "";
      return String(value).trim().toUpperCase();
    }

    async function handleDriverOfferAccept() {
      if (!pendingRideOffer) return;
      const ride = pendingRideOffer;
      activeRideError.textContent = "";
      driverOfferAcceptButton.disabled = true;
      driverOfferRejectButton.disabled = true;
      try {
        const group = await acceptRide(ride);
        pendingRideOffer = null;
        handleRideAssignment(group);
      } catch (err) {
        activeRideError.textContent = err.message || "Error accepting ride.";
      } finally {
        driverOfferAcceptButton.disabled = false;
        driverOfferRejectButton.disabled = false;
      }
    }

    async function handleDriverOfferReject() {
      if (!pendingRideOffer) {
        setDriverOverlayState(DRIVER_STATES.HIDDEN);
        return;
      }
      const ride = pendingRideOffer;
      activeRideError.textContent = "";
      driverOfferAcceptButton.disabled = true;
      driverOfferRejectButton.disabled = true;
      try {
        await declineRide(ride);
        pendingRideOffer = null;
        setDriverOverlayState(DRIVER_STATES.HIDDEN);
        maybeShowNextRideOffer();
      } catch (err) {
        activeRideError.textContent = err.message || "Error declining ride.";
      } finally {
        driverOfferAcceptButton.disabled = false;
        driverOfferRejectButton.disabled = false;
      }
    }

    async function handleDriverArriveAtPickup() {
      await updateActiveRideFields({
        status: "arrived_at_pickup",
        arrivedAtPickupAt: serverTimestamp()
      });
    }

    function handlePickupBack() {
      updateNavPickupView(getPrimaryRide());
      setDriverOverlayState(DRIVER_STATES.NAV_PICKUP, { forceReveal: true });
    }

    async function handlePickupCodeConfirm() {
      const code = pickupCodeInput.value.trim();
      pickupCodeError.textContent = "";
      if (!code) {
        pickupCodeError.textContent = "Enter the pickup code.";
        return;
      }
      const ride = getPrimaryRide();
      const expected = getPickupCodeFromRide(ride);
      if (expected && normalizeRideCode(code) !== normalizeRideCode(expected)) {
        pickupCodeError.textContent = "Code does not match. Try again.";
        return;
      }
      await updateActiveRideFields({
        status: "pickup_code_verified",
        pickupCodeVerified: true,
        pickupCodeEntered: code,
        pickupCodeVerifiedAt: serverTimestamp()
      });
    }

    async function handleDriverArriveAtDropoff() {
      await updateActiveRideFields({
        status: "arrived_at_dropoff",
        arrivedAtDropoffAt: serverTimestamp()
      });
    }

    async function handleDropoffCodeConfirm() {
      const code = dropoffCodeInput.value.trim();
      dropoffCodeError.textContent = "";
      if (!code) {
        dropoffCodeError.textContent = "Enter the dropoff code.";
        return;
      }
      const ride = getPrimaryRide();
      const expected = getDropoffCodeFromRide(ride);
      if (expected && normalizeRideCode(code) !== normalizeRideCode(expected)) {
        dropoffCodeError.textContent = "Code does not match. Try again.";
        return;
      }
      await updateActiveRideFields({
        status: "completed",
        dropoffCodeVerified: true,
        dropoffCodeEntered: code,
        dropoffCodeVerifiedAt: serverTimestamp(),
        completedAt: serverTimestamp()
      });
    }

    function handleRideCompleteDismiss() {
      clearActiveRideFlow();
    }

    async function updateActiveRideFields(fields) {
      if (!activeRideGroup.length) return;
      activeRideError.textContent = "";
      try {
        const batch = writeBatch(db);
        activeRideGroup.forEach((r) => {
          const ref = doc(db, "rideRequests", r.id);
          batch.update(ref, fields);
        });
        await batch.commit();
      } catch (err) {
        console.error("updateActiveRideFields error", err);
        activeRideError.textContent = err.message || "Error updating ride.";
      }
    }

    async function cancelActiveRideAsDriver() {
      activeRideError.textContent = "";
      driverError.textContent = "";
      if (driverCancelRideLink) {
        driverCancelRideLink.disabled = true;
      }
      try {
        if (!activeRideGroup.length) {
          if (pendingRideOffer) {
            await handleDriverOfferReject();
            if (!pendingRideOffer) {
              driverMessage.textContent = "Ride canceled.";
            }
          } else {
            setDriverOverlayState(DRIVER_STATES.HIDDEN);
          }
          return;
        }

        const batch = writeBatch(db);
        activeRideGroup.forEach((r) => {
          const ref = doc(db, "rideRequests", r.id);
          batch.update(ref, {
            status: "canceled_by_driver",
            driverCanceledAt: serverTimestamp()
          });
        });
        await batch.commit();
        driverMessage.textContent = "Ride canceled.";
        clearActiveRideFlow();
      } catch (err) {
        console.error("cancelActiveRideAsDriver error", err);
        activeRideError.textContent = err.message || "Error canceling ride.";
      } finally {
        if (driverCancelRideLink) {
          driverCancelRideLink.disabled = false;
        }
      }
    }

    function extractPickupLocation(ride) {
      const candidates = [
        ride?.pickupLocation,
        ride?.fromLocation,
        ride?.originLocation,
        ride?.pickupGeo,
        ride?.pickupCoordinates,
        ride?.fromCoordinates
      ];
      for (const candidate of candidates) {
        const parsed = parseLatLngCandidate(candidate);
        if (parsed) return parsed;
      }
      const pairCandidates = [
        ["pickupLat", "pickupLng"],
        ["fromLat", "fromLng"],
        ["originLat", "originLng"]
      ];
      for (const [latKey, lngKey] of pairCandidates) {
        if (typeof ride?.[latKey] === "number" && typeof ride?.[lngKey] === "number") {
          return { lat: ride[latKey], lng: ride[lngKey] };
        }
      }
      return null;
    }

    function extractDropoffLocation(ride) {
      const candidates = [
        ride?.dropoffLocation,
        ride?.toLocation,
        ride?.destinationLocation,
        ride?.destLocation,
        ride?.dropoffGeo,
        ride?.toCoordinates,
        ride?.destCoordinates
      ];
      for (const candidate of candidates) {
        const parsed = parseLatLngCandidate(candidate);
        if (parsed) return parsed;
      }
      const pairCandidates = [
        ["dropoffLat", "dropoffLng"],
        ["destLat", "destLng"],
        ["toLat", "toLng"],
        ["destinationLat", "destinationLng"]
      ];
      for (const [latKey, lngKey] of pairCandidates) {
        if (typeof ride?.[latKey] === "number" && typeof ride?.[lngKey] === "number") {
          return { lat: ride[latKey], lng: ride[lngKey] };
        }
      }
      return null;
    }

    function parseLatLngCandidate(value) {
      if (!value) return null;
      if (typeof value.lat === "number" && typeof value.lng === "number") {
        return { lat: value.lat, lng: value.lng };
      }
      if (typeof value.latitude === "number" && typeof value.longitude === "number") {
        return { lat: value.latitude, lng: value.longitude };
      }
      return null;
    }

    function evaluateDropoffGeofence() {
      if (!driverCompleteButton) return;
      const isDropoffState = driverOverlayState === DRIVER_STATES.NAV_DROPOFF;
      if (!isDropoffState) {
        driverCompleteButton.disabled = true;
        return;
      }

      if (geofenceOverride) {
        driverGeofenceStatusEl.textContent = "Geofence override enabled.";
        driverGeofenceStatusEl.classList.add("armed");
        driverCompleteButton.disabled = false;
        return;
      }

      if (!activeDropoffLocation) {
        driverGeofenceStatusEl.textContent = "Destination location unavailable. Override to complete.";
        driverGeofenceStatusEl.classList.remove("armed");
        driverCompleteButton.disabled = true;
        driverCompleteOverrideButton.style.display = "inline-flex";
        return;
      }

      if (!driverCurrentPosition) {
        driverGeofenceStatusEl.textContent = "Waiting for your current location…";
        driverGeofenceStatusEl.classList.remove("armed");
        driverCompleteButton.disabled = true;
        return;
      }

      const distanceMeters = haversineMeters(driverCurrentPosition, activeDropoffLocation);
      const distanceFeet = distanceMeters * 3.28084;
      if (distanceMeters <= DROPOFF_GEOFENCE_METERS) {
        driverGeofenceStatusEl.textContent = `Within ${Math.round(distanceFeet)} ft of dropoff.`;
        driverGeofenceStatusEl.classList.add("armed");
        driverCompleteButton.disabled = false;
        driverCompleteOverrideButton.style.display = "none";
      } else {
        driverGeofenceStatusEl.textContent = `Complete ride unlocks within 150 ft. Currently ${Math.round(distanceFeet)} ft away.`;
        driverGeofenceStatusEl.classList.remove("armed");
        driverCompleteButton.disabled = true;
        driverCompleteOverrideButton.style.display = "none";
      }
    }

    function updateNavMapStatus(el, message) {
      if (!el) return;
      if (message) {
        el.textContent = message;
        el.classList.add("visible");
      } else {
        el.textContent = "";
        el.classList.remove("visible");
      }
    }

    function getBaseMapCenter() {
      if (driverCurrentPosition) return driverCurrentPosition;
      if (map?.getCenter) {
        const center = map.getCenter();
        if (center) {
          return { lat: center.lat(), lng: center.lng() };
        }
      }
      return { lat: 36.0626, lng: -94.1574 };
    }

    function ensurePickupNavArtifacts() {
      if (!driverPickupMapEl || googleMapsLoadFailed) return false;
      if (!window.google || !google.maps) return false;
      if (!pickupNavMap) {
        pickupNavMap = new google.maps.Map(driverPickupMapEl, {
          center: getBaseMapCenter(),
          zoom: 13,
          disableDefaultUI: true
        });
      }
      if (!pickupDirectionsService) {
        pickupDirectionsService = new google.maps.DirectionsService();
      }
      if (!pickupDirectionsRenderer) {
        pickupDirectionsRenderer = new google.maps.DirectionsRenderer({
          map: pickupNavMap,
          preserveViewport: true,
          polylineOptions: { strokeColor: "#22c55e", strokeWeight: 6 }
        });
      }
      return true;
    }

    function ensureDropoffNavArtifacts() {
      if (!driverDropoffMapEl || googleMapsLoadFailed) return false;
      if (!window.google || !google.maps) return false;
      if (!dropoffNavMap) {
        dropoffNavMap = new google.maps.Map(driverDropoffMapEl, {
          center: getBaseMapCenter(),
          zoom: 13,
          disableDefaultUI: true
        });
      }
      if (!dropoffDirectionsService) {
        dropoffDirectionsService = new google.maps.DirectionsService();
      }
      if (!dropoffDirectionsRenderer) {
        dropoffDirectionsRenderer = new google.maps.DirectionsRenderer({
          map: dropoffNavMap,
          preserveViewport: true,
          polylineOptions: { strokeColor: "#0ea5e9", strokeWeight: 6 }
        });
      }
      return true;
    }

    function requestDirections(service, request) {
      if (!service) return Promise.reject(new Error("Directions service unavailable."));
      return new Promise((resolve, reject) => {
        service.route(request, (result, status) => {
          if (status === "OK" && result) {
            resolve(result);
          } else {
            reject(new Error(`Directions request failed: ${status}`));
          }
        });
      });
    }

    async function renderPickupNavigation(ride, { force = false } = {}) {
      if (!ride || !driverPickupMapEl) return;
      if (googleMapsLoadFailed) {
        updateNavMapStatus(driverPickupMapStatus, "Google Maps failed to load.");
        return;
      }
      if (!ensurePickupNavArtifacts()) {
        updateNavMapStatus(driverPickupMapStatus, "Loading Google Maps…");
        return;
      }
      if (!activePickupLocation) {
        updateNavMapStatus(driverPickupMapStatus, "Pickup location not available yet.");
        return;
      }
      if (!driverCurrentPosition) {
        updateNavMapStatus(driverPickupMapStatus, "Waiting for your GPS location…");
        return;
      }
      const now = Date.now();
      if (!force && now - lastPickupRouteAt < NAV_ROUTE_REFRESH_MS) {
        return;
      }
      try {
        const directions = await requestDirections(pickupDirectionsService, {
          origin: driverCurrentPosition,
          destination: activePickupLocation,
          travelMode: google.maps.TravelMode.DRIVING
        });
        pickupDirectionsRenderer.setDirections(directions);
        fitInsetMapToRoute(pickupNavMap, directions);
        resizeInsetMap(pickupNavMap);
        updateNavMapStatus(driverPickupMapStatus, "");
        lastPickupRouteAt = Date.now();
      } catch (err) {
        console.error("renderPickupNavigation error", err);
        updateNavMapStatus(driverPickupMapStatus, "Unable to build route. Open in Google Maps.");
      }
    }

    async function renderDropoffNavigation(ride, { force = false } = {}) {
      if (!ride || !driverDropoffMapEl) return;
      if (googleMapsLoadFailed) {
        updateNavMapStatus(driverDropoffMapStatus, "Google Maps failed to load.");
        return;
      }
      if (!ensureDropoffNavArtifacts()) {
        updateNavMapStatus(driverDropoffMapStatus, "Loading Google Maps…");
        return;
      }
      if (!activeDropoffLocation) {
        updateNavMapStatus(driverDropoffMapStatus, "Destination location not available yet.");
        return;
      }
      if (!driverCurrentPosition) {
        updateNavMapStatus(driverDropoffMapStatus, "Waiting for your GPS location…");
        return;
      }
      const now = Date.now();
      if (!force && now - lastDropoffRouteAt < NAV_ROUTE_REFRESH_MS) {
        return;
      }
      try {
        const directions = await requestDirections(dropoffDirectionsService, {
          origin: driverCurrentPosition,
          destination: activeDropoffLocation,
          travelMode: google.maps.TravelMode.DRIVING
        });
        dropoffDirectionsRenderer.setDirections(directions);
        const durationSeconds =
          directions?.routes?.[0]?.legs?.[0]?.duration?.value;
        if (Number.isFinite(durationSeconds)) {
          setLatestDropoffEta(durationSeconds / 60);
        }
        fitInsetMapToRoute(dropoffNavMap, directions);
        resizeInsetMap(dropoffNavMap);
        updateNavMapStatus(driverDropoffMapStatus, "");
        lastDropoffRouteAt = Date.now();
      } catch (err) {
        console.error("renderDropoffNavigation error", err);
        updateNavMapStatus(driverDropoffMapStatus, "Unable to build route. Open in Google Maps.");
      }
    }

    function fitInsetMapToRoute(mapInstance, directions) {
      if (!mapInstance || !directions?.routes?.length) return;
      const bounds = directions.routes[0].bounds;
      if (bounds) {
        mapInstance.fitBounds(bounds);
      }
    }

    function resizeInsetMap(mapInstance) {
      if (!mapInstance) return;
      if (!window.google || !google.maps?.event) return;
      setTimeout(() => {
        google.maps.event.trigger(mapInstance, "resize");
      }, 120);
    }

    function refreshNavigationRoutes(options = {}) {
      if (driverOverlayState === DRIVER_STATES.NAV_PICKUP && activePickupLocation) {
        renderPickupNavigation(getPrimaryRide(), options);
      }
      if (driverOverlayState === DRIVER_STATES.NAV_DROPOFF && activeDropoffLocation) {
        renderDropoffNavigation(getPrimaryRide(), options);
      }
    }

    function openNavigationInGoogleMaps(destination) {
      if (!destination) {
        activeRideError.textContent = "Location not available yet.";
        return;
      }
      const params = new URLSearchParams({
        api: "1",
        destination: `${destination.lat},${destination.lng}`,
        travelmode: "driving"
      });
      if (driverCurrentPosition) {
        params.set("origin", `${driverCurrentPosition.lat},${driverCurrentPosition.lng}`);
      }
      window.open(`https://www.google.com/maps/dir/?${params.toString()}`, "_blank", "noopener");
    }

    function handleOpenPickupInMaps() {
      if (!activePickupLocation) {
        activeRideError.textContent = "Pickup location not available yet.";
        return;
      }
      openNavigationInGoogleMaps(activePickupLocation);
    }

    function handleOpenDropoffInMaps() {
      if (!activeDropoffLocation) {
        activeRideError.textContent = "Destination not available yet.";
        return;
      }
      openNavigationInGoogleMaps(activeDropoffLocation);
    }

    function shouldSkipDriverLocationPush(nextPosition) {
      if (!nextPosition) return true;
      const now = Date.now();
      if (!lastDriverLocationSent) return false;
      const movedMeters = haversineMeters(lastDriverLocationSent, nextPosition);
      if (movedMeters >= DRIVER_LOCATION_MIN_DELTA_METERS) {
        return false;
      }
      return now - lastDriverLocationPushAt < DRIVER_LOCATION_PUSH_INTERVAL_MS;
    }

    function normalizedHeading(value) {
      if (typeof value !== "number" || Number.isNaN(value)) return null;
      return ((value % 360) + 360) % 360;
    }

    async function pushDriverLocationToFirestore(position) {
      if (!currentUser || !driverCurrentPosition) return;
      if (shouldSkipDriverLocationPush(driverCurrentPosition)) return;
      if (driverLocationUpdatePromise) return;

      const heading = normalizedHeading(position?.coords?.heading);
      const speed = Number.isFinite(position?.coords?.speed) ? position.coords.speed : null;
      const timestamp = serverTimestamp();
      const payload = {
        currentLat: driverCurrentPosition.lat,
        currentLng: driverCurrentPosition.lng,
        currentLocation: { ...driverCurrentPosition },
        currentHeading: heading,
        currentSpeedMps: speed,
        currentLocationUpdatedAt: timestamp
      };

      driverLocationUpdatePromise = (async () => {
        try {
          const batch = writeBatch(db);
          const driverRef = doc(db, "drivers", currentUser.uid);
          batch.set(driverRef, payload, { merge: true });

          if (activeRideGroup.length) {
            activeRideGroup.forEach((ride) => {
              const rideRef = doc(db, "rideRequests", ride.id);
              batch.update(rideRef, {
                driverLat: driverCurrentPosition.lat,
                driverLng: driverCurrentPosition.lng,
                driverLocation: { ...driverCurrentPosition },
                driverHeading: heading,
                driverSpeedMps: speed,
                driverLocationUpdatedAt: timestamp
              });
            });
          }

          await batch.commit();
          lastDriverLocationPushAt = Date.now();
          lastDriverLocationSent = { ...driverCurrentPosition };
        } catch (err) {
          console.warn("pushDriverLocationToFirestore error", err);
        } finally {
          driverLocationUpdatePromise = null;
        }
      })();
    }

    function startDriverLocationWatch() {
      if (!navigator.geolocation || driverLocationWatcherId) return;
      driverLocationWatcherId = navigator.geolocation.watchPosition(
        (pos) => {
          driverCurrentPosition = {
            lat: pos.coords.latitude,
            lng: pos.coords.longitude
          };
          if (driverMarker) {
            driverMarker.setPosition(driverCurrentPosition);
          }
          evaluateDropoffGeofence();
          refreshNavigationRoutes();
          pushDriverLocationToFirestore(pos);
        },
        (err) => {
          console.warn("watchPosition error", err);
        },
        { enableHighAccuracy: true }
      );
    }

    function haversineMeters(a, b) {
      const R = 6371000;
      const toRad = (deg) => (deg * Math.PI) / 180;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const sinLat = Math.sin(dLat / 2);
      const sinLng = Math.sin(dLng / 2);
      const h =
        sinLat * sinLat +
        Math.cos(lat1) * Math.cos(lat2) * sinLng * sinLng;
      const c = 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
      return R * c;
    }

    function ensureBackgroundMapReady() {
      if (googleMapsLoadFailed) return;
      if (map) return;
      if (window.google && google.maps) {
        initMap();
        return;
      }
      setTimeout(ensureBackgroundMapReady, 600);
    }

    if (driverNavSyncButton) {
      driverNavSyncButton.addEventListener("click", () => setDriverSection("sync"));
    }
    if (driverNavProfileButton) {
      driverNavProfileButton.addEventListener("click", () => setDriverSection("profile"));
    }
    if (driverProfileSaveButton) {
      driverProfileSaveButton.addEventListener("click", saveDriverProfileChanges);
    }
    if (driverPhotoInput) {
      driverPhotoInput.addEventListener("change", handleDriverPhotoSelected);
    }
    if (driverPhotoRemoveButton) {
      driverPhotoRemoveButton.addEventListener("click", handleDriverPhotoRemove);
    }
    if (driverEditNameInput) {
      driverEditNameInput.addEventListener("input", handleDriverNameInputChange);
    }
    if (driverAvatarChangeButton) {
      driverAvatarChangeButton.addEventListener("click", openDriverAvatarPicker);
    }
    if (driverAvatarUploadInput) {
      driverAvatarUploadInput.addEventListener("change", handleDriverAvatarUpload);
    }
    if (driverAvatar) {
      driverAvatar.addEventListener("click", openDriverAvatarPicker);
      driverAvatar.addEventListener("keydown", (event) => {
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          openDriverAvatarPicker();
        }
      });
    }

    if (driverOfferAcceptButton) {
      driverOfferAcceptButton.addEventListener("click", handleDriverOfferAccept);
    }
    if (driverOfferRejectButton) {
      driverOfferRejectButton.addEventListener("click", handleDriverOfferReject);
    }
    if (driverArriveButton) {
      driverArriveButton.addEventListener("click", handleDriverArriveAtPickup);
    }
    if (driverPickupBackButton) {
      driverPickupBackButton.addEventListener("click", handlePickupBack);
    }
    if (driverPickupConfirmButton) {
      driverPickupConfirmButton.addEventListener("click", handlePickupCodeConfirm);
    }
    if (driverCompleteButton) {
      driverCompleteButton.addEventListener("click", handleDriverArriveAtDropoff);
    }
    if (driverPickupNavigateButton) {
      driverPickupNavigateButton.addEventListener("click", handleOpenPickupInMaps);
    }
    if (driverCompleteOverrideButton) {
      driverCompleteOverrideButton.addEventListener("click", () => {
        geofenceOverride = true;
        driverCompleteOverrideButton.style.display = "none";
        evaluateDropoffGeofence();
      });
    }
    if (driverDropoffNavigateButton) {
      driverDropoffNavigateButton.addEventListener("click", handleOpenDropoffInMaps);
    }
    if (driverDropoffConfirmButton) {
      driverDropoffConfirmButton.addEventListener("click", handleDropoffCodeConfirm);
    }
    if (driverCompleteDismissButton) {
      driverCompleteDismissButton.addEventListener("click", handleRideCompleteDismiss);
    }
    if (driverCancelRideLink) {
      driverCancelRideLink.addEventListener("click", cancelActiveRideAsDriver);
    }

    if (closeActiveRideButton) {
      closeActiveRideButton.addEventListener("click", () => {
        driverOverlayDismissed = true;
        activeRideOverlay?.classList.remove("active");
      });
    }

    ensureBackgroundMapReady();
  </script>
</body>
</html>