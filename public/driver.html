<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RideSync Driver</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Google Maps -->
  <script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDlYSl5rfovahECuBSbkELw2uyC6-Ucmr0"></script>
  <!-- QR code library for boarding / dropoff codes -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1d4ed8, #020617 55%);
      color: #f9fafb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 10px;
    }
    .card {
      background: rgba(2,6,23,0.92);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.45);
      box-shadow: 0 24px 60px rgba(0,0,0,0.6);
      width: 100%;
      max-width: 640px;
      max-height: 96vh;
      padding: 20px 16px 16px;
      overflow-y: auto;
      position: relative;
      z-index: 2;
      backdrop-filter: blur(12px);
    }
    h1, h2 { margin: 0 0 8px; text-align: center; }
    h1 { font-size: 1.6rem; }
    h2 { font-size: 1.1rem; }
    .subtitle {
      margin: 0 0 16px;
      text-align: center;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    label {
      font-size: 0.8rem;
      display: block;
      margin-bottom: 4px;
      color: #e5e7eb;
    }
    input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #f9fafb;
      font-size: 0.9rem;
      margin-bottom: 8px;
    }
    input:focus {
      outline: 2px solid #2563eb;
      outline-offset: 1px;
    }
    button {
      padding: 9px 12px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
    }
      .btn-primary { background: #22c55e; color: #022c22; }
      .btn-secondary {
        background: #020617;
        color: #e5e7eb;
        border: 1px solid #4b5563;
      }
      .btn-danger {
        background: #7f1d1d;
        color: #fee2e2;
        border: 1px solid #fca5a5;
      }
    .btn-small { font-size: 0.78rem; padding: 6px 10px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .row > div { flex: 1 1 150px; }
    .error { color: #fecaca; font-size: 0.8rem; min-height: 18px; margin-top: 2px; }
    .success { color: #bbf7d0; font-size: 0.8rem; min-height: 18px; margin-top: 2px; }
    .small { font-size: 0.75rem; color: #9ca3af; margin-top: 4px; }

    #authView, #driverView { display: none; }
    #authView.active, #driverView.active { display: block; }

    .driver-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .driver-avatar {
      width: 58px;
      height: 58px;
      border-radius: 999px;
      border: 2px solid rgba(148,163,184,0.8);
      object-fit: cover;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #9ca3af;
      font-size: 1.1rem;
      overflow: hidden;
    }
    .driver-header-text { flex: 1 1 auto; min-width: 0; }
    .driver-name { font-size: 1rem; font-weight: 600; }
    .driver-detail { font-size: 0.8rem; color: #9ca3af; }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #ef4444;
      display: inline-block;
      margin-right: 4px;
    }
    .status-dot.online { background: #22c55e; }

    #map {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin: 12px 0 6px;
      border-top: 1px solid rgba(148,163,184,0.4);
      padding-top: 8px;
    }

    .ride-card {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.5);
      padding: 8px 10px;
      margin-bottom: 8px;
      background: rgba(15,23,42,0.95);
      font-size: 0.8rem;
    }
    .ride-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
      font-weight: 600;
    }
    .ride-line { margin-bottom: 2px; }
    .ride-meta { color: #9ca3af; }
    .tag {
      display: inline-flex;
      align-items: center;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid rgba(148,163,184,0.6);
      margin-right: 4px;
      margin-bottom: 2px;
    }
    .tag-basic { border-color:#3b82f6; color:#bfdbfe; }
    .tag-uofa { border-color:#22c55e; color:#bbf7d0; }
    .tag-nwa { border-color:#f97316; color:#fed7aa; }
    .tag-pooled { border-color:#a855f7; color:#e9d5ff; }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(2,6,23,0.92);
      backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 50;
    }
    .overlay.active { display: flex; }
    .driver-overlay-shell {
      width: min(520px, 100%);
      max-height: 100%;
      overflow-y: auto;
      background: rgba(2,6,23,0.95);
      border: 1px solid rgba(148,163,184,0.45);
      border-radius: 20px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.65);
    }
    .driver-overlay-top {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: flex-start;
    }
    .driver-rider-bar {
      flex: 1 1 auto;
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .driver-rider-avatars {
      display: flex;
      gap: 4px;
    }
    .driver-top-avatar {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.5);
      overflow: hidden;
      background: #0f172a;
      position: relative;
      flex-shrink: 0;
    }
    .driver-top-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .driver-top-avatar .avatar-initials {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #94a3b8;
      font-size: 0.78rem;
    }
    .driver-top-avatar.has-photo .avatar-initials {
      display: none;
    }
    .driver-rider-meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .driver-rider-names {
      font-size: 1rem;
      font-weight: 600;
    }
    .driver-rider-membership {
      font-size: 0.78rem;
      color: #cbd5f5;
    }
    .driver-rider-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .driver-chip {
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      font-size: 0.72rem;
      color: #e5e7eb;
    }
    .overlay-close {
      border-radius: 999px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #e5e7eb;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 0.78rem;
      flex-shrink: 0;
    }
    .driver-state {
      display: none;
      flex-direction: column;
      gap: 12px;
    }
    .driver-state.active { display: flex; }
    .driver-state h3 {
      margin: 0;
      font-size: 1.3rem;
    }
    .driver-state .state-subtitle {
      color: #9ca3af;
      font-size: 0.9rem;
    }
    .driver-state .info-box {
      background: rgba(15,23,42,0.9);
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      padding: 12px;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    .driver-state input {
      background: #020617;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.5);
      padding: 10px 12px;
      color: #f9fafb;
      font-size: 1.1rem;
      letter-spacing: 0.2em;
      text-align: center;
    }
    .driver-state .button-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .driver-state .button-row button {
      flex: 1 1 160px;
    }
    .driver-geofence-status {
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .driver-geofence-status.armed {
      color: #bbf7d0;
    }
    .driver-spinner {
      width: 36px;
      height: 36px;
      border-radius: 999px;
      border: 4px solid rgba(148,163,184,0.3);
      border-top-color: #22c55e;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }
    @keyframes spin { to { transform: rotate(360deg);} }

    .pill {
      display:inline-flex;
      padding:2px 7px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,0.5);
      font-size:0.7rem;
      margin-left:4px;
    }
    .driver-riders-container {
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:6px;
    }
    .driver-rider-card {
      display:flex;
      gap:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(148,163,184,0.45);
      background:rgba(2,6,23,0.9);
    }
    .driver-rider-avatar {
      width:54px;
      height:54px;
      border-radius:14px;
      border:1px solid rgba(148,163,184,0.6);
      background:#0f172a;
      overflow:hidden;
      position:relative;
      flex-shrink:0;
    }
    .driver-rider-avatar img {
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .driver-rider-avatar .avatar-initials {
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:600;
      color:#94a3af;
      font-size:0.8rem;
      background:#0f172a;
    }
    .driver-rider-avatar.has-photo .avatar-initials {
      display:none;
    }
    .driver-rider-body { flex:1 1 auto; min-width:0; }
    .driver-rider-label {
      font-size:0.7rem;
      color:#94a3af;
      text-transform:uppercase;
      letter-spacing:0.06em;
      margin-bottom:2px;
    }
    .driver-rider-name {
      font-weight:600;
      font-size:0.95rem;
      margin-bottom:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .driver-rider-line {
      font-size:0.78rem;
      color:#cbd5f5;
      margin-bottom:1px;
    }
    .support-panel {
      border:1px solid rgba(148,163,184,0.4);
      border-radius:14px;
      padding:12px;
      background:rgba(2,6,23,0.92);
      margin-top:8px;
      display:none;
    }
    .support-panel.active { display:block; }
    .support-panel-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom:6px;
    }
    .support-panel-text {
      font-size:0.8rem;
      color:#cbd5f5;
      margin-bottom:8px;
    }
    .support-actions {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .support-actions a {
      flex:1 1 140px;
      text-align:center;
      text-decoration:none;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="card">
    <!-- AUTH VIEW -->
    <div id="authView" class="active">
      <h1>RideSync Driver</h1>
      <p class="subtitle">Sign in to start receiving RideSync requests.</p>

      <label for="email">Email</label>
      <input id="email" type="email" placeholder="driver@example.com" autocomplete="email" />

      <label for="password">Password</label>
      <input id="password" type="password" placeholder="••••••••" autocomplete="current-password" />

      <button id="loginButton" class="btn-primary" style="width:100%;margin-top:6px;">Log in</button>
      <div id="authError" class="error"></div>
      <p class="small">Use your driver account (separate from rider login).</p>
    </div>

    <!-- DRIVER VIEW -->
    <div id="driverView">
      <h2>Driver console</h2>
      <p class="subtitle">Go online to start receiving RideSync requests.</p>

      <div class="driver-header">
        <div id="driverAvatar" class="driver-avatar">DR</div>
        <div class="driver-header-text">
          <div class="driver-name" id="driverName">Driver</div>
          <div class="driver-detail" id="driverDetail"></div>
          <div class="driver-detail">
            <span id="onlineDot" class="status-dot"></span>
            <span id="onlineLabel">Offline</span>
          </div>
        </div>
        <button id="logoutButton" class="btn-secondary btn-small">Log out</button>
      </div>

      <button id="toggleOnlineButton" class="btn-primary" style="width:100%;margin-bottom:4px;">
        Sync online
      </button>
      <div id="driverMessage" class="success"></div>
      <div id="driverError" class="error"></div>

      <div class="section-title">Available rides</div>
      <div id="ridesList"></div>
      <div class="small" id="ridesHint">
        Rides with no driver and status pending/pooled will appear here while you are online.
      </div>
    </div>

    <!-- ACTIVE RIDE OVERLAY -->
    <div id="activeRideOverlay" class="overlay">
      <div class="driver-overlay-shell">
        <div class="driver-overlay-top">
          <div class="driver-rider-bar">
            <div id="driverOverlayAvatarRow" class="driver-rider-avatars"></div>
            <div class="driver-rider-meta">
              <div id="driverOverlayRiderNames" class="driver-rider-names">Rider</div>
              <div id="driverOverlayMembership" class="driver-rider-membership"></div>
              <div id="driverOverlayChips" class="driver-rider-chips"></div>
            </div>
          </div>
          <button id="closeActiveRideButton" class="overlay-close" type="button">Hide</button>
        </div>

        <div id="driverStateOffer" class="driver-state">
          <h3>New ride request</h3>
          <div class="state-subtitle">Review the details before accepting.</div>
          <div class="info-box">
            <div><strong>Pickup:</strong> <span id="driverOfferPickupText"></span></div>
            <div><strong>Dropoff:</strong> <span id="driverOfferDropoffText"></span></div>
            <div><strong>Riders:</strong> <span id="driverOfferRiderCount"></span></div>
          </div>
          <div class="button-row">
            <button id="driverOfferRejectButton" class="btn-secondary" type="button">Not now</button>
            <button id="driverOfferAcceptButton" class="btn-primary" type="button">Accept ride</button>
          </div>
        </div>

        <div id="driverStateNavPickup" class="driver-state">
          <h3>Navigate to pickup</h3>
          <div class="state-subtitle">Keep the rider updated while en route.</div>
          <div class="info-box">
            <div><strong>Pickup:</strong> <span id="driverNavPickupAddress"></span></div>
            <div id="driverNavPickupEta"></div>
          </div>
          <button id="driverArriveButton" class="btn-primary" type="button">Arrive</button>
        </div>

        <div id="driverStateEnterPickup" class="driver-state">
          <h3>Verify rider</h3>
          <div class="state-subtitle">Ask for their pickup code and enter it below.</div>
          <input id="pickupCodeInput" type="text" inputmode="numeric" maxlength="6" placeholder="••••" />
          <div id="pickupCodeError" class="error"></div>
          <div class="button-row">
            <button id="driverPickupBackButton" class="btn-secondary" type="button">Back</button>
            <button id="driverPickupConfirmButton" class="btn-primary" type="button">Confirm code</button>
          </div>
        </div>

        <div id="driverStateNavDropoff" class="driver-state">
          <h3>On the way to destination</h3>
          <div class="state-subtitle">Complete ride once you reach the dropoff.</div>
          <div class="info-box">
            <div><strong>Destination:</strong> <span id="driverNavDropoffAddress"></span></div>
            <div id="driverDropoffEta"></div>
          </div>
          <div id="driverGeofenceStatus" class="driver-geofence-status"></div>
          <button id="driverCompleteButton" class="btn-primary" type="button" disabled>
            Complete ride
          </button>
          <button
            id="driverCompleteOverrideButton"
            class="btn-secondary btn-small"
            type="button"
            style="align-self:flex-start; display:none;"
          >
            Override geofence
          </button>
        </div>

        <div id="driverStateEnterDropoff" class="driver-state">
          <h3>Confirm dropoff</h3>
          <div class="state-subtitle">Enter the rider's dropoff code to finish.</div>
          <input id="dropoffCodeInput" type="text" inputmode="numeric" maxlength="6" placeholder="••••" />
          <div id="dropoffCodeError" class="error"></div>
          <button id="driverDropoffConfirmButton" class="btn-primary" type="button">Confirm code</button>
        </div>

        <div id="driverStateComplete" class="driver-state">
          <h3>Ride complete</h3>
          <div id="driverWaitingStatus" class="state-subtitle">Waiting for rider rating and tip…</div>
          <div class="driver-spinner"></div>
          <div id="driverRatingResult" class="info-box" style="display:none;"></div>
          <div id="driverTipResult" class="info-box" style="display:none;"></div>
          <button
            id="driverCompleteDismissButton"
            class="btn-primary"
            type="button"
            style="display:none;"
          >
            Close &amp; return to idle
          </button>
        </div>

        <button id="driverCancelRideLink" class="btn-danger" type="button">Cancel ride</button>
        <div id="activeRideError" class="error"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
    import {
      getAuth,
      onAuthStateChanged,
      signInWithEmailAndPassword,
      signOut
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";
    import {
      getFirestore,
      collection,
      doc,
      getDoc,
      setDoc,
      updateDoc,
      onSnapshot,
      query,
      orderBy,
      limit,
      where,
      getDocs,
      serverTimestamp,
      writeBatch
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

    async function loadAppConfig() {
      if (window.__rideSyncConfigPromise) {
        return window.__rideSyncConfigPromise;
      }

      window.__rideSyncConfigPromise = fetch("/app-config.json", {
        cache: "no-store"
      })
        .then((res) => {
          if (!res.ok) {
            throw new Error(`Failed to load app config: ${res.status}`);
          }
          return res.json();
        })
        .catch((err) => {
          console.error("App config load failed", err);
          throw err;
        });

      return window.__rideSyncConfigPromise;
    }

    const APP_CONFIG = await loadAppConfig();
    const firebaseConfig = APP_CONFIG.firebaseConfig || {};
    const supportConfig = APP_CONFIG.support || {};
    const geoConfig = APP_CONFIG.geo || {};
    const placeholderConfig = APP_CONFIG.placeholders || {};

    const SUPPORT_PHONE_NUMBER = supportConfig.phoneNumber || "";
    const SUPPORT_TEL_LINK = SUPPORT_PHONE_NUMBER
      ? `tel:${SUPPORT_PHONE_NUMBER}`
      : "#";
    const SUPPORT_SMS_LINK = SUPPORT_PHONE_NUMBER
      ? `sms:${SUPPORT_PHONE_NUMBER}`
      : "#";
    const RIDER_PLACEHOLDER_AVATAR = placeholderConfig.riderAvatar || "";
    const DROPOFF_GEOFENCE_METERS =
      geoConfig.dropoffGeofenceMeters ?? 45; // ~150ft

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const authView = document.getElementById("authView");
    const driverView = document.getElementById("driverView");
    const loginButton = document.getElementById("loginButton");
    const logoutButton = document.getElementById("logoutButton");
    const authError = document.getElementById("authError");
    const emailEl = document.getElementById("email");
    const passwordEl = document.getElementById("password");

    const driverAvatar = document.getElementById("driverAvatar");
    const driverNameEl = document.getElementById("driverName");
    const driverDetailEl = document.getElementById("driverDetail");
    const onlineDot = document.getElementById("onlineDot");
    const onlineLabel = document.getElementById("onlineLabel");
    const toggleOnlineButton = document.getElementById("toggleOnlineButton");
    const driverMessage = document.getElementById("driverMessage");
    const driverError = document.getElementById("driverError");
    const ridesList = document.getElementById("ridesList");

    const activeRideOverlay = document.getElementById("activeRideOverlay");
    const driverOverlayAvatarRow = document.getElementById("driverOverlayAvatarRow");
    const driverOverlayRiderNames = document.getElementById("driverOverlayRiderNames");
    const driverOverlayMembership = document.getElementById("driverOverlayMembership");
    const driverOverlayChips = document.getElementById("driverOverlayChips");
    const driverStateOffer = document.getElementById("driverStateOffer");
    const driverStateNavPickup = document.getElementById("driverStateNavPickup");
    const driverStateEnterPickup = document.getElementById("driverStateEnterPickup");
    const driverStateNavDropoff = document.getElementById("driverStateNavDropoff");
    const driverStateEnterDropoff = document.getElementById("driverStateEnterDropoff");
    const driverStateComplete = document.getElementById("driverStateComplete");
    const driverOfferPickupText = document.getElementById("driverOfferPickupText");
    const driverOfferDropoffText = document.getElementById("driverOfferDropoffText");
    const driverOfferRiderCount = document.getElementById("driverOfferRiderCount");
    const driverOfferAcceptButton = document.getElementById("driverOfferAcceptButton");
    const driverOfferRejectButton = document.getElementById("driverOfferRejectButton");
    const driverNavPickupAddress = document.getElementById("driverNavPickupAddress");
    const driverNavPickupEta = document.getElementById("driverNavPickupEta");
    const driverNavDropoffAddress = document.getElementById("driverNavDropoffAddress");
    const driverDropoffEta = document.getElementById("driverDropoffEta");
    const driverArriveButton = document.getElementById("driverArriveButton");
    const pickupCodeInput = document.getElementById("pickupCodeInput");
    const pickupCodeError = document.getElementById("pickupCodeError");
    const driverPickupBackButton = document.getElementById("driverPickupBackButton");
    const driverPickupConfirmButton = document.getElementById("driverPickupConfirmButton");
    const driverGeofenceStatusEl = document.getElementById("driverGeofenceStatus");
    const driverCompleteButton = document.getElementById("driverCompleteButton");
    const driverCompleteOverrideButton = document.getElementById("driverCompleteOverrideButton");
    const dropoffCodeInput = document.getElementById("dropoffCodeInput");
    const dropoffCodeError = document.getElementById("dropoffCodeError");
    const driverDropoffConfirmButton = document.getElementById("driverDropoffConfirmButton");
    const driverWaitingStatus = document.getElementById("driverWaitingStatus");
    const driverRatingResult = document.getElementById("driverRatingResult");
    const driverTipResult = document.getElementById("driverTipResult");
    const driverCompleteDismissButton = document.getElementById("driverCompleteDismissButton");
    const driverCancelRideLink = document.getElementById("driverCancelRideLink");
    const activeRideError = document.getElementById("activeRideError");
    const closeActiveRideButton = document.getElementById("closeActiveRideButton");

    let currentUser = null;
    let currentDriverProfile = null;
    let map;
    let driverMarker;
    let ridesUnsub = null;
    let isOnline = false;

    const DRIVER_STATES = {
      HIDDEN: "HIDDEN",
      OFFER: "DRIVER_RIDE_OFFER",
      NAV_PICKUP: "DRIVER_NAV_TO_PICKUP",
      ENTER_PICKUP: "DRIVER_ENTER_PICKUP_CODE",
      NAV_DROPOFF: "DRIVER_NAV_TO_DROPOFF",
      ENTER_DROPOFF: "DRIVER_ENTER_DROPOFF_CODE",
      COMPLETE: "DRIVER_RIDE_COMPLETE_WAITING_RATING"
    };

    let activeRideGroup = [];
    let activeRideWatchers = [];
    let pendingRideOffer = null;
    let driverOverlayState = DRIVER_STATES.HIDDEN;
    let driverOverlayDismissed = false;
    let driverCurrentPosition = null;
    let driverLocationWatcherId = null;
    let activeDropoffLocation = null;
    let geofenceOverride = false;

    function showAuth() {
      authView.classList.add("active");
      driverView.classList.remove("active");
    }
    function showDriver() {
      authView.classList.remove("active");
      driverView.classList.add("active");
    }

    loginButton.addEventListener("click", async () => {
      authError.textContent = "";
      try {
        await signInWithEmailAndPassword(
          auth,
          emailEl.value.trim(),
          passwordEl.value.trim()
        );
      } catch (err) {
        console.error(err);
        authError.textContent = err.message || "Login failed.";
      }
    });

    logoutButton.addEventListener("click", async () => {
      try {
        await signOut(auth);
      } catch (err) {
        console.error(err);
      }
    });

    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      if (!user) {
        showAuth();
        setOnline(false);
        driverAvatar.textContent = "DR";
        driverNameEl.textContent = "Driver";
        driverDetailEl.textContent = "";
        clearActiveRideFlow();
        if (ridesUnsub) {
          ridesUnsub();
          ridesUnsub = null;
        }
        ridesList.innerHTML = "";
        return;
      }

      showDriver();
      await loadDriverProfile();
      initMap();
      subscribeToRides();
    });

    async function loadDriverProfile() {
      try {
        const ref = doc(db, "drivers", currentUser.uid);
        const snap = await getDoc(ref);
        if (snap.exists()) {
          currentDriverProfile = snap.data();
        } else {
          currentDriverProfile = {
            fullName: currentUser.email || "Driver",
            phone: "",
            vehicleMake: "",
            vehicleModel: "",
            vehicleColor: "",
            licensePlate: ""
          };
          await setDoc(ref, {
            ...currentDriverProfile,
            createdAt: serverTimestamp()
          }, { merge: true });
        }

        const name = currentDriverProfile.fullName || currentUser.email || "Driver";
        driverNameEl.textContent = name;
        driverDetailEl.textContent =
          `${currentDriverProfile.vehicleYear || ""} ${currentDriverProfile.vehicleColor || ""} ${currentDriverProfile.vehicleMake || ""} ${currentDriverProfile.vehicleModel || ""}`.trim();

        if (currentDriverProfile.profilePicUrl) {
          const img = new Image();
          img.src = currentDriverProfile.profilePicUrl;
          img.onload = () => {
            driverAvatar.innerHTML = "";
            driverAvatar.appendChild(img);
          };
        } else {
          driverAvatar.textContent = name.charAt(0).toUpperCase();
        }
      } catch (err) {
        console.error("loadDriverProfile error", err);
      }
    }

    function initMap() {
      if (map) return;
      map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: 36.0626, lng: -94.1574 },
        zoom: 11,
        disableDefaultUI: true
      });

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const { latitude, longitude } = pos.coords;
            const loc = { lat: latitude, lng: longitude };
            map.setCenter(loc);
            driverCurrentPosition = loc;
            driverMarker = new google.maps.Marker({
              map,
              position: loc,
              title: "You"
            });
            evaluateDropoffGeofence();
          },
          () => {}
        );
        startDriverLocationWatch();
      }
    }

    function setOnline(val) {
      isOnline = val;
      if (val) {
        onlineDot.classList.add("online");
        onlineLabel.textContent = "Online";
        toggleOnlineButton.textContent = "Sync offline";
      } else {
        onlineDot.classList.remove("online");
        onlineLabel.textContent = "Offline";
        toggleOnlineButton.textContent = "Sync online";
      }
    }

    toggleOnlineButton.addEventListener("click", async () => {
      setOnline(!isOnline);
      driverMessage.textContent = isOnline ? "You are now online." : "You are offline.";
      driverError.textContent = "";
      try {
        const ref = doc(db, "drivers", currentUser.uid);
        await updateDoc(ref, {
          isOnline,
          lastOnlineAt: serverTimestamp()
        });
      } catch (err) {
        console.error(err);
      }
    });

    function subscribeToRides() {
      if (ridesUnsub) {
        ridesUnsub();
        ridesUnsub = null;
      }
      const ridesRef = collection(db, "rideRequests");
      const q = query(ridesRef, orderBy("createdAt", "desc"), limit(40));
      ridesUnsub = onSnapshot(
        q,
        (snap) => {
          const rides = [];
          snap.forEach((docSnap) => {
            const d = docSnap.data();
            rides.push({ id: docSnap.id, ...d });
          });
          renderRides(rides);
        },
        (err) => {
          console.error("rides snapshot error", err);
          driverError.textContent = err.message || "Error loading rides.";
        }
      );
    }

    function membershipTag(m) {
      if (m === "uofa_unlimited") return '<span class="tag tag-uofa">U of A Unlimited</span>';
      if (m === "nwa_unlimited") return '<span class="tag tag-nwa">NWA Unlimited</span>';
      if (m === "basic") return '<span class="tag tag-basic">Basic</span>';
      if (!m) return '<span class="tag tag-basic">Unknown</span>';
      return `<span class="tag tag-basic">${m}</span>`;
    }

    function safeImageUrl(url) {
      if (!url && url !== 0) return null;
      const value = String(url).trim();
      if (!value || value === "null" || value === "undefined") return null;
      return value;
    }

    function formatPhoneDisplay(phone) {
      if (!phone) return "";
      const digits = phone.replace(/\D/g, "");
      if (!digits) return "";
      let clean = digits;
      if (clean.length === 11 && clean.startsWith("1")) {
        clean = clean.slice(1);
      }
      if (clean.length === 10) {
        return `(${clean.slice(0, 3)}) ${clean.slice(3, 6)}-${clean.slice(6)}`;
      }
      return phone;
    }

    function membershipLabel(value) {
      if (value === "uofa_unlimited") return "Membership: U of A Unlimited";
      if (value === "nwa_unlimited") return "Membership: NWA Unlimited";
      if (value === "basic") return "Membership: Basic";
      if (!value) return "";
      return `Membership: ${value}`;
    }

    function pickupLabel(rider) {
      if (rider?.pickupAddress) return rider.pickupAddress;
      if (rider?.fromAddress) return rider.fromAddress;
      const loc = rider?.fromLocation;
      if (loc && typeof loc.lat === "number" && typeof loc.lng === "number") {
        return `${loc.lat.toFixed(4)}, ${loc.lng.toFixed(4)}`;
      }
      return "";
    }

    function dropoffLabel(rider) {
      return rider?.toDestination || rider?.toAddress || rider?.destAddress || "";
    }

    function riderInitials(name) {
      return (name || "RS")
        .split(" ")
        .filter(Boolean)
        .map((part) => part[0])
        .join("")
        .slice(0, 2)
        .toUpperCase() || "RS";
    }

    function renderDriverTopBar(riders) {
      if (!driverOverlayAvatarRow) return;
      const list = Array.isArray(riders) ? riders : [];
      driverOverlayAvatarRow.innerHTML = "";
      driverOverlayChips.innerHTML = "";

      if (!list.length) {
        driverOverlayRiderNames.textContent = "Awaiting rider";
        driverOverlayMembership.textContent = "";
        return;
      }

      const nameList = list
        .map((r, idx) => r?.riderName || `Rider ${idx + 1}`)
        .join(", ");
      driverOverlayRiderNames.textContent = nameList;

      const membershipText = membershipLabel(
        list[0]?.membershipType || list[0]?.membership
      )
        ?.replace("Membership: ", "") || "";
      driverOverlayMembership.textContent = membershipText;

      list.forEach((rider, index) => {
        const displayName = rider?.riderName || `Rider ${index + 1}`;
        const avatarWrapper = document.createElement("div");
        avatarWrapper.className = "driver-top-avatar";

        const avatarImg = document.createElement("img");
        avatarImg.alt = displayName;
        const fallback = document.createElement("div");
        fallback.className = "avatar-initials";
        fallback.textContent = riderInitials(displayName);

        const photoUrl =
          safeImageUrl(rider?.riderProfilePicUrl) ||
          safeImageUrl(rider?.riderPhotoUrl) ||
          safeImageUrl(rider?.riderAvatarUrl) ||
          safeImageUrl(rider?.riderImageUrl) ||
          null;
        if (photoUrl) {
          avatarImg.src = photoUrl;
          avatarImg.onerror = () => {
            avatarWrapper.classList.remove("has-photo");
            avatarImg.remove();
          };
          avatarWrapper.classList.add("has-photo");
          avatarWrapper.appendChild(avatarImg);
        }
        avatarWrapper.appendChild(fallback);
        driverOverlayAvatarRow.appendChild(avatarWrapper);

        const chip = document.createElement("span");
        chip.className = "driver-chip";
        chip.textContent = `Rider ${index + 1}`;
        driverOverlayChips.appendChild(chip);
      });
    }

    function setDriverOverlayState(state, options = {}) {
      const { forceReveal = false } = options;
      driverOverlayState = state;
      if (state === DRIVER_STATES.HIDDEN) {
        activeRideOverlay?.classList.remove("active");
        return;
      }
      if (forceReveal) {
        driverOverlayDismissed = false;
      }
      const pairs = [
        [driverStateOffer, DRIVER_STATES.OFFER],
        [driverStateNavPickup, DRIVER_STATES.NAV_PICKUP],
        [driverStateEnterPickup, DRIVER_STATES.ENTER_PICKUP],
        [driverStateNavDropoff, DRIVER_STATES.NAV_DROPOFF],
        [driverStateEnterDropoff, DRIVER_STATES.ENTER_DROPOFF],
        [driverStateComplete, DRIVER_STATES.COMPLETE]
      ];
      pairs.forEach(([el, key]) => {
        if (!el) return;
        if (state === key) {
          el.classList.add("active");
        } else {
          el.classList.remove("active");
        }
      });
      if (!driverOverlayDismissed) {
        activeRideOverlay?.classList.add("active");
      }
      evaluateDropoffGeofence();
      if (driverCompleteOverrideButton && state !== DRIVER_STATES.NAV_DROPOFF) {
        driverCompleteOverrideButton.style.display = "none";
      }
    }

    function openRideOfferOverlay(ride) {
      if (!ride) return;
      pendingRideOffer = ride;
      activeRideError.textContent = "";
      renderDriverTopBar([ride]);
      driverOfferPickupText.textContent = pickupLabel(ride) || "Pickup pending";
      driverOfferDropoffText.textContent = dropoffLabel(ride) || "Dropoff pending";
      const riderCount = ride?.numRiders || ride?.riderCount || ride?.currentRiderCount || 1;
      driverOfferRiderCount.textContent = `${riderCount} rider${riderCount === 1 ? "" : "s"}`;
      setDriverOverlayState(DRIVER_STATES.OFFER, { forceReveal: true });
    }

    function renderRides(allRides) {
      ridesList.innerHTML = "";
      const allowedStatuses = ["pending_driver", "pool_searching", "pooled_pending_driver", "pending"];

      const visible = allRides.filter((r) => {
        if (!isOnline) return false;
        if (r.driverId) return false;
        const st = r.status || "pending";
        return allowedStatuses.includes(st);
      });

      if (!visible.length) {
        ridesList.innerHTML = '<div class="small">No rides waiting right now.</div>';
        return;
      }

      visible.forEach((r) => {
        const div = document.createElement("div");
        div.className = "ride-card";
        const st = r.status || "pending";

        const isPool = !!r.isGroupRide || !!r.groupId;
        const tags = [];
        tags.push(membershipTag(r.membershipType || r.membership));
        if (isPool) tags.push('<span class="tag tag-pooled">Pooled</span>');
        if (r.poolType === "uofa") tags.push('<span class="tag tag-uofa">U of A</span>');

        div.innerHTML = `
          <div class="ride-header">
            <span>${r.riderName || "Rider"}</span>
            <span>${st}</span>
          </div>
          <div class="ride-line">${tags.join(" ")}</div>
          <div class="ride-line ride-meta">
            Dest: ${r.toDestination || r.toAddress || "Unknown"}
          </div>
          <div class="ride-line ride-meta">
            Group: ${r.groupId || "(none)"} • Riders: ${r.numRiders || r.riderCount || 1}
          </div>
          <div style="margin-top:4px;display:flex;justify-content:flex-end;gap:6px;">
            <button class="btn-secondary btn-small" data-decline-id="${r.id}">Decline</button>
            <button class="btn-primary btn-small" data-accept-id="${r.id}">Accept ride</button>
          </div>
        `;
        ridesList.appendChild(div);
      });

      ridesList.querySelectorAll("button[data-accept-id]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rideId = btn.getAttribute("data-accept-id");
          const ride = visible.find((r) => r.id === rideId);
          if (ride) openRideOfferOverlay(ride);
        });
      });

      ridesList.querySelectorAll("button[data-decline-id]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const rideId = btn.getAttribute("data-decline-id");
          const ride = visible.find((r) => r.id === rideId);
          if (ride) declineRide(ride);
        });
      });
    }

    async function declineRide(ride) {
      if (!currentUser) return;
      driverError.textContent = "";
      driverMessage.textContent = "";

      try {
        let groupRides = [ride];

        if ((ride.isGroupRide || ride.groupId) && ride.groupId) {
          const q = query(
            collection(db, "rideRequests"),
            where("groupId", "==", ride.groupId)
          );
          const snap = await getDocs(q);
          groupRides = [];
          snap.forEach((docSnap) => {
            const d = docSnap.data();
            if (!d.driverId) {
              groupRides.push({ id: docSnap.id, ...d });
            }
          });
          if (!groupRides.length) {
            groupRides = [ride];
          }
        }

        const batch = writeBatch(db);
        groupRides.forEach((r) => {
          const ref = doc(db, "rideRequests", r.id);
          batch.update(ref, {
            status: "driver_declined",
            driverId: null,
            driverDeclinedAt: serverTimestamp()
          });
        });

        await batch.commit();
        driverMessage.textContent = `Declined ${groupRides.length} ride(s).`;
      } catch (err) {
        console.error("declineRide error", err);
        driverError.textContent = err.message || "Error declining ride.";
      }
    }

    async function acceptRide(ride) {
      if (!currentUser) return null;
      driverError.textContent = "";
      driverMessage.textContent = "";

      try {
        let groupRides = [ride];

        if ((ride.isGroupRide || ride.groupId) && ride.groupId) {
          const q = query(
            collection(db, "rideRequests"),
            where("groupId", "==", ride.groupId)
          );
          const snap = await getDocs(q);
          groupRides = [];
          snap.forEach((docSnap) => {
            const d = docSnap.data();
            if (!d.driverId) {
              groupRides.push({ id: docSnap.id, ...d });
            }
          });
          if (!groupRides.length) {
            groupRides = [ride];
          }
        }

        const batch = writeBatch(db);
        const driverRef = doc(db, "drivers", currentUser.uid);
        const driverSnap = await getDoc(driverRef);
        if (driverSnap.exists()) {
          currentDriverProfile = { ...currentDriverProfile, ...driverSnap.data() };
        }

        const driverPhotoUrl =
          currentDriverProfile?.profilePicUrl ||
          currentDriverProfile?.avatarUrl ||
          currentDriverProfile?.photoURL ||
          null;
        const driverVehicleName = [
          currentDriverProfile?.vehicleYear,
          currentDriverProfile?.vehicleColor,
          currentDriverProfile?.vehicleMake,
          currentDriverProfile?.vehicleModel
        ]
          .filter(Boolean)
          .join(" ")
          .replace(/\s+/g, " ")
          .trim();
        const driverVehiclePhoto =
          currentDriverProfile?.vehiclePhotoUrl ||
          currentDriverProfile?.vehicleImageUrl ||
          null;
        const driverLicenseImage =
          currentDriverProfile?.licensePicUrl ||
          currentDriverProfile?.licenseImageUrl ||
          null;
        const driverPhone = currentDriverProfile?.phone || "";
        const driverRating =
          typeof currentDriverProfile?.rating === "number"
            ? currentDriverProfile.rating
            : null;
        const driverRatingCount =
          typeof currentDriverProfile?.ratingCount === "number"
            ? currentDriverProfile.ratingCount
            : null;

        const driverInfo = {
          driverId: currentUser.uid,
          driverEmail: currentUser.email || "",
          driverName: currentDriverProfile?.fullName || currentUser.email || "Driver",
          driverPhone,
          driverPhotoUrl,
          driverAvatarUrl: driverPhotoUrl,
          driverProfilePicUrl: driverPhotoUrl,
          driverVehicleMake: currentDriverProfile?.vehicleMake || "",
          driverVehicleModel: currentDriverProfile?.vehicleModel || "",
          driverVehicleColor: currentDriverProfile?.vehicleColor || "",
          driverVehicleYear: currentDriverProfile?.vehicleYear || "",
          driverVehicleName,
          driverVehicleDisplayName: driverVehicleName,
          driverVehiclePhotoUrl: driverVehiclePhoto,
          driverVehiclePlate: currentDriverProfile?.licensePlate || "",
          driverLicensePlate: currentDriverProfile?.licensePlate || "",
          driverLicenseStatus: currentDriverProfile?.licenseStatus || null,
          driverLicenseSummary: currentDriverProfile?.licenseStatus || null,
          driverLicenseMeta: currentDriverProfile?.licenseMeta || null,
          driverLicenseLast4: currentDriverProfile?.licenseLast4 || null,
          driverLicenseImageUrl: driverLicenseImage,
          driverLicensePhotoUrl: driverLicenseImage,
          driverLicenseVerified: !!currentDriverProfile?.licenseVerified,
          driverRating,
          driverRatingCount,
          driverVerifiedId: !!currentDriverProfile?.verifiedId,
          driverDrugTestCleared: !!currentDriverProfile?.drugTestCleared,
          driverBackgroundCheckCleared: !!currentDriverProfile?.backgroundCheckCleared,
          driverContactViaRideSync: !driverPhone,
          status: "driver_assigned",
          assignedAt: serverTimestamp()
        };

        groupRides.forEach((r) => {
          const ref = doc(db, "rideRequests", r.id);
          batch.update(ref, driverInfo);
        });

        await batch.commit();

        driverMessage.textContent = `Assigned to ${groupRides.length} rider(s).`;

        return groupRides.map((r) => ({
          ...r,
          ...driverInfo
        }));
      } catch (err) {
        console.error("acceptRide error", err);
        driverError.textContent = err.message || "Error accepting ride.";
        throw err;
      }
    }

    function clearActiveRideWatchers() {
      activeRideWatchers.forEach((unsub) => {
        if (typeof unsub === "function") unsub();
      });
      activeRideWatchers = [];
    }

    function getPrimaryRide() {
      return activeRideGroup.length ? activeRideGroup[0] : null;
    }

    function getPrimaryRideId() {
      const primary = getPrimaryRide();
      return primary ? primary.id : null;
    }

    function beginDriverRideFlow(groupRides) {
      if (!Array.isArray(groupRides) || !groupRides.length) return;
      driverOverlayDismissed = false;
      subscribeToActiveRideGroup(groupRides);
      setDriverOverlayState(DRIVER_STATES.NAV_PICKUP, { forceReveal: true });
    }

    function subscribeToActiveRideGroup(group) {
      clearActiveRideWatchers();
      activeRideGroup = group.slice();
      if (!activeRideGroup.length) {
        setDriverOverlayState(DRIVER_STATES.HIDDEN);
        return;
      }
      renderDriverTopBar(activeRideGroup);
      updateDriverStateFromRide(activeRideGroup[0]);
      activeRideWatchers = activeRideGroup.map((ride, index) => {
        const ref = doc(db, "rideRequests", ride.id);
        return onSnapshot(ref, (snap) => {
          if (!snap.exists()) return;
          const data = { id: snap.id, ...snap.data() };
          activeRideGroup[index] = data;
          renderDriverTopBar(activeRideGroup);
          if (index === 0) {
            updateDriverStateFromRide(data);
          }
        });
      });
    }

    function clearActiveRideFlow() {
      clearActiveRideWatchers();
      activeRideGroup = [];
      activeDropoffLocation = null;
      geofenceOverride = false;
      pendingRideOffer = null;
      driverOverlayDismissed = false;
      activeRideError.textContent = "";
      setDriverOverlayState(DRIVER_STATES.HIDDEN);
    }

    function normalizedRideStatus(ride) {
      const status = (ride?.status || "").toLowerCase();
      if (status === "driver_arrived") return "arrived_at_pickup";
      if (status === "in_progress") return "pickup_code_verified";
      return status;
    }

    function updateDriverStateFromRide(ride) {
      if (!ride) {
        setDriverOverlayState(DRIVER_STATES.HIDDEN);
        return;
      }

      const status = normalizedRideStatus(ride);

      switch (status) {
        case "driver_assigned":
        case "pending_driver":
        case "pool_searching":
        case "pooled_pending_driver":
          updateNavPickupView(ride);
          setDriverOverlayState(DRIVER_STATES.NAV_PICKUP, { forceReveal: true });
          break;
        case "arrived_at_pickup":
          updatePickupCodeView(ride);
          setDriverOverlayState(DRIVER_STATES.ENTER_PICKUP, { forceReveal: true });
          break;
        case "pickup_code_verified":
          updateNavDropoffView(ride);
          setDriverOverlayState(DRIVER_STATES.NAV_DROPOFF, { forceReveal: true });
          break;
        case "arrived_at_dropoff":
          updateDropoffCodeView();
          setDriverOverlayState(DRIVER_STATES.ENTER_DROPOFF, { forceReveal: true });
          break;
        case "dropoff_code_verified":
        case "completed":
          updateCompleteState(ride);
          setDriverOverlayState(DRIVER_STATES.COMPLETE, { forceReveal: true });
          break;
        case "canceled_by_rider":
          driverMessage.textContent = "Rider canceled the ride.";
          clearActiveRideFlow();
          break;
        default:
          updateNavPickupView(ride);
          setDriverOverlayState(DRIVER_STATES.NAV_PICKUP, { forceReveal: true });
      }
    }

    function updateNavPickupView(ride) {
      driverNavPickupAddress.textContent = pickupLabel(ride) || "Pickup pending";
      const etaMinutes =
        ride?.driverEtaMinutes ??
        ride?.pickupEtaMinutes ??
        ride?.estimatedDurationMinutes ??
        null;
      driverNavPickupEta.textContent = etaMinutes
        ? `Approx. ${Math.max(1, Math.round(etaMinutes))} min away`
        : "";
    }

    function updatePickupCodeView() {
      pickupCodeInput.value = "";
      pickupCodeError.textContent = "";
    }

    function updateNavDropoffView(ride) {
      driverNavDropoffAddress.textContent = dropoffLabel(ride) || "Destination pending";
      const etaMinutes =
        ride?.remainingEtaMinutes ??
        ride?.estimatedDurationMinutes ??
        null;
      driverDropoffEta.textContent = etaMinutes
        ? `Arriving in about ${Math.max(1, Math.round(etaMinutes))} min`
        : "";
      activeDropoffLocation = extractDropoffLocation(ride);
      geofenceOverride = false;
      driverCompleteOverrideButton.style.display = activeDropoffLocation ? "none" : "inline-flex";
      evaluateDropoffGeofence();
    }

    function updateDropoffCodeView() {
      dropoffCodeInput.value = "";
      dropoffCodeError.textContent = "";
    }

    function updateCompleteState(ride) {
      driverWaitingStatus.textContent =
        ride?.rating || ride?.riderRating
          ? "Rider feedback received."
          : "Waiting for rider rating and tip…";

      const ratingValue =
        ride?.rating ??
        ride?.riderRating ??
        ride?.driverRating ??
        null;
      if (typeof ratingValue === "number") {
        driverRatingResult.style.display = "block";
        driverRatingResult.textContent = `Rider rating: ${ratingValue.toFixed(1)} ★`;
      } else {
        driverRatingResult.style.display = "none";
      }

      const tipValue =
        ride?.tip ??
        ride?.tipAmount ??
        ride?.tip_value ??
        ride?.riderTip ??
        null;
      if (typeof tipValue === "number" && !Number.isNaN(tipValue) && tipValue > 0) {
        driverTipResult.style.display = "block";
        driverTipResult.textContent = `Tip: $${Number(tipValue).toFixed(2)}`;
      } else {
        driverTipResult.style.display = "none";
      }

      if (driverRatingResult.style.display === "block" || driverTipResult.style.display === "block") {
        driverCompleteDismissButton.style.display = "block";
      } else {
        driverCompleteDismissButton.style.display = "none";
      }
    }

    function getPickupCodeFromRide(ride) {
      return (
        ride?.pickupCode ??
        ride?.pickup_code ??
        ride?.pickupPin ??
        ride?.pickupPIN ??
        ride?.boardingCode ??
        null
      );
    }

    function getDropoffCodeFromRide(ride) {
      return (
        ride?.dropoffCode ??
        ride?.dropoff_code ??
        ride?.dropoffPin ??
        ride?.dropoffPIN ??
        ride?.dropoffBoardingCode ??
        null
      );
    }

    function normalizeRideCode(value) {
      if (value == null) return "";
      return String(value).trim().toUpperCase();
    }

    async function handleDriverOfferAccept() {
      if (!pendingRideOffer) return;
      activeRideError.textContent = "";
      driverOfferAcceptButton.disabled = true;
      driverOfferRejectButton.disabled = true;
      try {
        const group = await acceptRide(pendingRideOffer);
        pendingRideOffer = null;
        if (group && group.length) {
          beginDriverRideFlow(group);
        } else {
          setDriverOverlayState(DRIVER_STATES.HIDDEN);
        }
      } catch (err) {
        activeRideError.textContent = err.message || "Error accepting ride.";
      } finally {
        driverOfferAcceptButton.disabled = false;
        driverOfferRejectButton.disabled = false;
      }
    }

    function handleDriverOfferReject() {
      pendingRideOffer = null;
      setDriverOverlayState(DRIVER_STATES.HIDDEN);
    }

    async function handleDriverArriveAtPickup() {
      await updateActiveRideFields({
        status: "arrived_at_pickup",
        arrivedAtPickupAt: serverTimestamp()
      });
    }

    function handlePickupBack() {
      updateNavPickupView(getPrimaryRide());
      setDriverOverlayState(DRIVER_STATES.NAV_PICKUP, { forceReveal: true });
    }

    async function handlePickupCodeConfirm() {
      const code = pickupCodeInput.value.trim();
      pickupCodeError.textContent = "";
      if (!code) {
        pickupCodeError.textContent = "Enter the pickup code.";
        return;
      }
      const ride = getPrimaryRide();
      const expected = getPickupCodeFromRide(ride);
      if (expected && normalizeRideCode(code) !== normalizeRideCode(expected)) {
        pickupCodeError.textContent = "Code does not match. Try again.";
        return;
      }
      await updateActiveRideFields({
        status: "pickup_code_verified",
        pickupCodeVerified: true,
        pickupCodeEntered: code,
        pickupCodeVerifiedAt: serverTimestamp()
      });
    }

    async function handleDriverArriveAtDropoff() {
      await updateActiveRideFields({
        status: "arrived_at_dropoff",
        arrivedAtDropoffAt: serverTimestamp()
      });
    }

    async function handleDropoffCodeConfirm() {
      const code = dropoffCodeInput.value.trim();
      dropoffCodeError.textContent = "";
      if (!code) {
        dropoffCodeError.textContent = "Enter the dropoff code.";
        return;
      }
      const ride = getPrimaryRide();
      const expected = getDropoffCodeFromRide(ride);
      if (expected && normalizeRideCode(code) !== normalizeRideCode(expected)) {
        dropoffCodeError.textContent = "Code does not match. Try again.";
        return;
      }
      await updateActiveRideFields({
        status: "completed",
        dropoffCodeVerified: true,
        dropoffCodeEntered: code,
        dropoffCodeVerifiedAt: serverTimestamp(),
        completedAt: serverTimestamp()
      });
    }

    function handleRideCompleteDismiss() {
      clearActiveRideFlow();
    }

    async function updateActiveRideFields(fields) {
      if (!activeRideGroup.length) return;
      activeRideError.textContent = "";
      try {
        const batch = writeBatch(db);
        activeRideGroup.forEach((r) => {
          const ref = doc(db, "rideRequests", r.id);
          batch.update(ref, fields);
        });
        await batch.commit();
      } catch (err) {
        console.error("updateActiveRideFields error", err);
        activeRideError.textContent = err.message || "Error updating ride.";
      }
    }

    async function cancelActiveRideAsDriver() {
      if (!activeRideGroup.length) return;
      activeRideError.textContent = "";
      driverError.textContent = "";
      try {
        const batch = writeBatch(db);
        activeRideGroup.forEach((r) => {
          const ref = doc(db, "rideRequests", r.id);
          batch.update(ref, {
            status: "canceled_by_driver",
            driverCanceledAt: serverTimestamp()
          });
        });
        await batch.commit();
        driverMessage.textContent = "Ride canceled.";
        clearActiveRideFlow();
      } catch (err) {
        console.error("cancelActiveRideAsDriver error", err);
        activeRideError.textContent = err.message || "Error canceling ride.";
      }
    }

    function extractDropoffLocation(ride) {
      const candidates = [
        ride?.dropoffLocation,
        ride?.toLocation,
        ride?.destinationLocation,
        ride?.destLocation,
        ride?.dropoffGeo,
        ride?.toCoordinates,
        ride?.destCoordinates
      ];
      for (const candidate of candidates) {
        const parsed = parseLatLngCandidate(candidate);
        if (parsed) return parsed;
      }
      const pairCandidates = [
        ["dropoffLat", "dropoffLng"],
        ["destLat", "destLng"],
        ["toLat", "toLng"],
        ["destinationLat", "destinationLng"]
      ];
      for (const [latKey, lngKey] of pairCandidates) {
        if (typeof ride?.[latKey] === "number" && typeof ride?.[lngKey] === "number") {
          return { lat: ride[latKey], lng: ride[lngKey] };
        }
      }
      return null;
    }

    function parseLatLngCandidate(value) {
      if (!value) return null;
      if (typeof value.lat === "number" && typeof value.lng === "number") {
        return { lat: value.lat, lng: value.lng };
      }
      if (typeof value.latitude === "number" && typeof value.longitude === "number") {
        return { lat: value.latitude, lng: value.longitude };
      }
      return null;
    }

    function evaluateDropoffGeofence() {
      if (!driverCompleteButton) return;
      const isDropoffState = driverOverlayState === DRIVER_STATES.NAV_DROPOFF;
      if (!isDropoffState) {
        driverCompleteButton.disabled = true;
        return;
      }

      if (geofenceOverride) {
        driverGeofenceStatusEl.textContent = "Geofence override enabled.";
        driverGeofenceStatusEl.classList.add("armed");
        driverCompleteButton.disabled = false;
        return;
      }

      if (!activeDropoffLocation) {
        driverGeofenceStatusEl.textContent = "Destination location unavailable. Override to complete.";
        driverGeofenceStatusEl.classList.remove("armed");
        driverCompleteButton.disabled = true;
        driverCompleteOverrideButton.style.display = "inline-flex";
        return;
      }

      if (!driverCurrentPosition) {
        driverGeofenceStatusEl.textContent = "Waiting for your current location…";
        driverGeofenceStatusEl.classList.remove("armed");
        driverCompleteButton.disabled = true;
        return;
      }

      const distanceMeters = haversineMeters(driverCurrentPosition, activeDropoffLocation);
      const distanceFeet = distanceMeters * 3.28084;
      if (distanceMeters <= DROPOFF_GEOFENCE_METERS) {
        driverGeofenceStatusEl.textContent = `Within ${Math.round(distanceFeet)} ft of dropoff.`;
        driverGeofenceStatusEl.classList.add("armed");
        driverCompleteButton.disabled = false;
        driverCompleteOverrideButton.style.display = "none";
      } else {
        driverGeofenceStatusEl.textContent = `Complete ride unlocks within 150 ft. Currently ${Math.round(distanceFeet)} ft away.`;
        driverGeofenceStatusEl.classList.remove("armed");
        driverCompleteButton.disabled = true;
        driverCompleteOverrideButton.style.display = "none";
      }
    }

    function startDriverLocationWatch() {
      if (!navigator.geolocation || driverLocationWatcherId) return;
      driverLocationWatcherId = navigator.geolocation.watchPosition(
        (pos) => {
          driverCurrentPosition = {
            lat: pos.coords.latitude,
            lng: pos.coords.longitude
          };
          if (driverMarker) {
            driverMarker.setPosition(driverCurrentPosition);
          }
          evaluateDropoffGeofence();
        },
        (err) => {
          console.warn("watchPosition error", err);
        },
        { enableHighAccuracy: true }
      );
    }

    function haversineMeters(a, b) {
      const R = 6371000;
      const toRad = (deg) => (deg * Math.PI) / 180;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const sinLat = Math.sin(dLat / 2);
      const sinLng = Math.sin(dLng / 2);
      const h =
        sinLat * sinLat +
        Math.cos(lat1) * Math.cos(lat2) * sinLng * sinLng;
      const c = 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
      return R * c;
    }

    function ensureBackgroundMapReady() {
      if (map) return;
      if (window.google && google.maps) {
        initMap();
        return;
      }
      setTimeout(ensureBackgroundMapReady, 600);
    }

    if (driverOfferAcceptButton) {
      driverOfferAcceptButton.addEventListener("click", handleDriverOfferAccept);
    }
    if (driverOfferRejectButton) {
      driverOfferRejectButton.addEventListener("click", handleDriverOfferReject);
    }
    if (driverArriveButton) {
      driverArriveButton.addEventListener("click", handleDriverArriveAtPickup);
    }
    if (driverPickupBackButton) {
      driverPickupBackButton.addEventListener("click", handlePickupBack);
    }
    if (driverPickupConfirmButton) {
      driverPickupConfirmButton.addEventListener("click", handlePickupCodeConfirm);
    }
    if (driverCompleteButton) {
      driverCompleteButton.addEventListener("click", handleDriverArriveAtDropoff);
    }
    if (driverCompleteOverrideButton) {
      driverCompleteOverrideButton.addEventListener("click", () => {
        geofenceOverride = true;
        driverCompleteOverrideButton.style.display = "none";
        evaluateDropoffGeofence();
      });
    }
    if (driverDropoffConfirmButton) {
      driverDropoffConfirmButton.addEventListener("click", handleDropoffCodeConfirm);
    }
    if (driverCompleteDismissButton) {
      driverCompleteDismissButton.addEventListener("click", handleRideCompleteDismiss);
    }
    if (driverCancelRideLink) {
      driverCancelRideLink.addEventListener("click", cancelActiveRideAsDriver);
    }

    if (closeActiveRideButton) {
      closeActiveRideButton.addEventListener("click", () => {
        driverOverlayDismissed = true;
        activeRideOverlay?.classList.remove("active");
      });
    }

    ensureBackgroundMapReady();
  </script>
</body>
</html>