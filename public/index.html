<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RideSync – NWA & U of A</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#020617" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="/manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/icon-192.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-180.png" />

  <!-- Stripe placeholder (real payments wired later) -->
  <script src="https://js.stripe.com/v3"></script>

  <!-- QR code library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

  <script type="importmap">
    {
      "imports": {
        "@/lib/firebase": "/src/lib/firebase.js",
        "firebase/app": "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js",
        "firebase/auth": "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js"
      }
    }
  </script>

  <style>
    * { box-sizing: border-box; }
    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --weather-bg: radial-gradient(circle at top, #1d4ed8, #020617 55%);
      --weather-panel-bg: rgba(2,6,23,0.92);
      --weather-panel-border: rgba(148,163,184,0.45);
      --weather-overlay-bg: rgba(2,6,23,0.92);
      --weather-overlay-border: rgba(148,163,184,0.45);
      --weather-ambient-glow: rgba(59,130,246,0.4);
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--weather-bg);
      color: #f9fafb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 10px;
      position: relative;
      overflow-x: hidden;
      transition: background 0.5s ease;
    }
    body.landing-active {
      overflow: hidden;
    }
    body.landing-active .card,
    body.landing-active .site-footer,
    body.landing-active .top-right {
      display: none;
    }
    body.landing-active #map {
      opacity: 0;
      pointer-events: none;
    }
    .main-landing {
      position: fixed;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--weather-bg);
      padding: clamp(18px, 6vw, 32px);
      gap: clamp(24px, 6vw, 48px);
      text-align: center;
      z-index: 40;
    }
    .main-landing.active {
      display: flex;
    }
    .main-landing.home-screen {
      backdrop-filter: blur(12px);
    }
    .main-landing-wordmark {
      display: flex;
      align-items: baseline;
      justify-content: center;
      gap: 0.25em;
      font-size: clamp(2.6rem, 9vw, 4.8rem);
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #f8fafc;
      text-shadow:
        0 12px 32px rgba(15,23,42,0.8),
        0 0 24px rgba(248,250,252,0.25);
      pointer-events: none;
    }
    .main-landing-wordmark .brand-accent {
      color: #ef4444;
    }
    .landing-copyright {
      font-size: 0.75rem;
      color: #94a3b8;
      max-width: 320px;
      line-height: 1.4;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .landing-button {
      width: clamp(160px, 32vw, 200px);
      height: clamp(160px, 32vw, 200px);
      border-radius: 50%;
      border: 3px solid rgba(248,250,252,0.5);
      background: linear-gradient(145deg, #ef4444, #1d4ed8);
      box-shadow:
        0 18px 45px rgba(2,6,23,0.65),
        0 0 25px var(--weather-ambient-glow),
        inset 0 0 12px rgba(248,250,252,0.25);
      color: #f9fafb;
      font-size: 1.1rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 0 16px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }
    .landing-button:hover {
      transform: translateY(-4px);
      box-shadow:
        0 24px 60px rgba(2,6,23,0.75),
        0 0 30px var(--weather-ambient-glow),
        inset 0 0 14px rgba(248,250,252,0.35);
    }
    .landing-button:focus-visible {
      transform: translateY(-4px);
      box-shadow:
        0 24px 60px rgba(2,6,23,0.75),
        0 0 30px rgba(59,130,246,0.6),
        inset 0 0 14px rgba(248,250,252,0.35);
      outline: 3px solid rgba(248,250,252,0.65);
      outline-offset: 6px;
    }
    .landing-button:active {
      transform: translateY(2px) scale(0.98);
    }
    .landing-button-secondary {
      background: linear-gradient(145deg, rgba(248,250,252,0.08), rgba(15,23,42,0.85));
      border-color: rgba(148,163,184,0.6);
      color: #cbd5f5;
      box-shadow:
        0 16px 40px rgba(2,6,23,0.65),
        0 0 22px var(--weather-ambient-glow),
        inset 0 0 10px rgba(15,23,42,0.6);
    }
    .landing-button-secondary:hover,
    .landing-button-secondary:focus-visible {
      box-shadow:
        0 22px 55px rgba(2,6,23,0.75),
        0 0 28px var(--weather-ambient-glow),
        inset 0 0 14px rgba(15,23,42,0.8);
    }
    .site-footer {
      width: 100%;
      max-width: 520px;
      margin-top: auto;
      text-align: center;
      font-size: 0.75rem;
      color: #94a3b8;
      padding: 8px 0 calc(var(--safe-bottom) + 6px);
    }
    .site-footer p {
      margin: 0;
      color: inherit;
    }
    @supports (height: 100dvh) {
      body {
        min-height: 100dvh;
      }
    }
    .card {
      background: rgba(2,6,23,0.92);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.45);
      box-shadow: 0 24px 60px rgba(0,0,0,0.6);
      width: 100%;
      max-width: 520px;
      max-height: 96vh;
      padding: 22px 18px 18px;
      overflow-y: auto;
      position: relative;
      z-index: 2;
      backdrop-filter: blur(12px);
    }
    h1, h2 { margin: 0 0 8px; text-align: center; }
    h1 { font-size: 1.6rem; }
    h2 { font-size: 1.1rem; }
    .subtitle {
      margin: 0 0 18px;
      text-align: center;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    label {
      font-size: 0.8rem;
      display: block;
      margin-bottom: 4px;
      color: #e5e7eb;
    }
    input, select {
      width: 100%;
      padding: 9px 11px;
      border-radius: 10px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #f9fafb;
      font-size: 0.9rem;
      margin-bottom: 10px;
    }
    input:focus, select:focus {
      outline: 2px solid #2563eb;
      outline-offset: 1px;
    }
    button {
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      margin-top: 4px;
      transition: background 0.2s ease, color 0.2s ease, opacity 0.2s ease;
    }
    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .btn-primary { background: #22c55e; color: #022c22; }
    .btn-danger { background: #dc2626; color: #fee2e2; }
    .btn-success { background: #16a34a; color: #022c22; }
    .btn-secondary {
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #4b5563;
      margin-top: 8px;
    }
    .reserve-mode-options {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin: 8px 0 10px;
    }
    .reserve-mode-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.6);
      font-size: 0.9rem;
    }
    .reserve-mode-option input {
      width: auto;
      margin: 0;
    }
    .reserve-datetime-row {
      display: none;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 8px;
    }
    .reserve-datetime-field {
      flex: 1 1 160px;
      display: flex;
      flex-direction: column;
    }
    .reserve-datetime-field label {
      margin: 0 0 4px;
      font-size: 0.75rem;
      color: #cbd5f5;
    }
    .btn-small {
      width: auto;
      padding: 6px 10px;
      font-size: 0.8rem;
      border-radius: 999px;
    }
    .rider-action-box {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 14px;
    }
    .rider-action-header {
      font-size: 0.85rem;
      color: #cbd5f5;
      font-weight: 600;
    }
    .rider-action-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .rider-action-buttons button {
      width: auto;
      flex: 1 1 0%;
      margin-top: 0;
    }
    @media (min-width: 520px) {
      .rider-action-buttons {
        flex-direction: row;
      }
    }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .row > div { flex: 1 1 120px; }
    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin: 14px 0 6px;
      border-top: 1px solid rgba(148,163,184,0.4);
      padding-top: 8px;
    }
    .toggle-auth {
      display: flex;
      justify-content: center;
      gap: 6px;
      font-size: 0.8rem;
      margin-bottom: 10px;
      color: #9ca3af;
    }
    .toggle-auth span { text-decoration: underline; cursor: pointer; }

    .error { color: #fecaca; font-size: 0.8rem; min-height: 18px; margin-bottom: 6px; }
    .success { color: #bbf7d0; font-size: 0.8rem; min-height: 18px; margin-bottom: 6px; }
    .small { font-size: 0.75rem; color: #9ca3af; margin-top: 4px; }

    #authView, #rideView, #loadingView { display: none; }
    #authView.active, #rideView.active, #loadingView.active { display: block; }

    #map {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    .fare-box {
      background: rgba(15,23,42,0.9);
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.5);
      padding: 9px 11px;
      font-size: 0.8rem;
      margin-bottom: 10px;
    }
    .trip-builder-card {
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding: 14px;
    }
    .trip-builder-fields {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .trip-field {
      display: flex;
      flex-direction: column;
    }
    .group-qr-section {
      margin-top: 12px;
      gap: 6px;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      transition: max-height 0.25s ease, opacity 0.2s ease;
    }
    .group-qr-section.visible {
      max-height: 360px;
      opacity: 1;
    }
    .sync-riders-button {
      width: auto;
      align-self: flex-start;
      margin-top: 6px;
      padding: 6px 14px;
    }
    .sync-qr-trigger {
      display: inline-flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      min-width: 0;
    }
    .sync-qr-trigger::after {
      content: "";
      display: inline-block;
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 4px 4px 0 4px;
      border-color: currentColor transparent transparent transparent;
      margin-left: auto;
    }
    body.host-guest-bypass .sync-qr-trigger::after {
      border-top-color: #facc15;
    }
    body.guest-bypass-active #rideViewTabMembership,
    body.guest-bypass-active #rideViewTabInfo {
      display: none;
    }
    .guest-contribution-card {
      border-style: dashed;
      border-color: rgba(234,179,8,0.5);
    }
    .guest-contribution-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
    }
    .guest-contribution-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 8px;
    }
    .guest-contribution-row input {
      flex: 1;
      min-width: 0;
    }
    .currency-prefix {
      font-weight: 600;
      color: #facc15;
    }
    .guest-contribution-summary {
      font-size: 0.75rem;
      color: #cbd5f5;
      min-height: 18px;
      margin-top: 4px;
    }
    .sync-riders-modal-card {
      width: min(420px, calc(100% - 40px));
      background: rgba(2,6,23,0.95);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.45);
      padding: 18px;
      box-shadow: 0 20px 45px rgba(2,6,23,0.85);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .sync-riders-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
    }
    .sync-riders-modal-card canvas {
      width: 220px;
      height: 220px;
      margin: 8px auto;
      background: #fff;
      border-radius: 12px;
      padding: 8px;
    }
    .sync-riders-modal-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .sync-riders-modal-link {
      font-size: 0.75rem;
      word-break: break-all;
      color: #93c5fd;
    }
    .sync-riders-copy-feedback {
      min-height: 18px;
    }
    .destination-input-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .destination-input-row input {
      flex: 1;
    }
    .add-stop-button {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(34,197,94,0.6);
      background: rgba(34,197,94,0.1);
      color: #bbf7d0;
      font-size: 1.2rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .add-stop-button:focus-visible {
      outline: 2px solid rgba(34,197,94,0.8);
      outline-offset: 2px;
    }
    .add-stop-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .extra-stops {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }
    .extra-stops:empty {
      margin-top: 0;
    }
    .extra-stop-field {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(15,23,42,0.8);
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.35);
      padding: 6px 8px;
    }
    .extra-stop-field input {
      flex: 1;
      background: transparent;
      border: none;
      color: #f8fafc;
    }
    .extra-stop-field input:focus {
      outline: none;
    }
    .remove-stop-btn {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 1px solid rgba(248,113,113,0.4);
      background: rgba(2,6,23,0.85);
      color: #fecaca;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .remove-stop-btn:focus-visible {
      outline: 2px solid rgba(248,113,113,0.5);
      outline-offset: 2px;
    }
    .extra-stop-hint {
      margin-top: 6px;
      color: #94a3b8;
    }
    .trip-map-preview {
      position: relative;
      min-height: 180px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.3);
      background: #020617;
      overflow: hidden;
    }
    .trip-map-canvas {
      position: absolute;
      inset: 0;
    }
    .map-empty-state {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 14px;
      text-align: center;
      font-size: 0.8rem;
      color: #94a3b8;
      background: linear-gradient(135deg, rgba(15,23,42,0.92), rgba(2,6,23,0.92));
      transition: opacity 0.25s ease;
    }
    .trip-map-preview.has-destination .map-empty-state {
      opacity: 0;
      pointer-events: none;
    }
    @media (min-width: 640px) {
      .trip-builder-card {
        flex-direction: row;
        align-items: stretch;
      }
      .trip-builder-fields,
      .trip-map-preview {
        flex: 1 1 0%;
      }
    }
    @media (max-width: 430px) {
      body {
        align-items: stretch;
        justify-content: flex-start;
        gap: 6px;
        padding: calc(var(--safe-top) + 8px) clamp(10px, 4vw, 18px) calc(var(--safe-bottom) + 12px);
      }
      .card {
        width: 100%;
        max-width: none;
        max-height: none;
        min-height: calc(100vh - var(--safe-top) - var(--safe-bottom));
        border-radius: 0;
        padding: 18px clamp(14px, 4.8vw, 26px) calc(24px + var(--safe-bottom));
        box-shadow: 0 18px 50px rgba(0,0,0,0.5);
      }
      @supports (height: 100dvh) {
        .card {
          min-height: calc(100dvh - var(--safe-top) - var(--safe-bottom));
        }
      }
      h1 { font-size: 1.35rem; }
      h2 { font-size: 1rem; }
      .subtitle { font-size: 0.82rem; }
      .section-title { font-size: 0.72rem; letter-spacing: 0.06em; }
      .rider-action-box,
      .rider-info-card,
      .membership-card,
      .trip-builder-card {
        padding: 12px;
      }
      .rider-action-buttons {
        flex-direction: column;
        gap: 6px;
      }
      .trip-map-preview {
        min-height: 150px;
      }
      .rider-info-grid,
      .membership-plan-grid {
        grid-template-columns: 1fr;
      }
      .membership-plan {
        gap: 6px;
      }
    }
    @media (max-width: 360px) {
      body {
        padding-left: clamp(8px, 6vw, 16px);
        padding-right: clamp(8px, 6vw, 16px);
      }
      h1 { font-size: 1.18rem; }
      .rider-info-value { font-size: 0.85rem; }
      button { font-size: 0.85rem; }
    }
    .fare-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
    }
    .fare-label { color: #9ca3af; }
    .fare-value { color: #e5e7eb; }
    .fare-total { color: #bbf7d0; font-weight: 600; }
    .ride-fare-details {
      margin-top: 6px;
      font-size: 0.85rem;
      color: #9ca3af;
      line-height: 1.45;
    }
    .ride-payment-button {
      margin: 16px 0 10px;
    }
    .ride-card-element {
      margin-top: 8px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(15,23,42,0.6);
    }
    #rideCardSubmit {
      width: 100%;
      margin-top: 12px;
    }
    .ride-payment-status {
      font-size: 0.85rem;
      color: #22c55e;
      margin-top: 4px;
    }
    .ride-payment-status.error {
      color: #fecaca;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid #4b5563;
      background: rgba(15,23,42,0.9);
      margin-top: 3px;
    }
    .badge-basic { border-color:#3b82f6; color:#bfdbfe; }
    .badge-uofa { border-color:#22c55e; color:#bbf7d0; }
    .badge-nwa { border-color:#f97316; color:#fed7aa; }
    .badge-tag { font-size: 0.68rem; color:#e5e7eb; opacity:0.8; }

    .rider-header {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .rider-avatar {
      width: 60px;
      height: 60px;
      border-radius: 999px;
      border: 2px solid rgba(148,163,184,0.8);
      object-fit: cover;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #9ca3af;
      font-size: 1.1rem;
      overflow: hidden;
    }
    .rider-header-text { flex: 1 1 auto; min-width: 0; }
    .rider-name { font-size: 1rem; font-weight: 600; }
    .rider-contact { font-size: 0.8rem; color: #9ca3af; }

    .rider-info-card {
      background: rgba(15,23,42,0.92);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.5);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 12px;
    }
    .rider-info-main {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .rider-info-text {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1 1 auto;
    }
    .rider-info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
    }
    .rider-info-field {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(2,6,23,0.85);
      padding: 10px 12px;
    }
    .rider-info-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #94a3b8;
      margin-bottom: 2px;
    }
    .rider-info-value {
      font-size: 0.9rem;
      color: #f9fafb;
      word-break: break-word;
    }
    .rider-info-actions {
      display: flex;
      justify-content: flex-end;
    }

    .membership-card {
      background: rgba(15,23,42,0.92);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.45);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 16px;
    }
    .membership-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .membership-subtitle {
      margin: 2px 0 0;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .membership-status-badge {
      font-size: 0.75rem;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .membership-status-badge.active {
      border-color: #22c55e;
      color: #bbf7d0;
    }
    .membership-status-badge.inactive {
      border-color: #f97316;
      color: #fed7aa;
    }
    .membership-status-badge.pending {
      border-color: #facc15;
      color: #fef3c7;
    }
    .membership-plan-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
    }
    .membership-plan-grid.checkout-plans {
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .membership-plan {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(2,6,23,0.85);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 0;
    }
    .membership-plan.active {
      border-color: #22c55e;
      background: rgba(34,197,94,0.08);
    }
    .membership-plan-title {
      font-weight: 600;
    }
    .membership-plan-price {
      font-size: 1rem;
      color: #f9fafb;
    }
    .membership-plan-desc {
      font-size: 0.78rem;
      color: #9ca3af;
      margin: 0;
    }
    .membership-plan-note {
      font-style: italic;
      color: #cbd5f5;
    }
    .membership-plan button {
      margin-top: auto;
    }
    .membership-plan-hint {
      font-size: 0.75rem;
      color: #fbbf24;
      margin: 0;
    }
    .membership-plan-card {
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
      text-align: left;
    }
    .membership-plan-card.checkout-option {
      width: 100%;
    }
    .membership-plan-card:hover {
      border-color: #22c55e;
      background: rgba(34,197,94,0.12);
    }
    .membership-plan-card:focus-visible {
      outline: 2px solid #22c55e;
      outline-offset: 3px;
    }
    .membership-terms-content {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(2,6,23,0.9);
      padding: 14px;
      max-height: min(60vh, 420px);
      overflow-y: auto;
      margin: 12px 0;
      scroll-behavior: smooth;
    }
    .membership-terms-footer {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 6px;
    }
    .membership-terms-footer label {
      margin: 0;
    }

    .payment-overlay {
      position: fixed;
      inset: 0;
      background: var(--weather-overlay-bg);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 80;
    }
    .payment-overlay.active {
      display: flex;
    }
    .payment-panel {
      width: min(480px, 100%);
      background: var(--weather-panel-bg);
      border-radius: 18px;
      border: 1px solid var(--weather-panel-border);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.6);
      max-height: min(90vh, 640px);
      overflow-y: auto;
      overscroll-behavior: contain;
    }
    .payment-panel.compact {
      max-width: 420px;
      text-align: center;
      gap: 12px;
    }
    .payment-redirect-icon {
      font-size: 2rem;
    }
    .payment-redirect-subtitle {
      color: #cbd5f5;
      font-size: 0.95rem;
      margin: 0;
    }
    .payment-redirect-spinner {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 3px solid rgba(148,163,184,0.35);
      border-top-color: #22c55e;
      margin: 12px auto 0;
      animation: paymentRedirectSpin 1s linear infinite;
    }
    @keyframes paymentRedirectSpin {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }
    .payment-status-overlay .payment-result-card {
      width: min(420px, 100%);
      background: var(--weather-panel-bg);
      border-radius: 20px;
      border: 1px solid var(--weather-panel-border);
      padding: 24px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.6);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    @supports (height: 100dvh) {
      .payment-panel {
        max-height: min(90dvh, 640px);
      }
    }
    @media (max-width: 520px) {
      .overlay {
        align-items: flex-start;
      }
      .payment-panel {
        width: 100%;
        border-radius: 16px;
      }
    }
    .payment-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
    }
    .payment-panel-title {
      margin: 0;
      font-size: 1.2rem;
    }
    .payment-panel-subtitle {
      margin: 4px 0 0;
      font-size: 0.9rem;
      color: #9ca3af;
    }
    .sync-membership-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .sync-membership-card {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.85);
      padding: 12px 14px;
      display: flex;
      gap: 12px;
      align-items: flex-start;
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
      cursor: pointer;
      position: relative;
      width: 100%;
      text-align: left;
      color: inherit;
      font: inherit;
    }
    .sync-membership-card input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }
    .sync-membership-card.active {
      border-color: #22c55e;
      background: rgba(34,197,94,0.08);
    }
    .sync-membership-card.disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }
    .sync-membership-card:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }
    .sync-membership-card .plan-pill {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid rgba(148,163,184,0.5);
      margin-top: 4px;
      flex-shrink: 0;
    }
    .sync-membership-card.active .plan-pill {
      border-color: #22c55e;
      background: #22c55e;
    }
    .sync-membership-card .plan-content {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .sync-membership-card .plan-label {
      font-weight: 600;
    }
    .sync-membership-card .plan-price {
      font-size: 0.9rem;
      color: #cbd5f5;
    }
    .sync-membership-card .plan-desc {
      font-size: 0.8rem;
      color: #94a3b8;
      margin: 0;
    }
    .sync-membership-card.info-only {
      cursor: default;
      pointer-events: none;
    }
    .sync-tip-note {
      font-size: 0.78rem;
      color: #94a3b8;
      margin-top: -6px;
    }
    .fare-section {
      margin-top: 12px;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(15,23,42,0.65);
    }
    .fare-section .small {
      margin-top: 6px;
      color: #94a3b8;
    }
    .field-label {
      display: block;
      font-size: 0.85rem;
      color: #cbd5f5;
      font-weight: 600;
      margin-bottom: 6px;
    }
    .select-input,
    .text-input {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(2,6,23,0.82);
      color: #f8fafc;
      font-size: 1rem;
      padding: 10px 12px;
    }
    .select-input:focus,
    .text-input:focus {
      outline: 2px solid rgba(34,197,94,0.4);
      border-color: rgba(34,197,94,0.6);
    }
    .inline-input-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
    }
    .inline-input-row input {
      flex: 1;
    }
    .inline-input-row button {
      flex-shrink: 0;
      align-self: stretch;
    }
    .payment-fare-summary {
      border-top: 1px solid rgba(148,163,184,0.25);
      padding-top: 8px;
      margin-top: -4px;
    }
    .fare-extra-stops {
      margin-top: 6px;
    }

    .loading-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 240px;
      text-align: center;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 4px solid rgba(148,163,184,0.4);
      border-top-color: #22c55e;
      animation: spin 1s linear infinite;
      margin-bottom: 14px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .overlay {
      position: fixed;
      inset: 0;
      background: var(--weather-overlay-bg);
      backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: clamp(12px, 4vw, 24px);
      z-index: 50;
      overflow-y: auto;
    }
    .overlay.active { display: flex; }
    .cooldown-panel {
      width: min(420px, 100%);
      background: var(--weather-panel-bg);
      border-radius: 20px;
      border: 1px solid var(--weather-panel-border);
      padding: clamp(18px, 4vw, 28px);
      display: flex;
      flex-direction: column;
      gap: 12px;
      text-align: center;
      box-shadow: 0 28px 70px rgba(0,0,0,0.65);
    }
    .cooldown-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #cbd5f5;
    }
    .cooldown-timer {
      font-size: clamp(2.2rem, 9vw, 3rem);
      font-weight: 600;
      letter-spacing: 0.08em;
      color: #bfdbfe;
    }
    .cooldown-hint {
      font-size: 0.9rem;
      color: #94a3b8;
      line-height: 1.4;
    }
    .cooldown-overlay .btn-primary {
      margin-top: 6px;
    }
    .rider-overlay-shell {
      width: min(520px, 100%);
      max-height: 100%;
      overflow-y: auto;
      background: var(--weather-panel-bg);
      border: 1px solid var(--weather-panel-border);
      border-radius: 20px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.65);
    }
    .driver-coming-soon-shell {
      text-align: center;
    }
    .driver-coming-soon-copy {
      font-size: 1.05rem;
      color: #cbd5f5;
      margin: 0;
    }
    .overlay-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 12px;
    }
    .overlay-title { font-size:1.2rem; font-weight:600; }
    .overlay-subtitle { font-size:0.85rem; color:#9ca3af; margin-top:2px; }
    .overlay-close {
      border-radius:999px;
      border:1px solid #4b5563;
      background:#020617;
      color:#e5e7eb;
      padding:6px 12px;
      cursor:pointer;
      font-size:0.82rem;
      flex-shrink: 0;
    }
    .rider-state {
      display: none;
      flex-direction: column;
      gap: 12px;
    }
    .rider-state.active { display: flex; }
    .state-text {
      font-size: 1rem;
      font-weight: 600;
    }
    .state-subtext {
      font-size: 0.9rem;
      color: #9ca3af;
    }
    .waitlist-panel {
      display: none;
      flex-direction: column;
      gap: 10px;
      margin-top: 8px;
      padding: 16px;
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.85);
    }
    .waitlist-panel.active {
      display: flex;
    }
    .waitlist-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      color: #f97316;
    }
    .waitlist-indicator-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #fb923c;
      box-shadow: 0 0 10px rgba(251,146,60,0.8);
      animation: waitlistPulse 1.8s ease-in-out infinite;
    }
    .waitlist-status {
      font-size: 0.9rem;
      color: #cbd5f5;
    }
    .waitlist-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .waitlist-pill {
      font-size: 0.78rem;
      padding: 4px 12px;
      border-radius: 999px;
      border: 1px solid rgba(94,234,212,0.4);
      background: rgba(13,148,136,0.15);
      color: #5eead4;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .waitlist-pill:empty {
      display: none;
    }
    .waitlist-timer-block {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    .waitlist-timer-label {
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #94a3b8;
    }
    .waitlist-timer-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: #fef3c7;
    }
    @keyframes waitlistPulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.4); opacity: 0.6; }
      100% { transform: scale(1); opacity: 1; }
    }
    .pin-card {
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.9);
      padding: 16px;
      text-align: center;
    }
    .pin-label {
      font-size: 0.9rem;
      color: #cbd5f5;
      margin-bottom: 6px;
    }
    .pin-value {
      font-size: 2.5rem;
      letter-spacing: 0.4rem;
      font-weight: 700;
      color: #f9fafb;
    }
    .pin-hint {
      font-size: 0.85rem;
      color: #9ca3af;
      margin-top: 6px;
    }
    .driver-info-slot {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .driver-info-stack {
      display: flex;
      flex-direction: column;
      gap: 14px;
      border: 1px solid rgba(148,163,184,0.5);
      border-radius: 18px;
      padding: 16px;
      background: rgba(2,6,23,0.95);
    }
    .driver-info-stack > :not(:first-child) {
      border-top: 1px solid rgba(148,163,184,0.25);
      padding-top: 14px;
    }
    .driver-identity-card,
    .driver-vehicle-card,
    .driver-license-card {
      border: none;
      border-radius: 0;
      padding: 0;
      background: transparent;
    }
    .ride-chat-card {
      display: flex;
      flex-direction: column;
      gap: 10px;
      border: 1px solid rgba(148,163,184,0.45);
      border-radius: 18px;
      padding: 14px;
      background: rgba(2,6,23,0.95);
      box-shadow: inset 0 0 0 rgba(0,0,0,0);
    }
    .ride-chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .ride-chat-title {
      font-size: 0.95rem;
      font-weight: 600;
    }
    .ride-chat-note {
      font-size: 0.75rem;
      color: #94a3b8;
      display: none;
    }
    .ride-chat-messages {
      min-height: 160px;
      max-height: 220px;
      overflow-y: auto;
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 14px;
      padding: 12px;
      background: rgba(15,23,42,0.8);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .ride-chat-message {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-width: 90%;
    }
    .ride-chat-message.from-self {
      align-self: flex-end;
      text-align: right;
    }
    .ride-chat-message.from-peer {
      align-self: flex-start;
      text-align: left;
    }
    .ride-chat-bubble {
      display: inline-flex;
      padding: 8px 12px;
      border-radius: 14px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(148,163,184,0.4);
      color: #f9fafb;
      font-size: 0.9rem;
      line-height: 1.35;
      word-break: break-word;
      white-space: pre-wrap;
    }
    .ride-chat-message.from-self .ride-chat-bubble {
      background: rgba(59,130,246,0.18);
      border-color: rgba(59,130,246,0.45);
    }
    .ride-chat-message.from-peer .ride-chat-bubble {
      background: rgba(15,23,42,0.95);
    }
    .ride-chat-meta {
      font-size: 0.7rem;
      color: #94a3b8;
    }
    .ride-chat-placeholder {
      text-align: center;
      font-size: 0.85rem;
      color: #94a3b8;
      padding: 12px 0;
    }
    .ride-chat-input-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .ride-chat-input {
      flex: 1 1 auto;
      border-radius: 12px;
      border: 1px solid #4b5563;
      padding: 10px 12px;
      background: #020617;
      color: #f9fafb;
      font-size: 0.9rem;
    }
    .ride-chat-input:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .ride-chat-send {
      flex: 0 0 auto;
    }
    .support-panel {
      border: none;
      border-radius: 0;
      padding: 0;
      background: transparent;
    }
    .driver-identity-card {
      margin-top: 0;
    }
    .driver-identity-header {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .driver-identity-avatar {
      width: 64px;
      height: 64px;
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.7);
      overflow: hidden;
      background: #0f172a;
      position: relative;
      flex-shrink: 0;
    }
    .driver-identity-avatar img,
    .driver-vehicle-photo img,
    .driver-license-photo img,
    .eta-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }
    .avatar-fallback {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #94a3b8;
      font-size: 0.9rem;
    }
    .driver-identity-meta { flex: 1 1 auto; min-width: 0; }
    .driver-identity-name-row {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }
    .driver-identity-name {
      font-size: 1rem;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .driver-rating-pill {
      font-size: 0.76rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(251,191,36,0.6);
      color: #fcd34d;
      background: rgba(120,53,15,0.25);
      display: none;
      white-space: nowrap;
    }
    .driver-identity-status {
      font-size: 0.78rem;
      color: #9ca3af;
      margin-top: 2px;
    }
    .driver-identity-phone {
      font-size: 0.82rem;
      color: #e5e7eb;
      margin-top: 4px;
    }
    .driver-identity-badges {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .driver-badge-pill {
      font-size: 0.7rem;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(94,234,212,0.5);
      color: #99f6e4;
      background: rgba(13,148,136,0.2);
    }
    .driver-vehicle-card,
    .driver-license-card {
      display: none;
    }
    .driver-vehicle-body,
    .driver-license-body {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .driver-vehicle-photo,
    .driver-license-photo {
      width: 96px;
      height: 72px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.5);
      overflow: hidden;
      background: #0f172a;
      position: relative;
      flex-shrink: 0;
    }
    .driver-vehicle-details,
    .driver-license-details {
      font-size: 0.82rem;
      color: #e5e7eb;
    }
    .driver-vehicle-name {
      font-weight: 600;
      margin-bottom: 2px;
    }
    .driver-license-card .driver-license-summary {
      font-weight: 600;
      margin-bottom: 2px;
    }
    .driver-license-meta {
      font-size: 0.75rem;
      color: #94a3b8;
    }
    .driver-identity-eta {
      font-size: 0.85rem;
      color: #cbd5f5;
      margin-top: 10px;
    }
    .driver-mini-map-shell {
      position: relative;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      margin-top: 12px;
      overflow: hidden;
      min-height: 180px;
      background: rgba(15,23,42,0.9);
      display: none;
    }
    .driver-mini-map {
      width: 100%;
      height: 200px;
    }
    .driver-mini-map-status {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      color: #cbd5f5;
      background: rgba(2,6,23,0.9);
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
    }
    .driver-mini-map-shell.show-status .driver-mini-map-status {
      opacity: 1;
    }
    .support-panel {
      display: none;
      scroll-margin-top: 16px;
    }
    .support-panel.active {
      display: block;
    }
    .support-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }
    .support-panel-text {
      font-size: 0.82rem;
      color: #cbd5f5;
      margin-bottom: 10px;
    }
    .support-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .support-actions a {
      flex: 1 1 140px;
      text-align: center;
      text-decoration: none;
    }
    textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #f9fafb;
      font-size: 0.9rem;
      resize: vertical;
      min-height: 80px;
    }
    .rating-stars {
      display: flex;
      gap: 6px;
    }
    .rating-stars button {
      flex: 1 1 auto;
      border: 1px solid rgba(248,250,252,0.3);
      background: rgba(15,23,42,0.9);
      color: #fcd34d;
      font-size: 1.2rem;
      border-radius: 10px;
      padding: 8px 0;
      cursor: pointer;
    }
    .rating-stars button.active {
      background: #fcd34d;
      color: #1f2937;
    }
    .tip-options {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .tip-button {
      flex: 1 1 80px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.9);
      color: #e5e7eb;
      padding: 8px 0;
      cursor: pointer;
    }
    .tip-button.active {
      background: #22c55e;
      color: #022c22;
      border-color: #22c55e;
    }
    #tipCustomInput,
    #rideTipCustomInput {
      margin-top: 6px;
      display: none;
    }
    .tip-adjust-card {
      margin-top: 16px;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.7);
    }
    .tip-adjust-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
    }
    .tip-adjust-row input {
      width: 90px;
      padding: 6px;
      text-align: center;
    }
    .tip-adjust-row button {
      flex: 1 1 auto;
    }
    .tip-hint {
      font-size: 12px;
      color: rgba(226,232,240,0.85);
      margin-top: 4px;
    }
    .hidden {
      display: none !important;
    }
    .ride-view-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    .ride-view-tab {
      flex: 1 1 120px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.85);
      color: #e2e8f0;
      padding: 8px 12px;
      font-size: 0.9rem;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s ease;
    }
    .ride-view-tab:hover:not(.active) {
      border-color: rgba(248,250,252,0.6);
      color: #f8fafc;
    }
    .ride-view-tab.active {
      background: #f97316;
      border-color: #f97316;
      color: #0f172a;
      font-weight: 600;
      box-shadow: 0 4px 16px rgba(249,115,22,0.35);
    }
    .ride-view-panel {
      display: none;
    }
    .ride-view-panel.active {
      display: block;
    }
    .pwa-install-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .pwa-install-overlay.hidden {
      display: none;
    }
    .pwa-install-card {
      max-width: 420px;
      width: 90%;
      background: #0b1930;
      color: #ffffff;
      border-radius: 12px;
      padding: 20px 24px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .pwa-install-card h2 {
      margin-top: 0;
      margin-bottom: 8px;
    }
    .pwa-install-card p {
      margin-bottom: 12px;
    }
    .pwa-instructions {
      font-size: 0.9rem;
      margin-bottom: 16px;
    }
    .pwa-instructions ol {
      padding-left: 18px;
    }
    .pwa-install-card .btn-primary {
      display: inline-block;
      width: auto;
      padding: 8px 16px;
      border-radius: 999px;
      border: none;
      background: #34c759;
      color: #000;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 8px;
    }
    .pwa-install-card .btn-secondary {
      display: inline-block;
      width: auto;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid #ffffff55;
      background: transparent;
      color: #ffffff;
      cursor: pointer;
    }
    .pwa-install-card .btn-primary:disabled {
      opacity: 0.6;
      cursor: default;
    }
  </style>
</head>
<body id="appRoot" class="landing-active">
  <div
    id="mainLandingPage"
    class="main-landing home-screen active"
    role="region"
    aria-label="RideSync mode selection"
    aria-hidden="false"
  >
    <button id="landingSyncRider" type="button" class="landing-button">
      Sync Rider
    </button>
    <div class="main-landing-wordmark" aria-label="RideSync">
      <span class="brand-accent">Ride</span>
      <span>Sync</span>
    </div>
    <button id="landingSyncDriver" type="button" class="landing-button landing-button-secondary">
      Sync Driver (Coming Soon)
    </button>
    <p class="landing-copyright">
      &copy; 2025 RideSync. All rights reserved.
    </p>
  </div>
  <div id="map"></div>
  <div class="card">
    <!-- AUTH VIEW -->
    <div id="authView" class="active">
      <h1>RideSync</h1>
      <p class="subtitle">NWA • U of A • Private rides made simple</p>

      <div class="toggle-auth">
        <span id="toggleLink">New here? Create account</span>
      </div>

      <div id="authError" class="error"></div>

      <label for="email">Email</label>
      <input id="email" type="email" placeholder="you@example.com" autocomplete="email" />

      <label for="password">Password</label>
      <input id="password" type="password" placeholder="••••••••" autocomplete="current-password" />

      <!-- SIGNUP FIELDS -->
      <div id="signupFields" style="display:none;">
        <div class="section-title">Rider info</div>
        <label for="fullName">Full name</label>
        <input id="fullName" type="text" placeholder="Your legal name" />

        <div class="row">
          <div>
            <label for="gender">Gender</label>
            <select id="gender">
              <option value="">Select…</option>
              <option value="male">Male</option>
              <option value="female">Female</option>
              <option value="other">Other / Prefer not</option>
            </select>
          </div>
          <div>
            <label for="phoneNumber">Phone</label>
            <input id="phoneNumber" type="tel" placeholder="555-123-4567" />
          </div>
        </div>

        <div class="section-title">Address</div>
        <label for="streetAddress">Street</label>
        <input id="streetAddress" type="text" placeholder="123 Main St" />

        <div class="row">
          <div>
            <label for="city">City</label>
            <input id="city" type="text" placeholder="Fayetteville" />
          </div>
          <div>
            <label for="state">State</label>
            <input id="state" type="text" placeholder="AR" />
          </div>
          <div>
            <label for="zip">ZIP</label>
            <input id="zip" type="text" placeholder="72701" />
          </div>
        </div>

        <div class="section-title">Student & membership</div>
        <div class="row">
          <div>
            <label for="isStudent">U of A student?</label>
            <select id="isStudent">
              <option value="false">No</option>
              <option value="true">Yes</option>
            </select>
          </div>
          <div>
            <label for="membership">Membership</label>
            <select id="membership">
              <option value="basic">BASIC (default) — pay per ride</option>
              <option value="uofa_unlimited">U OF A STUDENT — UNLIMITED ($80/mo)</option>
              <option value="nwa_unlimited">NORTHWEST ARKANSAS — UNLIMITED ($120/mo)</option>
            </select>
          </div>
        </div>

        <div class="section-title">Photos (never public)</div>
        <label>Profile picture</label>
        <input id="profilePicInput" type="file" accept="image/*" />
      </div>

      <button id="authButton" class="btn-primary">Log in</button>
      <p class="small">When creating an account, all info on this screen saves at once.</p>
    </div>

    <!-- RIDE VIEW -->
    <div id="rideView">
      <div class="ride-view-tabs" role="tablist" aria-label="Rider sections">
        <button
          type="button"
          id="rideViewTabDestination"
          class="ride-view-tab active"
          data-view-tab="destination"
          aria-controls="rideViewPanelDestination"
          aria-selected="true"
          tabindex="0"
        >
          Destination
        </button>
        <button
          type="button"
          id="rideViewTabMembership"
          class="ride-view-tab"
          data-view-tab="membership"
          aria-controls="rideViewPanelMembership"
          aria-selected="false"
          tabindex="-1"
        >
          Membership
        </button>
        <button
          type="button"
          id="rideViewTabInfo"
          class="ride-view-tab"
          data-view-tab="info"
          aria-controls="rideViewPanelInfo"
          aria-selected="false"
          tabindex="-1"
        >
          Rider info
        </button>
      </div>

      <div id="profileMessage" class="success"></div>
      <div id="profileError" class="error"></div>

      <div
        class="ride-view-panel active"
        id="rideViewPanelDestination"
        data-view-panel="destination"
        role="tabpanel"
        aria-labelledby="rideViewTabDestination"
        aria-hidden="false"
      >
      <!-- Join banner for QR joiners -->
      <div id="joinBanner" class="fare-box" style="display:none;">
        <div class="small" id="joinBannerText"></div>
      </div>

      <div class="section-title">Trip setup</div>
      <div class="small" style="margin: -4px 0 12px; color: #94a3b8;">
        Check out our memberships to save on frequent rides.
      </div>
      <div class="fare-box trip-builder-card">
        <div class="trip-builder-fields">
          <div class="trip-field">
            <label for="destination">Where are you going?</label>
            <div class="destination-input-row">
              <input id="destination" type="text" placeholder="Enter destination address" />
              <button
                id="addStopButton"
                type="button"
                class="add-stop-button"
                aria-label="Add an extra stop"
                title="Add an extra stop"
              >
                +
              </button>
            </div>
            <div class="small extra-stop-hint">
              Need multiple stops? Tap + to add them before syncing your destination.
            </div>
            <div id="extraStopsContainer" class="extra-stops"></div>
            <div id="pickupOverrideField" class="trip-field" style="display:none;">
              <label for="pickupOverrideInput">Pickup location</label>
              <input
                id="pickupOverrideInput"
                type="text"
                placeholder="Enter pickup address if location access is off"
                autocomplete="street-address"
              />
              <div id="pickupOverrideHint" class="small">
                Turn on location services or type where to meet your driver.
              </div>
              <div id="pickupOverrideError" class="error"></div>
            </div>
          </div>
          <div id="ridersSection" class="trip-field">
            <label for="numRiders">Number of riders</label>
            <select id="numRiders">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
            <div class="small">
              For U of A pooling, choose 1 rider. For private group rides with friends, choose 2–4 and use the QR.
            </div>
            <button
              id="syncRidersButton"
              type="button"
              class="btn-secondary btn-small sync-riders-button sync-qr-trigger"
              style="display:none;"
              aria-haspopup="dialog"
              aria-controls="syncRidersOverlay"
            >
              Sync QR
            </button>
          </div>
          <div
            id="groupQrSection"
            class="trip-field group-qr-section"
            aria-live="polite"
            aria-expanded="false"
          >
            <div class="small" id="groupQrIntro">
              Tap Sync QR to open the overlay and share the code with friends. We'll track how many riders have joined below.
            </div>
            <div
              id="groupQrPendingMessage"
              class="small"
              style="margin-top:6px; display:none;"
            ></div>
            <canvas
              id="groupQrCanvas"
              width="140"
              height="140"
              style="margin-top:8px; display:none;"
            ></canvas>
            <div
              id="groupOccupancyLabel"
              class="small"
              style="margin-top:6px; display:none;"
            ></div>
          </div>
        </div>
        <div id="tripMapPreview" class="trip-map-preview" aria-hidden="true">
          <div id="destinationPreviewMap" class="trip-map-canvas"></div>
          <div id="destinationPreviewEmpty" class="map-empty-state">
            Add a destination to preview your pickup &amp; dropoff pins.
          </div>
        </div>
      </div>

      <div class="section-title" id="poolGroupTitle" style="display:none;">
        U of A pool group
      </div>
      <div id="poolGroupBox" class="fare-box" style="display:none;">
        <div class="small" id="poolGroupStatus">
          Searching for other U of A riders…
        </div>
        <div id="poolGroupList"></div>
      </div>

      <div class="fare-box rider-action-box">
        <div class="rider-action-header">Account &amp; ride actions</div>
        <div class="rider-action-buttons">
          <button id="syncButton" class="btn-primary">Sync destination</button>
          <button id="logoutButton" class="btn-secondary">Log out</button>
        </div>
        <div id="driverAvailabilityNotice" class="small"></div>
      </div>
      <div
        id="guestContributionCard"
        class="fare-box guest-contribution-card"
        style="display:none;"
        aria-live="polite"
      >
        <div class="guest-contribution-header">
          <div>
            <div class="section-title" style="margin:0;border:none;padding:0;">
              Pitch in for this ride
            </div>
            <p id="guestContributionHint" class="small" style="margin-top:2px;">
              Your host enabled Guest Sync. Skip the account screen and enter your share below.
            </p>
          </div>
          <span class="badge badge-basic" style="font-size:0.7rem;">Guest</span>
        </div>
        <label for="guestShareInput">Share the fare</label>
        <div class="guest-contribution-row">
          <span class="currency-prefix">$</span>
          <input
            id="guestShareInput"
            type="number"
            inputmode="decimal"
            min="0"
            step="1"
            placeholder="15"
            aria-label="Contribution amount in dollars"
          />
          <button id="guestShareButton" type="button" class="btn-secondary btn-small">
            Add
          </button>
        </div>
        <label for="guestTipInput">Tip at dropoff</label>
        <div class="guest-contribution-row">
          <span class="currency-prefix">$</span>
          <input
            id="guestTipInput"
            type="number"
            inputmode="decimal"
            min="0"
            step="1"
            placeholder="5"
            aria-label="Tip amount in dollars"
          />
          <button id="guestTipButton" type="button" class="btn-secondary btn-small">
            Save
          </button>
        </div>
        <div id="guestContributionSummary" class="guest-contribution-summary"></div>
      </div>
      </div>

      <div
        class="ride-view-panel"
        id="rideViewPanelMembership"
        data-view-panel="membership"
        role="tabpanel"
        aria-labelledby="rideViewTabMembership"
        aria-hidden="true"
      >
        <div id="membershipCard" class="membership-card">
          <div class="membership-card-header">
            <div>
              <div
                class="section-title"
                style="margin-top:0;border-top:none;padding-top:0;"
              >
                Membership
              </div>
              <p id="membershipStatusText" class="membership-subtitle">
                Loading membership…
              </p>
            </div>
            <span id="membershipStatusBadge" class="membership-status-badge">—</span>
          </div>
          <div class="membership-card-summary">
            <p id="membershipCurrentLabel" class="membership-subtitle">
              Checking membership...
            </p>
            <p class="membership-subtitle membership-info-note">
              Membership savings are bundled with your fare and tip. Contact RideSync support if you need to change plans.
            </p>
          </div>
          <div id="membershipPlanGrid" class="membership-plan-grid">
            <div class="membership-plan" data-plan="uofa_unlimited">
              <div class="membership-plan-title">U OF A STUDENT — UNLIMITED</div>
              <div
                class="membership-plan-price"
                data-plan-price="uofa_unlimited"
              >
                $80 / month
              </div>
              <p class="membership-plan-desc">
                Unlimited Fayetteville rides with a 30-min cooldown (60 during surge). Only pay the tip after each trip.
              </p>
              <p
                class="membership-plan-desc membership-plan-hint"
                data-plan-hint="uofa_unlimited"
              ></p>
              <p class="membership-plan-desc membership-plan-note">
                Coming soon.
              </p>
            </div>
            <div class="membership-plan" data-plan="nwa_unlimited">
              <div class="membership-plan-title">NORTHWEST ARKANSAS — UNLIMITED</div>
              <div
                class="membership-plan-price"
                data-plan-price="nwa_unlimited"
              >
                $120 / month
              </div>
              <p class="membership-plan-desc">
                Unlimited rides within a 30-mile radius of Rogers with tips handled separately at checkout.
              </p>
              <p
                class="membership-plan-desc membership-plan-hint"
                data-plan-hint="nwa_unlimited"
              ></p>
              <p class="membership-plan-desc membership-plan-note">
                Coming soon.
              </p>
            </div>
          </div>
          <div id="membershipCardMessage" class="small">
            Membership charges are included with your fare payment.
          </div>
        </div>
      </div>

      <div
        class="ride-view-panel"
        id="rideViewPanelInfo"
        data-view-panel="info"
        role="tabpanel"
        aria-labelledby="rideViewTabInfo"
        aria-hidden="true"
      >
      <div id="riderInfoCard" class="rider-info-card">
        <div class="rider-info-main">
          <div id="avatar" class="rider-avatar">RS</div>
          <div class="rider-info-text">
            <div class="rider-name" id="riderName">Rider</div>
            <div id="membershipBadge" class="badge badge-basic">
              <span id="membershipBadgeLabel">Basic</span>
              <span class="badge-tag" id="membershipBadgeTag"></span>
            </div>
          </div>
        </div>

        <div class="rider-info-grid">
          <div class="rider-info-field">
            <div class="rider-info-label">Email</div>
            <div class="rider-info-value" id="riderEmailDetail">you@example.com</div>
          </div>
          <div class="rider-info-field">
            <div class="rider-info-label">Phone</div>
            <div class="rider-info-value" id="riderPhoneDetail"></div>
          </div>
          <div class="rider-info-field">
            <div class="rider-info-label">Address</div>
            <div class="rider-info-value" id="riderAddressDetail"></div>
          </div>
          <div class="rider-info-field">
            <div class="rider-info-label">Membership</div>
            <div class="rider-info-value" id="riderMembershipDetail"></div>
          </div>
        </div>

        <div class="rider-info-actions">
          <button
            id="editProfileButton"
            type="button"
            class="btn-secondary btn-small"
          >
            Edit profile
          </button>
        </div>
      </div>

      <!-- Inline edit form -->
      <div id="editProfileSection"
           class="fare-box"
           style="display:none; margin-top:6px;">
        <div class="row">
          <div>
            <label for="editFullName">Name</label>
            <input id="editFullName" type="text" />
          </div>
          <div>
            <label for="editPhone">Phone</label>
            <input id="editPhone" type="tel" />
          </div>
          <div>
            <label for="editGender">Gender</label>
            <select id="editGender">
              <option value="">Select…</option>
              <option value="male">Male</option>
              <option value="female">Female</option>
              <option value="other">Other / Prefer not</option>
            </select>
          </div>
        </div>

        <label for="editStreet">Street</label>
        <input id="editStreet" type="text" />

        <div class="row">
          <div>
            <label for="editCity">City</label>
            <input id="editCity" type="text" />
          </div>
          <div>
            <label for="editState">State</label>
            <input id="editState" type="text" />
          </div>
          <div>
            <label for="editZip">ZIP</label>
            <input id="editZip" type="text" />
          </div>
        </div>

        <div class="section-title">Photos</div>
        <label>Profile picture</label>
        <input id="editProfilePicInput" type="file" accept="image/*" />

        <button id="saveProfileButton" type="button"
                class="btn-primary btn-small"
                style="margin-top:8px;">
          Save changes
        </button>
      </div>

      </div>
    </div>

    <!-- LOADING VIEW -->
      <div id="loadingView">
        <h2>RideSync</h2>
        <div class="loading-center">
          <div class="loading-spinner"></div>
          <div>Syncing your ride…</div>
          <div class="small">Pre-authorizing payment and matching your driver.</div>
        </div>
      </div>

      <!-- RIDE SUMMARY (after ride completes) -->
      <div id="rideSummary" style="display:none; color:#e5e7eb; padding:16px 4px; text-align:center;">
        <h2 style="margin-bottom:8px;">Ride complete</h2>
        <div id="rideSummaryText" style="font-size:0.85rem; line-height:1.4;"></div>
      </div>

      <!-- RIDER ACTIVE RIDE OVERLAY -->
      <div id="riderOverlay" class="overlay">
        <div class="rider-overlay-shell">
          <div class="overlay-header">
            <div>
              <div id="riderOverlayTitle" class="overlay-title">RideSync</div>
              <div id="riderOverlaySubtitle" class="overlay-subtitle"></div>
            </div>
          </div>

          <div id="riderStateSearching" class="rider-state">
            <div class="loading-spinner"></div>
            <div class="state-text">Looking for a driver…</div>
            <div class="state-subtext">We’re syncing you with a nearby verified driver.</div>
            <div
              id="riderWaitlistPanel"
              class="waitlist-panel"
              aria-live="polite"
              aria-hidden="true"
            >
              <div class="waitlist-title">
                <span class="waitlist-indicator-dot" aria-hidden="true"></span>
                Holding your place in line
              </div>
              <div id="riderWaitlistStatus" class="waitlist-status">
                All drivers are currently finishing trips nearby.
              </div>
              <div class="waitlist-meta">
                <div id="riderWaitlistBadge" class="waitlist-pill"></div>
                <div class="waitlist-timer-block">
                  <div class="waitlist-timer-label">Driver ETA</div>
                  <div id="riderWaitlistTimer" class="waitlist-timer-value">--:--</div>
                </div>
              </div>
            </div>
          </div>

          <div id="riderStateDriverEta" class="rider-state">
            <div class="state-text">Driver accepted</div>
            <div class="state-subtext">Track their ETA and vehicle details below.</div>
            <div class="driver-info-slot" data-slot="driver"></div>
          </div>

          <div id="riderStatePickupPin" class="rider-state">
            <div class="state-text">Share your pickup code</div>
            <div class="pin-card">
              <div class="pin-label">Tell your driver this code when they arrive</div>
              <div id="riderPickupPinValue" class="pin-value">----</div>
              <div class="pin-hint">We use codes so only verified rides start.</div>
            </div>
          </div>

          <div id="riderStateInTrip" class="rider-state">
            <div class="state-text">On the way</div>
            <div id="riderTripEtaText" class="state-subtext"></div>
            <div class="driver-info-slot" data-slot="driver"></div>
          </div>

          <div id="riderStateDropoffPin" class="rider-state">
            <div class="state-text">Almost there</div>
            <div class="pin-card">
              <div class="pin-label">Share this code at dropoff</div>
              <div id="riderDropoffPinValue" class="pin-value">----</div>
              <div class="pin-hint">Your driver enters this to finish the ride.</div>
            </div>
          </div>

          <div id="riderStateRateTip" class="rider-state">
            <div class="state-text">Rate your ride</div>
            <div id="ratingStars" class="rating-stars">
              <button type="button" data-rating="1">★</button>
              <button type="button" data-rating="2">★</button>
              <button type="button" data-rating="3">★</button>
              <button type="button" data-rating="4">★</button>
              <button type="button" data-rating="5">★</button>
            </div>
            <textarea id="riderFeedbackInput" placeholder="Anything we should know?"></textarea>
            <button id="submitRatingButton" class="btn-primary" type="button">Submit</button>
            <div id="ratingError" class="error"></div>
          <div id="finalTipSection" class="tip-adjust-card" style="display:none;">
            <div class="section-title" style="margin-top:0;">Adjust your tip</div>
            <div class="tip-adjust-row">
              <button id="finalTipDecrease" type="button" class="btn-secondary btn-small" aria-label="Decrease tip">
                –
              </button>
              <input
                id="finalTipInput"
                type="number"
                min="0"
                step="1"
                value="0"
                aria-label="Tip amount in dollars"
              />
              <button id="finalTipIncrease" type="button" class="btn-secondary btn-small" aria-label="Increase tip">
                +
              </button>
            </div>
            <p id="finalTipHint" class="tip-hint">
              Tips are optional. Increase it if you'd like before we finish payment.
            </p>
            <button id="finalizeTipButton" class="btn-primary" type="button" style="margin-top:12px;">
              Confirm tip & finish payment
            </button>
            <div id="finalizeTipMessage" class="small"></div>
          </div>
          </div>

          <div id="riderStateThanks" class="rider-state">
            <div class="state-text">Thank you for riding with RideSync!</div>
            <div class="state-subtext">You’re all set. Request another ride anytime.</div>
          </div>

          <div id="driverInfoStack" class="driver-info-stack">
            <div id="driverIdentityCard" class="driver-identity-card">
              <div class="driver-identity-header">
                <div class="driver-identity-avatar">
                  <img id="driverIdentityAvatarImg" alt="Driver avatar" />
                  <div id="driverIdentityAvatarFallback" class="avatar-fallback">RS</div>
                </div>
                <div class="driver-identity-meta">
                  <div class="driver-identity-name-row">
                    <div id="driverIdentityName" class="driver-identity-name">RideSync driver</div>
                    <div id="driverIdentityRating" class="driver-rating-pill"></div>
                  </div>
                  <div id="driverIdentityStatus" class="driver-identity-status"></div>
                  <div id="driverIdentityPhoneRow" class="driver-identity-phone">
                    <span id="driverIdentityPhone"></span>
                  </div>
                </div>
              </div>
              <div id="driverIdentityBadges" class="driver-identity-badges"></div>
              <div id="driverIdentityEta" class="driver-identity-eta"></div>
              <div id="driverMiniMapShell" class="driver-mini-map-shell">
                <div id="driverMiniMap" class="driver-mini-map"></div>
                <div id="driverMiniMapStatus" class="driver-mini-map-status">
                  Waiting for driver location…
                </div>
              </div>
            </div>

            <div
              id="rideChatCard"
              class="ride-chat-card"
              style="display:none;"
            >
              <div class="ride-chat-header">
                <div class="ride-chat-title">Chat with your driver</div>
                <div id="rideChatOfflineNote" class="ride-chat-note">
                  Chat is available only while the ride is active.
                </div>
              </div>
              <div
                id="rideChatMessages"
                class="ride-chat-messages"
                role="log"
                aria-live="polite"
              ></div>
              <div class="ride-chat-input-row">
                <input
                  id="rideChatInput"
                  class="ride-chat-input"
                  type="text"
                  inputmode="text"
                  maxlength="500"
                  autocomplete="off"
                  placeholder="Type a message…"
                  aria-label="Message your driver"
                />
                <button
                  id="rideChatSendButton"
                  type="button"
                  class="ride-chat-send btn-primary btn-small"
                >
                  Send
                </button>
              </div>
            </div>

            <div id="driverVehicleSection" class="driver-vehicle-card">
              <div class="section-title" style="margin-top:0;">Vehicle</div>
              <div class="driver-vehicle-body">
                <div class="driver-vehicle-photo">
                  <img id="driverVehiclePhoto" alt="Driver vehicle" />
                  <div id="driverVehicleFallback" class="avatar-fallback">RS</div>
                </div>
                <div class="driver-vehicle-details">
                  <div id="driverVehicleName" class="driver-vehicle-name"></div>
                  <div id="driverVehiclePlate"></div>
                  <div id="driverVehicleNote" class="driver-license-meta"></div>
                </div>
              </div>
            </div>

            <div id="driverLicenseSection" class="driver-license-card">
              <div class="section-title" style="margin-top:0;">License &amp; verification</div>
              <div class="driver-license-body">
                <div class="driver-license-photo">
                  <img id="driverLicensePhoto" alt="Driver license" />
                  <div id="driverLicenseFallback" class="avatar-fallback">ID</div>
                </div>
                <div class="driver-license-details">
                  <div id="driverLicenseSummary" class="driver-license-summary"></div>
                  <div id="driverLicenseMeta" class="driver-license-meta"></div>
                </div>
              </div>
            </div>

            <button id="contactDriverBtn" type="button" class="btn-secondary" style="margin-top:8px;">
              Support
            </button>

            <div id="supportPanel" class="support-panel">
              <div class="support-panel-header">
                <div style="font-weight:600;">RideSync support</div>
                <button id="supportBackButton" type="button" class="btn-small btn-secondary">Back</button>
              </div>
              <div class="support-panel-text">
                Choose how you'd like to contact RideSync support.
              </div>
              <div class="support-actions">
                <a id="supportCallButton" class="btn-primary" href="#" role="button">Call support</a>
                <a id="supportTextButton" class="btn-secondary" href="#" role="button">Text support</a>
              </div>
            </div>
          </div>

          <div id="riderOverlayError" class="error"></div>
        </div>
      </div>

        <button id="cancelRideButton" class="btn-secondary" style="margin-top:16px;" hidden>
          Cancel ride
        </button>
        <div id="cancelError" class="error"></div>
      </div>
    </div>
  </div>

  <div id="syncConfirmOverlay" class="payment-overlay" aria-hidden="true">
    <div
      class="payment-panel"
      role="dialog"
      aria-modal="true"
      aria-labelledby="syncConfirmTitle"
    >
      <div class="payment-panel-header">
        <div>
          <h3 id="syncConfirmTitle" class="payment-panel-title">
            Review trip &amp; payment
          </h3>
          <p id="syncConfirmSubtitle" class="payment-panel-subtitle">
            Confirm your fare, tip, and membership before syncing.
          </p>
        </div>
        <button
          id="syncConfirmClose"
          type="button"
          class="btn-secondary btn-small"
        >
          Close
        </button>
      </div>

      <div class="fare-box" id="syncConfirmFareBox">
        <div class="fare-row">
          <div class="fare-label">Destination</div>
          <div class="fare-value" id="syncConfirmDestination">—</div>
        </div>
        <div class="fare-row">
          <div class="fare-label">Time</div>
          <div class="fare-value" id="syncConfirmTime">—</div>
        </div>
        <div class="fare-row">
          <div class="fare-label">Distance</div>
          <div class="fare-value" id="syncConfirmDistance">—</div>
        </div>
        <div class="fare-row">
          <div class="fare-label">Estimated total</div>
          <div class="fare-total" id="syncConfirmTotal">—</div>
        </div>
      </div>

      <div id="reserveTimeSection" class="fare-section">
        <label class="field-label">Reserve pickup time</label>
        <div class="reserve-mode-options">
          <label class="reserve-mode-option">
            <input
              type="radio"
              name="reserveMode"
              value="asap"
              id="reserveModeAsap"
              checked
            />
            <span>ASAP (no reservation)</span>
          </label>
          <label class="reserve-mode-option">
            <input
              type="radio"
              name="reserveMode"
              value="schedule"
              id="reserveModeSchedule"
            />
            <span>Schedule pickup (+$5)</span>
          </label>
        </div>
        <div id="reserveDateTimeRow" class="reserve-datetime-row">
          <div class="reserve-datetime-field">
            <label for="reserveDateInput">Date</label>
            <input id="reserveDateInput" type="date" />
          </div>
          <div class="reserve-datetime-field">
            <label for="reserveTimeInput">Pickup time</label>
            <input id="reserveTimeInput" type="time" step="900" />
          </div>
        </div>
        <p id="reserveTimeHint" class="small">
          Scheduling a pickup adds a $5 reserve fee.
        </p>
      </div>

      <div id="referralCodeSection" class="fare-section">
        <label for="referralCodeInput" class="field-label">
          Referral code (optional)
        </label>
        <div class="inline-input-row">
          <input
            id="referralCodeInput"
            type="text"
            class="text-input"
            autocomplete="off"
            placeholder="Enter referral code"
          />
          <button
            id="applyReferralCodeButton"
            type="button"
            class="btn-secondary btn-small"
          >
            Apply
          </button>
        </div>
        <p id="referralCodeMessage" class="small" aria-live="polite"></p>
      </div>

      <div id="discountCodeSection" class="fare-section">
        <label for="discountCodeInput" class="field-label">
          Discount code (optional)
        </label>
        <div class="inline-input-row">
          <input
            id="discountCodeInput"
            type="text"
            class="text-input"
            autocomplete="off"
            placeholder="Enter discount code"
          />
          <button
            id="applyDiscountCodeButton"
            type="button"
            class="btn-secondary btn-small"
          >
            Apply
          </button>
        </div>
        <p id="discountCodeMessage" class="small" aria-live="polite"></p>
      </div>

      <div class="section-title" style="margin-top:12px;">Tip your driver</div>
      <div id="syncTipOptions" class="tip-options">
        <button class="tip-button" type="button" data-tip="0">No tip</button>
        <button class="tip-button" type="button" data-tip="2">$2</button>
        <button class="tip-button" type="button" data-tip="5">$5</button>
        <button class="tip-button" type="button" data-tip="10">$10</button>
        <button class="tip-button tip-custom" type="button" data-tip="custom">
          Custom
        </button>
      </div>
      <input
        id="syncTipCustomInput"
        type="number"
        min="0"
        step="1"
        placeholder="Custom tip"
        style="display:none;"
      />
      <p id="syncTipMessage" class="sync-tip-note">
        Tips go directly to your driver and are charged with your fare.
      </p>

      <div class="section-title" style="margin-top:18px;">Membership</div>
      <div id="syncMembershipList" class="sync-membership-list"></div>
      <div id="syncMembershipHint" class="small"></div>

      <div id="syncMembershipTermsContainer" style="display:none;">
        <div class="section-title" style="margin-top:10px;">Membership terms</div>
        <div class="membership-terms-content" id="syncMembershipTermsContent">
          <p><strong>Effective Date:</strong> January 1st</p>
          <p><strong>Customer Name:</strong> <span id="syncMembershipTermsCustomerName">RideSync Member</span></p>
          <p><strong>Membership Type:</strong> <span id="syncMembershipTermsPlanLabel">—</span></p>

          <h3>1. General Membership Rules</h3>
          <p>All customers must have at minimum a Basic Membership to request rides. Your profile information (name, phone, license, student ID, or employer verification) must remain accurate and up to date at all times.</p>
          <p><strong>Auto-Renewal:</strong> All paid memberships renew every 30 days. If you do not cancel at least 3 days before renewal, you will be charged automatically. No exceptions. Failure to cancel on time is your responsibility.</p>
          <p><strong>No Refund Policy:</strong> Once billed, the membership payment is non-refundable. Canceling early does not result in a prorated refund.</p>
          <p><strong>Bug / Error Reporting:</strong> If you find ANY bug, exploit, or system issue, you MUST report it immediately. Failure to report issues, intentionally exploiting bugs, or sharing them with others will result in immediate membership cancellation without refund. RideSync may pursue legal action for damages or abuse.</p>
          <p><strong>Geofence Requirements:</strong> All unlimited rides must remain inside the official RideSync geofence. Leaving the geofence intentionally is a violation of this Agreement and may result in cancellation without refund.</p>

          <hr>

          <h3>2. U of A Unlimited Membership</h3>
          <p>Eligibility requires an active U of A student ID that RideSync can verify at any time.</p>
          <p><strong>Unlimited Rides Policy:</strong> Unlimited rides apply only inside the U of A service geofence. You cannot bring additional riders under your unlimited plan unless:</p>
          <ul>
            <li>They pay the normal Basic fare, OR</li>
            <li>They also upgrade to their own unlimited membership.</li>
          </ul>
          <p>Sharing or attempting to share your membership results in immediate cancellation without refund and may include legal action for fraudulent use.</p>
          <p><strong>Coverage Area:</strong> If your pickup or destination is outside the U of A zone, the ride converts into a Basic priced ride.</p>

          <hr>

          <h3>3. Northwest Arkansas Work Pass – Unlimited</h3>
          <p>The Work Pass is NOT general unlimited transportation. It is ONLY for commuting to and from work within a 30-mile radius.</p>
          <p><strong>Work-Only Travel:</strong> You receive one ride to work and one ride home each day, at no additional cost.</p>
          <p>You cannot use the Work Pass for personal trips, store runs, entertainment, visiting friends, or any non-work purpose. Misuse results in cancellation without refund.</p>
          <p><strong>Additional Riders:</strong> Only YOU are covered. Additional riders must pay Basic fare or have their own unlimited membership.</p>

          <hr>

          <h3>4. Behavior, Conduct, and Safety</h3>
          <p>Any harassment, threats, unsafe behavior, intoxication, or abusive conduct may result in immediate suspension or permanent ban without refund.</p>
          <p>You agree that all personal information you provide is accurate. If false data is discovered, RideSync may cancel your membership without refund.</p>

          <hr>

          <h3>5. Acceptance of Agreement</h3>
          <p>By checking the box below and continuing to checkout, you agree:</p>
          <ul>
            <li>You understand and accept all terms above</li>
            <li>You authorize RideSync to automatically bill your payment method</li>
            <li>You acknowledge geofence and usage limitations</li>
            <li>You understand that violating terms may result in cancellation without refund</li>
          </ul>
        </div>
        <div class="membership-terms-footer">
          <label>
            <input type="checkbox" id="syncMembershipTermsCheckbox" />
            I have read and agree to the RideSync Membership Terms &amp; Conditions.
          </label>
        </div>
      </div>

      <div id="syncConfirmError" class="error"></div>
      <button
        id="syncConfirmButton"
        type="button"
        class="btn-primary"
        data-default-focus="true"
      >
        Sync &amp; pay
      </button>
      <button id="syncConfirmCancel" type="button" class="btn-secondary">
        Go back
      </button>
    </div>
  </div>

  <div id="paymentOverlay" class="payment-overlay" aria-hidden="true">
    <div class="payment-panel">
      <div class="payment-panel-header">
        <div>
          <h3 id="paymentOverlayTitle" class="payment-panel-title">
            Complete payment
          </h3>
          <p id="paymentOverlaySubtitle" class="payment-panel-subtitle"></p>
        </div>
        <button
          id="paymentOverlayClose"
          type="button"
          class="btn-secondary btn-small"
        >
          Cancel
        </button>
      </div>
      <div id="paymentFareSummary" class="payment-fare-summary" aria-live="polite">
        <div class="section-title" style="margin-bottom:4px;">Fare summary</div>
        <div class="fare-box" style="margin-bottom:0;">
          <div id="fareNotReady" class="small">
            Choose your destination first to calculate time, distance, and total.
          </div>
          <div id="fareReady" style="display:none;">
            <div class="fare-row">
              <div class="fare-label">Time</div>
              <div class="fare-value" id="fareTime"></div>
            </div>
            <div class="fare-row">
              <div class="fare-label">Distance</div>
              <div class="fare-value" id="fareDistance"></div>
            </div>
            <div class="fare-row">
              <div class="fare-label">Plan</div>
              <div class="fare-value" id="fareMembership"></div>
            </div>
            <div class="fare-row">
              <div class="fare-label">Total (incl. fees)</div>
              <div class="fare-total" id="fareTotal"></div>
            </div>
            <div id="fareExtraStops" class="fare-extra-stops"></div>
          </div>
        </div>
      </div>
      <div id="preauthTipSection" class="payment-tip-section" aria-live="polite">
        <div class="section-title" style="margin-top:18px;">
          Add a tip (charged now, optional)
        </div>
        <div id="preauthTipOptions" class="tip-options">
          <button type="button" class="tip-button" data-tip="0">No tip</button>
          <button type="button" class="tip-button" data-tip="2">$2</button>
          <button type="button" class="tip-button" data-tip="5">$5</button>
          <button type="button" class="tip-button" data-tip="10">$10</button>
          <button type="button" class="tip-button tip-custom" data-tip="custom">
            Custom
          </button>
        </div>
        <input
          id="preauthTipCustomInput"
          type="number"
          min="0"
          step="1"
          placeholder="Custom tip"
          style="display:none;"
        />
        <p id="preauthTipMessage" class="tip-hint">
          Tips are optional. If you add one, we'll charge it now with your fare.
        </p>
      </div>
      <div class="fare-box" id="preauthHoldSummary" style="margin-top:12px;">
        <div class="fare-row">
          <div class="fare-label">Total charge</div>
          <div class="fare-value" id="preauthHoldAmount">$0.00</div>
        </div>
      </div>
      <div id="paymentElement"></div>
      <button
        id="paymentOverlayConfirm"
        type="button"
        class="btn-primary"
      >
        Pay now
      </button>
      <div id="paymentOverlayMessage" class="error"></div>
    </div>
  </div>

  <div id="paymentRedirectOverlay" class="payment-overlay" aria-hidden="true">
    <div class="payment-panel compact" role="dialog" aria-live="assertive">
      <div class="payment-redirect-icon" aria-hidden="true">🔒</div>
      <h3 class="payment-panel-title">Secure payment</h3>
      <p id="paymentRedirectSubtitle" class="payment-redirect-subtitle">
        Redirecting you to Stripe Checkout…
      </p>
      <div class="payment-redirect-spinner" aria-hidden="true"></div>
    </div>
  </div>

  <div
    id="paymentStatusOverlay"
    class="overlay payment-status-overlay"
    aria-hidden="true"
  >
    <div
      class="payment-result-card"
      role="dialog"
      aria-modal="true"
      aria-live="polite"
    >
      <div id="paymentStatusTitle" class="overlay-title"></div>
      <div id="paymentStatusMessage" class="overlay-subtitle"></div>
      <button id="paymentStatusBackButton" type="button" class="btn-primary">
        Back to RideSync
      </button>
    </div>
  </div>

  <div
    id="rideFareOverlay"
    class="payment-overlay"
    aria-hidden="true"
    inert
  >
    <div class="payment-panel" role="dialog" aria-modal="true">
      <div class="payment-panel-header">
        <div>
          <h3 class="payment-panel-title">Ride payment required</h3>
          <p id="rideFareSubtitle" class="payment-panel-subtitle">
            Complete your fare to finish this ride.
          </p>
        </div>
        <button
          id="rideFareClose"
          type="button"
          class="btn-secondary btn-small"
          data-default-focus="true"
          disabled
        >
          Close
        </button>
      </div>
      <div class="fare-box" style="margin-bottom:0;">
        <div class="fare-row">
          <div class="fare-label">Base fare</div>
          <div class="fare-value" id="rideFareBaseAmount">$0.00</div>
        </div>
        <div class="fare-row" id="rideFareMembershipRow" style="display:none;">
          <div class="fare-label">Membership</div>
          <div class="fare-value" id="rideFareMembershipLabel">Checking…</div>
        </div>
        <div class="fare-row">
          <div class="fare-label">Tip</div>
          <div class="fare-value" id="rideFareTipAmount">$0.00</div>
        </div>
        <div class="fare-row">
          <div class="fare-label">Total due</div>
          <div class="fare-total" id="rideFareAmount">$0.00</div>
        </div>
        <div id="rideFareDetails" class="ride-fare-details"></div>
        <p id="rideFareMembershipNote" class="small" style="margin-top:6px; display:none;"></p>
      </div>
      <div class="section-title" style="margin-top:18px;">Pay securely</div>
      <p class="small" id="rideCheckoutDetails">
        Stripe Checkout opens in a secure window so you can use any saved payment method.
      </p>
      <button
        id="rideCheckoutButton"
        type="button"
        class="btn-primary"
        disabled
      >
        Continue to Stripe Checkout
      </button>
      <div id="rideCheckoutMessage" class="error"></div>
      <div id="rideFareStatus" class="ride-payment-status"></div>
    </div>
  </div>

  <div
    id="membershipCheckoutOverlay"
    class="payment-overlay"
    aria-hidden="true"
  >
    <div
      class="payment-panel"
      role="dialog"
      aria-modal="true"
      aria-labelledby="membershipCheckoutTitle"
    >
      <div class="payment-panel-header">
        <div>
          <h3 id="membershipCheckoutTitle" class="payment-panel-title">
            Upgrade your membership
          </h3>
          <p id="membershipCheckoutSubtitle" class="payment-panel-subtitle">
            Compare one-time rides with unlimited plans before heading to Stripe.
          </p>
        </div>
        <button
          id="membershipCheckoutClose"
          type="button"
          class="btn-secondary btn-small"
          data-default-focus="true"
        >
          Close
        </button>
      </div>
      <div
        id="membershipCheckoutOptions"
        class="membership-plan-grid checkout-plans"
        role="radiogroup"
        aria-label="Membership checkout options"
      ></div>
      <div class="fare-box" style="margin-top:12px;">
        <div class="fare-row">
          <div class="fare-label">Selected plan</div>
          <div class="fare-value" id="membershipCheckoutPrice">—</div>
        </div>
        <p id="membershipCheckoutHint" class="small" style="margin-top:6px;"></p>
      </div>
      <div id="membershipCheckoutError" class="error" aria-live="polite"></div>
      <button
        id="membershipCheckoutButton"
        type="button"
        class="btn-primary"
      >
        Checkout with Stripe
      </button>
      <button
        id="membershipCheckoutCancel"
        type="button"
        class="btn-secondary"
      >
        Not now
      </button>
    </div>

  </div>

  <div id="driverComingSoonOverlay" class="overlay" aria-hidden="true">
    <div class="rider-overlay-shell driver-coming-soon-shell" role="dialog" aria-modal="true">
      <div class="overlay-header">
        <div>
          <div class="overlay-title">Driver Dashboard</div>
          <div class="overlay-subtitle">Coming soon</div>
        </div>
        <button id="driverComingSoonClose" type="button" class="overlay-close">
          Close
        </button>
      </div>
      <p class="driver-coming-soon-copy">Driver Dashboard Coming Soon</p>
    </div>
  </div>

  <div
    id="cooldownOverlay"
    class="overlay cooldown-overlay"
    aria-hidden="true"
  >
    <div
      class="cooldown-panel"
      role="dialog"
      aria-modal="true"
      aria-labelledby="cooldownTitle"
      aria-describedby="cooldownHintText"
    >
      <div id="cooldownLabel" class="cooldown-label">Unlimited cooldown</div>
      <div id="cooldownTitle" class="overlay-title">Next ride unlocks soon</div>
      <div id="cooldownSubtitle" class="overlay-subtitle">
        Hang tight while we reset drivers nearby.
      </div>
      <div id="cooldownTimerValue" class="cooldown-timer">00:00</div>
      <div id="cooldownHintText" class="cooldown-hint">
        Unlimited riders take a short break between trips to keep rides fair.
      </div>
      <button id="cooldownDismissButton" type="button" class="btn-primary">
        Okay, got it
      </button>
    </div>
  </div>

  <div id="syncRidersOverlay" class="overlay" aria-hidden="true">
    <div
      class="sync-riders-modal-card"
      role="dialog"
      aria-modal="true"
      aria-labelledby="syncRidersModalTitle"
    >
      <div class="sync-riders-modal-header">
        <div>
          <div class="section-title" style="margin-top:0;">Group ride QR</div>
          <h3 id="syncRidersModalTitle" style="margin:4px 0 0;">Sync Riders</h3>
        </div>
        <button
          id="syncRidersOverlayClose"
          type="button"
          class="btn-secondary btn-small"
        >
          Close
        </button>
      </div>
      <p id="syncRidersModalSubtitle" class="small" style="margin-top:0;">
        Share this code so friends can join your ride after signing in.
      </p>
      <canvas
        id="syncRidersModalCanvas"
        width="220"
        height="220"
        aria-hidden="true"
      ></canvas>
      <div
        id="syncRidersModalOccupancy"
        class="small"
        style="text-align:center; display:none;"
      ></div>
      <div class="sync-riders-modal-actions">
        <button id="syncRidersCopyLink" type="button" class="btn-secondary btn-small">
          Copy share link
        </button>
        <div
          id="syncRidersCopyFeedback"
          class="small sync-riders-copy-feedback"
          aria-live="polite"
        ></div>
      </div>
    </div>
  </div>

  <!-- Membership overlays removed: rider view now provides information only. -->

  <div id="pwaInstallOverlay" class="pwa-install-overlay hidden" aria-hidden="true">
    <div class="pwa-install-card" role="dialog" aria-labelledby="pwaInstallMessage">
      <h2>Install RideSync</h2>
      <p id="pwaInstallMessage">
        Get faster access by installing RideSync on your home screen.
      </p>

      <div id="pwaIosInstructions" class="pwa-instructions hidden">
        <ol>
          <li>Tap the <strong>Share</strong> button in Safari.</li>
          <li>Scroll down and tap <strong>Add to Home Screen</strong>.</li>
          <li>Tap <strong>Add</strong> to install RideSync.</li>
        </ol>
      </div>

      <div id="pwaAndroidInstructions" class="pwa-instructions hidden">
        <p>
          Your browser may show an <strong>Install app</strong> prompt.
          When you see it, tap <strong>Install</strong>.
        </p>
        <button id="pwaInstallButton" type="button" class="btn-primary">
          Install RideSync
        </button>
      </div>

      <button id="pwaInstallDismiss" type="button" class="btn-secondary">
        Maybe later
      </button>
    </div>
  </div>

  <footer class="site-footer" aria-label="Copyright notice">
    <p>&copy; 2025 RideSync. All rights reserved.</p>
  </footer>

  <script type="module">
    import { auth, db } from "@/lib/firebase";
    import {
      onAuthStateChanged,
      signInWithEmailAndPassword,
      createUserWithEmailAndPassword,
      signOut,
      setPersistence,
      browserLocalPersistence,
      browserSessionPersistence,
      indexedDBLocalPersistence
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";
    import {
      doc,
      getDoc,
      collection,
      onSnapshot,
      query,
      where,
      getDocs,
      orderBy,
      limit,
      setDoc,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";
    import {
      getStorage,
      ref,
      uploadBytes,
      getDownloadURL
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-storage.js";
    import {
      getFunctions,
      httpsCallable
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-functions.js";

    const FIREBASE_PROJECT_ID = "ride-sync-nwa";

    async function loadAppConfig() {
      if (window.__rideSyncConfigPromise) {
        return window.__rideSyncConfigPromise;
      }

      window.__rideSyncConfigPromise = fetch("/app-config.json", {
        cache: "no-store"
      })
        .then((res) => {
          if (!res.ok) {
            throw new Error(`Failed to load app config: ${res.status}`);
          }
          return res.json();
        })
        .catch((err) => {
          console.error("App config load failed", err);
          throw err;
        });

      return window.__rideSyncConfigPromise;
    }

    function loadGoogleMapsSdk({ apiKey, libraries = [] } = {}) {
      if (window.__rideSyncMapsPromise) {
        return window.__rideSyncMapsPromise;
      }

      window.__rideSyncMapsPromise = new Promise((resolve, reject) => {
        if (window.google && window.google.maps) {
          resolve(window.google.maps);
          return;
        }

        if (!apiKey) {
          reject(new Error("Missing Google Maps API key"));
          return;
        }

        const params = new URLSearchParams({ key: apiKey });
        if (libraries.length) {
          params.set("libraries", libraries.join(","));
        }

        const script = document.createElement("script");
        script.src = `https://maps.googleapis.com/maps/api/js?${params.toString()}`;
        script.async = true;
        script.defer = true;
        script.onload = () => {
          if (window.google && window.google.maps) {
            resolve(window.google.maps);
          } else {
            reject(new Error("Google Maps SDK loaded without maps namespace."));
          }
        };
        script.onerror = () => reject(new Error("Google Maps SDK failed to load."));
        document.head.appendChild(script);
      }).catch((err) => {
        window.__rideSyncMapsPromise = null;
        throw err;
      });

      return window.__rideSyncMapsPromise;
    }

    function loadStripeJs() {
      if (!STRIPE_ENABLED) {
        return Promise.reject(
          new Error("Stripe payments are not available right now.")
        );
      }
      if (window.Stripe) {
        return Promise.resolve(window.Stripe);
      }
      if (!stripeJsPromise) {
        stripeJsPromise = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = STRIPE_JS_URL;
          script.async = true;
          script.onload = () => {
            if (window.Stripe) {
              resolve(window.Stripe);
            } else {
              reject(
                new Error("Stripe.js loaded but Stripe was unavailable.")
              );
            }
          };
          script.onerror = () =>
            reject(new Error("Stripe.js failed to load."));
          document.head.appendChild(script);
        }).catch((err) => {
          stripeJsPromise = null;
          throw err;
        });
      }
      return stripeJsPromise;
    }

    async function ensureAuthPersistence(authInstance) {
      if (!authInstance) return null;
      const strategies = [
        { label: "local", value: browserLocalPersistence },
        { label: "indexedDb", value: indexedDBLocalPersistence },
        { label: "session", value: browserSessionPersistence },
      ];
      for (const strategy of strategies) {
        if (!strategy.value) continue;
        try {
          await setPersistence(authInstance, strategy.value);
          return strategy.label;
        } catch (err) {
          console.warn(`Failed to set auth persistence (${strategy.label})`, err);
        }
      }
      return null;
    }

    const APP_CONFIG = await loadAppConfig();
    const supportConfig = APP_CONFIG.support || {};
    const geoConfig = APP_CONFIG.geo || {};
    const ridePolicyConfig = APP_CONFIG.ridePolicy || {};
    const placeholderConfig = APP_CONFIG.placeholders || {};
    const functionsConfig = APP_CONFIG.functions || {};
    const mapsConfig = APP_CONFIG.maps || APP_CONFIG.googleMaps || {};
    const DEFAULT_MAPS_API_KEY = "AIzaSyDlYSl5rfovahECuBSbkELw2uyC6-Ucmr0";
    const mapsApiKey = mapsConfig.apiKey || DEFAULT_MAPS_API_KEY;
    const mapsLibraries =
      Array.isArray(mapsConfig.libraries) && mapsConfig.libraries.length
        ? mapsConfig.libraries
        : ["places"];
    let googleMapsLoadFailed = false;

    const persistenceStrategy = await ensureAuthPersistence(auth);
    if (!persistenceStrategy) {
      console.warn("Auth persistence fallback failed; using Firebase default.");
    }
    const storage = getStorage(auth.app);
    const FUNCTIONS_REGION = "us-central1";
    const functionsClient = getFunctions(auth.app, FUNCTIONS_REGION);
    const stripeConfig = APP_CONFIG.stripe || {};
    const fareConfig = APP_CONFIG.fares || {};
    const paymentConfig = APP_CONFIG.payments || {};
    const MIN_RIDE_TIP_CENTS = 0;
    const DEFAULT_MAX_TIP_CENTS = Math.max(
      MIN_RIDE_TIP_CENTS,
      Math.round(paymentConfig.maxTipHoldCents || 1200)
    );
    const RESERVE_FEE_CENTS = 500;
    const RESERVATION_MIN_LEAD_MINUTES = 30;
    const RESERVATION_MAX_LEAD_MINUTES = 24 * 60;

    function normalizeStripeKeyForMode(key, mode) {
      const trimmed = typeof key === "string" ? key.trim() : "";
      if (!trimmed) {
        return "";
      }
      if (mode === "live" && trimmed.startsWith("pk_live_")) {
        return trimmed;
      }
      if (mode === "test" && trimmed.startsWith("pk_test_")) {
        return trimmed;
      }
      return "";
    }

    function selectStripeKeyForMode(mode) {
      const candidates =
        mode === "live"
          ? [
              stripeConfig.publishableKeyLive,
              stripeConfig.livePublishableKey,
              stripeConfig.publishableKey,
            ]
          : [
              stripeConfig.publishableKeyTest,
              stripeConfig.testPublishableKey,
              stripeConfig.publishableKeySandbox,
              stripeConfig.publishableKey,
            ];
      for (const candidate of candidates) {
        const normalized = normalizeStripeKeyForMode(candidate, mode);
        if (normalized) {
          return normalized;
        }
      }
      return "";
    }

    const STRIPE_KEYS_BY_MODE = {
      live: selectStripeKeyForMode("live"),
      test: selectStripeKeyForMode("test"),
    };

    const isLocalDevHost =
      typeof window !== "undefined" &&
      ["localhost", "127.0.0.1", "0.0.0.0"].includes(window.location.hostname);
    if (isLocalDevHost && !STRIPE_KEYS_BY_MODE.live) {
      console.warn(
        "[RideSync][Stripe] Missing live publishable key. Update stripe.publishableKey or stripe.publishableKeyLive in app-config.json."
      );
    }
    if (isLocalDevHost && !STRIPE_KEYS_BY_MODE.test) {
      console.warn(
        "[RideSync][Stripe] Missing test publishable key. Update stripe.publishableKeyTest or stripe.testPublishableKey in app-config.json."
      );
    }

    function resolveDefaultStripeKey() {
      if (isLocalDevHost) {
        return STRIPE_KEYS_BY_MODE.test || STRIPE_KEYS_BY_MODE.live || "";
      }
      return STRIPE_KEYS_BY_MODE.live || STRIPE_KEYS_BY_MODE.test || "";
    }

    const STRIPE_DEFAULT_PUBLISHABLE_KEY = resolveDefaultStripeKey();
    const stripeMembershipConfig = stripeConfig.membershipPlans || {};
    // Enable Stripe only when at least one publishable key is configured
    const STRIPE_ENABLED = STRIPE_DEFAULT_PUBLISHABLE_KEY.length > 0;
    const STRIPE_JS_URL = "https://js.stripe.com/v3/";
    const FORCE_DISABLE_GOOGLE_PAY = window.location.protocol !== "https:";
    const PAYMENT_ERROR_FALLBACK =
      "Payments are temporarily unavailable. Please try again.";
    const rideCheckoutSessionEndpoints = buildRideCheckoutSessionEndpoints();
    const membershipFinalizeEndpoints = buildMembershipFinalizeEndpoints();
    const MEMBERSHIP_CHECKOUT_ERROR_FALLBACK =
      "Membership billing is temporarily unavailable. Please try again.";
    const MEMBERSHIP_FINALIZE_FALLBACK =
      "We received your payment but still need to finish processing your membership. Contact RideSync support if this continues.";

    function isFirebaseHttpsError(err) {
      return typeof err?.code === "string" && err.code.startsWith("functions/");
    }

    function handleCallableError(source, err, fallbackMessage = PAYMENT_ERROR_FALLBACK) {
      if (isFirebaseHttpsError(err)) {
        console.error(`${source} failed`, {
          code: err.code,
          message: err.message,
          details: err.details ?? null,
        });
        return new Error(fallbackMessage);
      }
      console.error(`${source} failed`, err);
      return err instanceof Error ? err : new Error(fallbackMessage);
    }

    function resolveStripePublishableKeyForMode(livemode) {
      if (livemode === true) {
        return STRIPE_KEYS_BY_MODE.live || null;
      }
      if (livemode === false) {
        return STRIPE_KEYS_BY_MODE.test || null;
      }
      return STRIPE_DEFAULT_PUBLISHABLE_KEY || null;
    }

    // === RIDE SYNC STRIPE: DEBUG HELPERS ===
    function logStripeDebug(label, payload) {
      try {
        console.log("[RideSync][Stripe]", label, payload);
      } catch (_) {
        // no-op: logging should never break the app
      }
    }
    function resolveClientSecret(payload = {}) {
      return payload?.clientSecret || payload?.client_secret || null;
    }
    const getDriverAvailabilityStatsFn = httpsCallable(
      functionsClient,
      "getDriverAvailabilityStats"
    );
    const createRideCheckoutSessionCallableFn = httpsCallable(
      functionsClient,
      "createRideCheckoutSessionCallable"
    );
    const createMembershipCheckoutSessionFn = httpsCallable(
      functionsClient,
      "createMembershipCheckoutSession"
    );
    const saveUserProfileFn = httpsCallable(functionsClient, "saveUserProfile");
    const createRideRequestFn = httpsCallable(functionsClient, "createRideRequest");
    const joinRideGroupFn = httpsCallable(functionsClient, "joinRideGroup");
    const cancelRideRequestFn = httpsCallable(functionsClient, "cancelRideRequest");
    const submitRideRatingFn = httpsCallable(functionsClient, "submitRideRating");
    const validateReferralCodeForRideFn = httpsCallable(
      functionsClient,
      "validateReferralCodeForRide"
    );
    const confirmRidePaymentIntentFn = httpsCallable(
      functionsClient,
      "confirmRidePaymentIntent"
    );
    const captureRidePaymentIntentFn = httpsCallable(
      functionsClient,
      "captureRidePaymentIntent"
    );
    const createRidePaymentIntentFn = httpsCallable(
      functionsClient,
      "createRidePaymentIntent"
    );
    const createRideFareCheckoutSessionFn = httpsCallable(
      functionsClient,
      "createRideFareCheckoutSession"
    );

    const NWA_CENTER = geoConfig.nwaCenter || { lat: 36.334, lng: -94.118 };
    const NWA_RADIUS_MILES = geoConfig.nwaRadiusMiles ?? 30;
    const FAYETTEVILLE_CENTER =
      geoConfig.fayettevilleCenter || { lat: 36.063, lng: -94.171 };
    const FAYETTEVILLE_RADIUS_MILES =
      geoConfig.fayettevilleRadiusMiles ?? 6;
    const UNLIMITED_COOLDOWN_MINUTES =
      ridePolicyConfig.unlimitedCooldownMinutes ?? 30;
    const SURGE_MODE = ridePolicyConfig.surgeMode ?? false;
    const SURGE_COOLDOWN_MINUTES =
      ridePolicyConfig.surgeCooldownMinutes ?? 60;
    const DRIVER_PLACEHOLDER_AVATAR = placeholderConfig.driverAvatar || "";
    const VEHICLE_PLACEHOLDER_IMG = placeholderConfig.vehicleImage || "";
    const LICENSE_PLACEHOLDER_IMG = placeholderConfig.licenseImage || "";
    const SUPPORT_PHONE_NUMBER = supportConfig.phoneNumber || "";
    const SUPPORT_TEL_LINK = SUPPORT_PHONE_NUMBER
      ? `tel:${SUPPORT_PHONE_NUMBER}`
      : "#";
    const SUPPORT_SMS_LINK = SUPPORT_PHONE_NUMBER
      ? `sms:${SUPPORT_PHONE_NUMBER}`
      : "#";
    const MEMBERSHIP_TIER_KEYS = {
      BASIC: "BASIC",
      UOFA: "UOFA",
      NWA: "NWA",
    };
    const MEMBERSHIP_TIER_DETAILS = {
      [MEMBERSHIP_TIER_KEYS.BASIC]: {
        label: "BASIC (default)",
        summary: "Pay per ride inside the standard RideSync coverage area.",
        badgeTag: "Pay per ride",
      },
      [MEMBERSHIP_TIER_KEYS.UOFA]: {
        label: "U OF A STUDENT — UNLIMITED",
        summary: "Unlimited Fayetteville rides. Only pay tip. 30-min cooldown (60 during surge).",
        badgeTag: "Fayetteville radius",
      },
      [MEMBERSHIP_TIER_KEYS.NWA]: {
        label: "NORTHWEST ARKANSAS — UNLIMITED",
        summary: "Unlimited rides within 30 miles of Rogers. Only pay tip.",
        badgeTag: "30-mi NWA zone",
      },
    };
    const MEMBERSHIP_PLAN_COPY = {
      basic: {
        label: MEMBERSHIP_TIER_DETAILS[MEMBERSHIP_TIER_KEYS.BASIC].label,
        price: "$0.60/min + $3.00 + 3%",
        description: "Standard RideSync coverage. Billed per ride.",
        tier: MEMBERSHIP_TIER_KEYS.BASIC,
        priceCents: 0,
      },
      uofa_unlimited: {
        label: MEMBERSHIP_TIER_DETAILS[MEMBERSHIP_TIER_KEYS.UOFA].label,
        price: "$80 / month",
        description: "Unlimited Fayetteville rides with a 30-min cooldown (60-min during surge).",
        tier: MEMBERSHIP_TIER_KEYS.UOFA,
        priceCents: 8000,
      },
      nwa_unlimited: {
        label: MEMBERSHIP_TIER_DETAILS[MEMBERSHIP_TIER_KEYS.NWA].label,
        price: "$120 / month",
        description: "Unlimited rides within a 30-mile Rogers radius. Only pay tip.",
        tier: MEMBERSHIP_TIER_KEYS.NWA,
        priceCents: 12000,
      },
    };
    const MEMBERSHIP_PLAN_KEY_ALIASES = {
      basic: new Set([
        "basic",
        "basic (pay per ride)",
        "basic plan",
        "plan: basic",
        "basic (default)",
      ]),
      uofa_unlimited: new Set([
        "uofa",
        "u of a",
        "u of a student — unlimited",
        "u of a student - unlimited",
        "u of a student unlimited",
        "u of a student",
        "uofa_unlimited",
      ]),
      nwa_unlimited: new Set([
        "nwa",
        "northwest arkansas",
        "northwest arkansas — unlimited",
        "northwest arkansas - unlimited",
        "northwest arkansas unlimited",
        "nwa_unlimited",
      ]),
    };
    const MEMBERSHIP_PLAN_DEFAULT_MODES = {
      basic: "none",
      uofa_unlimited: "subscription",
      nwa_unlimited: "subscription"
    };
    const MEMBERSHIP_PLAN_VALID_MODES = new Set(["subscription", "payment", "none"]);

    function resolvePlanTier(planKey) {
      const normalized = normalizePlanKey(planKey);
      return MEMBERSHIP_PLAN_COPY[normalized]?.tier || MEMBERSHIP_TIER_KEYS.BASIC;
    }

    function formatPlanTierLabel(planKey) {
      const tier = resolvePlanTier(planKey);
      return (
        MEMBERSHIP_TIER_DETAILS[tier]?.label ||
        MEMBERSHIP_TIER_DETAILS[MEMBERSHIP_TIER_KEYS.BASIC].label
      );
    }

    function normalizeMembershipTierClient(value) {
      if (typeof value !== "string") {
        return MEMBERSHIP_TIER_KEYS.BASIC;
      }
      const normalized = value.trim().toUpperCase();
      return MEMBERSHIP_TIER_KEYS[normalized] ? normalized : MEMBERSHIP_TIER_KEYS.BASIC;
    }

    function resolveProfileTier(profile) {
      if (!profile) {
        return MEMBERSHIP_TIER_KEYS.BASIC;
      }
      if (profile.membershipTier) {
        return normalizeMembershipTierClient(profile.membershipTier);
      }
      if (profile.membership_tier) {
        return normalizeMembershipTierClient(profile.membership_tier);
      }
      const plan = normalizePlanKey(profile.membershipType || profile.membership || "basic");
      return resolvePlanTier(plan);
    }

    const DEFAULT_FARE_SETTINGS = {
      BASIC_RATE_PER_MIN: 0.6,
      BASIC_PLATFORM_FEE: 1.5,
      BASIC_PER_RIDE_FEE: 1.5,
      BASIC_PROCESSING_FEE_RATE: 0.03,
      UNLIMITED_OUT_RATE: 0.35,
      UNLIMITED_PROCESSING_FEE_RATE: 0.04
    };

    function coerceFareNumber(value, fallback) {
      if (value === null || value === undefined) {
        return fallback;
      }
      if (typeof value === "string" && value.trim() === "") {
        return fallback;
      }
      const num = Number(value);
      return Number.isFinite(num) && num >= 0 ? num : fallback;
    }

    const FARE_SETTINGS = {
      BASIC_RATE_PER_MIN: coerceFareNumber(
        fareConfig.basicRatePerMin,
        DEFAULT_FARE_SETTINGS.BASIC_RATE_PER_MIN
      ),
      BASIC_PLATFORM_FEE: coerceFareNumber(
        fareConfig.basicPlatformFee,
        DEFAULT_FARE_SETTINGS.BASIC_PLATFORM_FEE
      ),
      BASIC_PER_RIDE_FEE: coerceFareNumber(
        fareConfig.basicPerRideFee,
        DEFAULT_FARE_SETTINGS.BASIC_PER_RIDE_FEE
      ),
      BASIC_PROCESSING_FEE_RATE: coerceFareNumber(
        fareConfig.basicProcessingFeeRate,
        DEFAULT_FARE_SETTINGS.BASIC_PROCESSING_FEE_RATE
      ),
      UNLIMITED_OUT_RATE: coerceFareNumber(
        fareConfig.unlimitedOutRate,
        DEFAULT_FARE_SETTINGS.UNLIMITED_OUT_RATE
      ),
      UNLIMITED_PROCESSING_FEE_RATE: coerceFareNumber(
        fareConfig.unlimitedProcessingFeeRate,
        DEFAULT_FARE_SETTINGS.UNLIMITED_PROCESSING_FEE_RATE
      )
    };

    const urlParams = new URLSearchParams(window.location.search);
    const joinRideIdFromUrl = urlParams.get("join");
    const joinGuestBypassRequested = urlParams.get("guest") === "1";
    const checkoutReturnState = {
      pendingId:
        urlParams.get("pending_id") ||
        urlParams.get("pendingId") ||
        urlParams.get("pending"),
      sessionId:
        urlParams.get("session_id") ||
        urlParams.get("sessionId") ||
        urlParams.get("session"),
      status: "idle",
      attempts: 0,
      rideId: null
    };
    if (checkoutReturnState.pendingId && checkoutReturnState.sessionId) {
      checkoutReturnState.status = "waiting";
    }

    const membershipCheckoutReturnState = {
      pendingId:
        urlParams.get("membership_pending_id") ||
        urlParams.get("membershipPendingId") ||
        urlParams.get("membershipPending"),
      sessionId:
        urlParams.get("membership_session_id") ||
        urlParams.get("membershipSessionId") ||
        urlParams.get("membershipSession"),
      status: "idle",
      attempts: 0,
    };
    if (
      membershipCheckoutReturnState.pendingId &&
      membershipCheckoutReturnState.sessionId
    ) {
      membershipCheckoutReturnState.status = "waiting";
    }

    const membershipCheckoutState = {
      status: "idle",
      activePlan: null,
      selectedPlan: null,
      processing: false,
    };

    let joinMode = false;
    let joinTargetRide = null;
    let guestBypassEligible = false;
    let activeRideGuestBypass = false;
    let joinGuestBypassActive = false;
    let guestContributionState = {
      shareCents: 0,
      tipCents: 0
    };

    const PIN_CHARSET = "0123456789";
    const POOL_GENDER_ALLOWLIST = new Set(["male", "female"]);
    const METERS_TO_MILES = 0.000621371;

    function normalizePoolGender(value) {
      if (typeof value !== "string") {
        return null;
      }
      const normalized = value.trim().toLowerCase();
      return POOL_GENDER_ALLOWLIST.has(normalized) ? normalized : null;
    }

    function generateRidePin(length = 4) {
      let code = "";
      for (let i = 0; i < length; i += 1) {
        const idx = Math.floor(Math.random() * PIN_CHARSET.length);
        code += PIN_CHARSET.charAt(idx);
      }
      return code;
    }

    let lastDestinationPlace = null;
    let lastDestinationIsFayetteville = false;

    function isFayettevilleFromPlace(place) {
      if (!place || !place.address_components) return false;
      return place.address_components.some(
        (comp) =>
          comp.types.includes("locality") && comp.long_name === "Fayetteville"
      );
    }

    const authView = document.getElementById("authView");
    const rideView = document.getElementById("rideView");
    const loadingView = document.getElementById("loadingView");
    const toggleLink = document.getElementById("toggleLink");
    const authError = document.getElementById("authError");
    const authButton = document.getElementById("authButton");
    const emailEl = document.getElementById("email");
    const passwordEl = document.getElementById("password");
    const signupFields = document.getElementById("signupFields");
    const fullNameEl = document.getElementById("fullName");
    const genderEl = document.getElementById("gender");
    const phoneEl = document.getElementById("phoneNumber");
    const streetEl = document.getElementById("streetAddress");
    const cityEl = document.getElementById("city");
    const stateEl = document.getElementById("state");
    const zipEl = document.getElementById("zip");
    const isStudentEl = document.getElementById("isStudent");
    const membershipEl = document.getElementById("membership");
    const profilePicInput = document.getElementById("profilePicInput");
    const mainLandingPage = document.getElementById("mainLandingPage");
    const landingSyncRiderButton = document.getElementById("landingSyncRider");
    const landingSyncDriverButton = document.getElementById("landingSyncDriver");
    const driverComingSoonOverlay = document.getElementById("driverComingSoonOverlay");
    const driverComingSoonClose = document.getElementById("driverComingSoonClose");
    const appBody = document.body;
    let riderPresenceInterval = null;
    let riderPresenceUserId = null;

    function writeRiderPresenceOnline(uid) {
      if (!uid) return Promise.resolve();
      const userRef = doc(db, "users", uid);
      return setDoc(
        userRef,
        {
          presenceRole: "rider",
          isOnline: true,
          lastActiveAt: serverTimestamp(),
        },
        { merge: true }
      ).catch((err) => {
        console.warn("rider presence heartbeat failed", err);
      });
    }

    function markRiderOffline(uid) {
      if (!uid) return;
      const userRef = doc(db, "users", uid);
      setDoc(
        userRef,
        {
          isOnline: false,
          lastOfflineAt: serverTimestamp(),
          presenceRole: "rider",
        },
        { merge: true }
      ).catch((err) => {
        console.warn("rider presence offline update failed", err);
      });
    }

    function handleVisibilityChange() {
      if (document.visibilityState === "visible" && riderPresenceUserId) {
        writeRiderPresenceOnline(riderPresenceUserId);
      }
    }

    function startRiderPresenceHeartbeat(uid) {
      if (!uid) return;
      riderPresenceUserId = uid;
      clearInterval(riderPresenceInterval);
      writeRiderPresenceOnline(uid);
      riderPresenceInterval = setInterval(() => {
        writeRiderPresenceOnline(uid);
      }, 60_000);
      document.addEventListener("visibilitychange", handleVisibilityChange);
    }

    function stopRiderPresenceHeartbeat(markOffline = false) {
      clearInterval(riderPresenceInterval);
      riderPresenceInterval = null;
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      const uid = riderPresenceUserId;
      riderPresenceUserId = null;
      if (markOffline && uid) {
        markRiderOffline(uid);
      }
    }

    function dismissLandingPage() {
      if (mainLandingPage && mainLandingPage.classList.contains("active")) {
        const focusWasInside = mainLandingPage.contains(document.activeElement);
        mainLandingPage.classList.remove("active");
        mainLandingPage.setAttribute("aria-hidden", "true");
        if (focusWasInside) {
          landingSyncRiderButton?.blur();
          landingSyncDriverButton?.blur();
          emailEl?.focus?.();
        }
        mainLandingPage.setAttribute("inert", "");
      }
      if (appBody && appBody.classList.contains("landing-active")) {
        appBody.classList.remove("landing-active");
      }
    }

    function showDriverComingSoonModal() {
      if (!driverComingSoonOverlay) return;
      driverComingSoonOverlay.classList.add("active");
      driverComingSoonOverlay.setAttribute("aria-hidden", "false");
    }

    function hideDriverComingSoonModal() {
      if (!driverComingSoonOverlay) return;
      driverComingSoonOverlay.classList.remove("active");
      driverComingSoonOverlay.setAttribute("aria-hidden", "true");
    }

    landingSyncRiderButton?.addEventListener("click", () => {
      hideDriverComingSoonModal();
      dismissLandingPage();
    });

    landingSyncDriverButton?.addEventListener("click", () => {
      showDriverComingSoonModal();
    });

    driverComingSoonClose?.addEventListener("click", () => {
      hideDriverComingSoonModal();
    });

    driverComingSoonOverlay?.addEventListener("click", (event) => {
      if (event.target === driverComingSoonOverlay) {
        hideDriverComingSoonModal();
      }
    });

    const avatarEl = document.getElementById("avatar");
    const riderNameEl = document.getElementById("riderName");
    const membershipBadgeEl = document.getElementById("membershipBadge");
    const membershipBadgeLabelEl = document.getElementById("membershipBadgeLabel");
    const membershipBadgeTagEl = document.getElementById("membershipBadgeTag");
    const membershipCard = document.getElementById("membershipCard");
    const membershipStatusText = document.getElementById("membershipStatusText");
    const membershipStatusBadge = document.getElementById("membershipStatusBadge");
    const membershipCardMessage = document.getElementById("membershipCardMessage");
    const membershipCurrentLabel = document.getElementById("membershipCurrentLabel");
    const membershipPriceEls = document.querySelectorAll("[data-plan-price]");
    const membershipPlanGrid = document.getElementById("membershipPlanGrid");
    const membershipPlanCards = membershipPlanGrid
      ? Array.from(membershipPlanGrid.querySelectorAll(".membership-plan[data-plan]"))
      : [];
    const membershipPlanButtons = new Map();
    document.querySelectorAll("[data-plan-action]").forEach((button) => {
      const planKey = normalizePlanKey(button.dataset.planAction);
      membershipPlanButtons.set(planKey, button);
    });
    const membershipPlanHints = new Map();
    document.querySelectorAll("[data-plan-hint]").forEach((node) => {
      const planKey = normalizePlanKey(node.dataset.planHint);
      membershipPlanHints.set(planKey, node);
    });
    const MEMBERSHIP_CARD_DEFAULT_MESSAGE =
      "Membership charges are included with your fare payment.";
    const syncConfirmOverlay = document.getElementById("syncConfirmOverlay");
    const syncConfirmTitle = document.getElementById("syncConfirmTitle");
    const syncConfirmSubtitle = document.getElementById("syncConfirmSubtitle");
    const syncConfirmDestination = document.getElementById("syncConfirmDestination");
    const syncConfirmTime = document.getElementById("syncConfirmTime");
    const syncConfirmDistance = document.getElementById("syncConfirmDistance");
    const syncConfirmTotal = document.getElementById("syncConfirmTotal");
    const syncMembershipList = document.getElementById("syncMembershipList");
    const syncMembershipHint = document.getElementById("syncMembershipHint");
    const syncMembershipTermsContainer = document.getElementById("syncMembershipTermsContainer");
    const syncMembershipTermsCheckbox = document.getElementById("syncMembershipTermsCheckbox");
    const syncMembershipTermsCustomerName = document.getElementById("syncMembershipTermsCustomerName");
    const syncMembershipTermsPlanLabel = document.getElementById("syncMembershipTermsPlanLabel");
    const syncTipOptions = document.getElementById("syncTipOptions");
    const syncTipCustomInput = document.getElementById("syncTipCustomInput");
    const syncTipMessage = document.getElementById("syncTipMessage");
    const reserveTimeSection = document.getElementById("reserveTimeSection");
    const reserveModeRadios = document.querySelectorAll('input[name="reserveMode"]');
    const reserveDateInput = document.getElementById("reserveDateInput");
    const reserveTimeInput = document.getElementById("reserveTimeInput");
    const reserveDateTimeRow = document.getElementById("reserveDateTimeRow");
    const reserveTimeHint = document.getElementById("reserveTimeHint");
    const referralCodeSection = document.getElementById("referralCodeSection");
    const referralCodeInput = document.getElementById("referralCodeInput");
    const applyReferralCodeButton = document.getElementById("applyReferralCodeButton");
    const referralCodeMessage = document.getElementById("referralCodeMessage");
    const discountCodeSection = document.getElementById("discountCodeSection");
    const discountCodeInput = document.getElementById("discountCodeInput");
    const applyDiscountCodeButton = document.getElementById("applyDiscountCodeButton");
    const discountCodeMessage = document.getElementById("discountCodeMessage");
    const syncConfirmButton = document.getElementById("syncConfirmButton");
    const syncConfirmClose = document.getElementById("syncConfirmClose");
    const syncConfirmCancel = document.getElementById("syncConfirmCancel");
    const syncConfirmError = document.getElementById("syncConfirmError");

    const membershipCheckoutOverlay = document.getElementById("membershipCheckoutOverlay");
    const membershipCheckoutOptions = document.getElementById("membershipCheckoutOptions");
    const membershipCheckoutPrice = document.getElementById("membershipCheckoutPrice");
    const membershipCheckoutHint = document.getElementById("membershipCheckoutHint");
    const membershipCheckoutError = document.getElementById("membershipCheckoutError");
    const membershipCheckoutButton = document.getElementById("membershipCheckoutButton");
    const membershipCheckoutClose = document.getElementById("membershipCheckoutClose");
    const membershipCheckoutCancel = document.getElementById("membershipCheckoutCancel");

    const riderEmailDetailEl = document.getElementById("riderEmailDetail");
    const riderPhoneDetailEl = document.getElementById("riderPhoneDetail");
    const riderAddressDetailEl = document.getElementById("riderAddressDetail");
    const riderMembershipDetailEl = document.getElementById("riderMembershipDetail");
    const editProfileButton = document.getElementById("editProfileButton");
    const editProfileSection = document.getElementById("editProfileSection");
    const editFullNameEl = document.getElementById("editFullName");
    const editPhoneEl = document.getElementById("editPhone");
    const editStreetEl = document.getElementById("editStreet");
    const editCityEl = document.getElementById("editCity");
    const editStateEl = document.getElementById("editState");
    const editZipEl = document.getElementById("editZip");
    const editProfilePicInput = document.getElementById("editProfilePicInput");
    const editGenderEl = document.getElementById("editGender");
    const saveProfileButton = document.getElementById("saveProfileButton");

    const joinBanner = document.getElementById("joinBanner");
    const joinBannerText = document.getElementById("joinBannerText");

    const poolGroupTitle = document.getElementById("poolGroupTitle");
    const poolGroupBox = document.getElementById("poolGroupBox");
    const poolGroupStatus = document.getElementById("poolGroupStatus");
    const poolGroupList = document.getElementById("poolGroupList");

    const profileMessage = document.getElementById("profileMessage");
    const profileError = document.getElementById("profileError");
    const driverAvailabilityNotice = document.getElementById("driverAvailabilityNotice");

    function showErrorBanner(message) {
      if (profileError) {
        profileError.textContent =
          message || "Payments are temporarily unavailable. Please try again.";
      } else {
        console.error(message);
      }
    }

    const mapEl = document.getElementById("map");
    const destinationEl = document.getElementById("destination");
    const addStopButton = document.getElementById("addStopButton");
    const extraStopsContainer = document.getElementById("extraStopsContainer");
    const pickupOverrideField = document.getElementById("pickupOverrideField");
    const pickupOverrideInput = document.getElementById("pickupOverrideInput");
    const pickupOverrideHint = document.getElementById("pickupOverrideHint");
    const pickupOverrideError = document.getElementById("pickupOverrideError");
    const numRidersEl = document.getElementById("numRiders");
    const syncRidersButton = document.getElementById("syncRidersButton");
    const ridersSection = document.getElementById("ridersSection");
    const tripMapPreviewEl = document.getElementById("tripMapPreview");
    const destinationPreviewMapEl = document.getElementById("destinationPreviewMap");
    const destinationPreviewEmptyEl = document.getElementById("destinationPreviewEmpty");
    const paymentFareSummary = document.getElementById("paymentFareSummary");
    const fareNotReady = document.getElementById("fareNotReady");
    const fareReady = document.getElementById("fareReady");
    const fareTime = document.getElementById("fareTime");
    const fareDistance = document.getElementById("fareDistance");
    const fareMembership = document.getElementById("fareMembership");
    const fareTotal = document.getElementById("fareTotal");
    const fareExtraStops = document.getElementById("fareExtraStops");
    const syncButton = document.getElementById("syncButton");
    const logoutButton = document.getElementById("logoutButton");

    const cancelRideButton = document.getElementById("cancelRideButton");
    const cancelError = document.getElementById("cancelError");

    const groupQrSection = document.getElementById("groupQrSection");
    const groupQrIntro = document.getElementById("groupQrIntro");
    const groupQrCanvas = document.getElementById("groupQrCanvas");
    const groupQrPendingMessage = document.getElementById("groupQrPendingMessage");
    const groupOccupancyLabel = document.getElementById("groupOccupancyLabel");
    const syncRidersOverlay = document.getElementById("syncRidersOverlay");
    const syncRidersOverlayClose = document.getElementById("syncRidersOverlayClose");
    const syncRidersModalCanvas = document.getElementById("syncRidersModalCanvas");
    const syncRidersModalOccupancy = document.getElementById("syncRidersModalOccupancy");
    const syncRidersCopyLink = document.getElementById("syncRidersCopyLink");
    const syncRidersCopyFeedback = document.getElementById("syncRidersCopyFeedback");
    const guestContributionCard = document.getElementById("guestContributionCard");
    const guestContributionHint = document.getElementById("guestContributionHint");
    const guestShareInput = document.getElementById("guestShareInput");
    const guestShareButton = document.getElementById("guestShareButton");
    const guestTipInput = document.getElementById("guestTipInput");
    const guestTipButton = document.getElementById("guestTipButton");
    const guestContributionSummary = document.getElementById("guestContributionSummary");
    const groupQrIntroDefaultCopy =
      groupQrIntro?.textContent?.trim() ||
      "Tap Sync QR to open the overlay and share the code with friends. We'll track how many riders have joined below.";
    let syncRidersQr = null;
    let syncRidersJoinUrl = "";
    let syncRidersFlowActive = false;
    let syncRidersAwaitingRideActivation = false;

    function setGroupQrVisibility(isVisible) {
      if (!groupQrSection) return;
      groupQrSection.classList.toggle("visible", Boolean(isVisible));
      groupQrSection.setAttribute("aria-expanded", isVisible ? "true" : "false");
    }

    try {
      await loadGoogleMapsSdk({ apiKey: mapsApiKey, libraries: mapsLibraries });
    } catch (err) {
      googleMapsLoadFailed = true;
      console.error("Google Maps SDK failed to load", err);
      if (profileError) {
        profileError.textContent =
          "Unable to load maps right now. Please refresh or verify the Maps API key.";
      }
    }

    // Rider active-ride overlay + mini bar + summary
    const riderOverlay = document.getElementById("riderOverlay");
    const riderOverlayTitle = document.getElementById("riderOverlayTitle");
    const riderOverlaySubtitle = document.getElementById("riderOverlaySubtitle");
    const riderOverlayError = document.getElementById("riderOverlayError");
    const riderStateElements = {
      searching: document.getElementById("riderStateSearching"),
      driverEta: document.getElementById("riderStateDriverEta"),
      pickupPin: document.getElementById("riderStatePickupPin"),
      inTrip: document.getElementById("riderStateInTrip"),
      dropoffPin: document.getElementById("riderStateDropoffPin"),
      rateTip: document.getElementById("riderStateRateTip"),
      thanks: document.getElementById("riderStateThanks")
    };
    const driverInfoSlotPickup = riderStateElements.driverEta?.querySelector(".driver-info-slot") || null;
    const driverInfoSlotTrip = riderStateElements.inTrip?.querySelector(".driver-info-slot") || null;
    const riderPickupPinValue = document.getElementById("riderPickupPinValue");
    const riderDropoffPinValue = document.getElementById("riderDropoffPinValue");
    const riderTripEtaText = document.getElementById("riderTripEtaText");
    const riderWaitlistPanel = document.getElementById("riderWaitlistPanel");
    const riderWaitlistStatusEl = document.getElementById("riderWaitlistStatus");
    const riderWaitlistTimerEl = document.getElementById("riderWaitlistTimer");
    const riderWaitlistBadgeEl = document.getElementById("riderWaitlistBadge");
    const driverInfoStack = document.getElementById("driverInfoStack");
    const rideChatCard = document.getElementById("rideChatCard");
    const rideChatMessagesEl = document.getElementById("rideChatMessages");
    const rideChatInputEl = document.getElementById("rideChatInput");
    const rideChatSendButton = document.getElementById("rideChatSendButton");
    const rideChatOfflineNote = document.getElementById("rideChatOfflineNote");
    const ratingStarsContainer = document.getElementById("ratingStars");
    const ratingError = document.getElementById("ratingError");
    const rideTipOptions = document.getElementById("rideTipOptions");
    const rideTipCustomInput = document.getElementById("rideTipCustomInput");
    const submitRatingButton = document.getElementById("submitRatingButton");
    const riderFeedbackInput = document.getElementById("riderFeedbackInput");
    const cooldownOverlay = document.getElementById("cooldownOverlay");
    const cooldownLabelEl = document.getElementById("cooldownLabel");
    const cooldownTitleEl = document.getElementById("cooldownTitle");
    const cooldownSubtitleEl = document.getElementById("cooldownSubtitle");
    const cooldownTimerValue = document.getElementById("cooldownTimerValue");
    const cooldownHintText = document.getElementById("cooldownHintText");
    const cooldownDismissButton = document.getElementById("cooldownDismissButton");

    const driverIdentityCardEl = document.getElementById("driverIdentityCard");
    const driverIdentityNameEl = document.getElementById("driverIdentityName");
    const driverIdentityStatusEl = document.getElementById("driverIdentityStatus");
    const driverIdentityRatingEl = document.getElementById("driverIdentityRating");
    const driverIdentityAvatarImg = document.getElementById("driverIdentityAvatarImg");
    const driverIdentityAvatarFallback = document.getElementById("driverIdentityAvatarFallback");
    const driverIdentityPhoneRow = document.getElementById("driverIdentityPhoneRow");
    const driverIdentityPhoneEl = document.getElementById("driverIdentityPhone");
    const driverIdentityBadgesEl = document.getElementById("driverIdentityBadges");
    const driverIdentityEtaEl = document.getElementById("driverIdentityEta");
    const driverMiniMapShell = document.getElementById("driverMiniMapShell");
    const driverMiniMapEl = document.getElementById("driverMiniMap");
    const driverMiniMapStatusEl = document.getElementById("driverMiniMapStatus");

    const driverVehicleSection = document.getElementById("driverVehicleSection");
    const driverVehiclePhotoImg = document.getElementById("driverVehiclePhoto");
    const driverVehicleFallbackEl = document.getElementById("driverVehicleFallback");
    const driverVehicleNameEl = document.getElementById("driverVehicleName");
    const driverVehiclePlateEl = document.getElementById("driverVehiclePlate");
    const driverVehicleNoteEl = document.getElementById("driverVehicleNote");

    const driverLicenseSection = document.getElementById("driverLicenseSection");
    const driverLicensePhotoImg = document.getElementById("driverLicensePhoto");
    const driverLicenseFallbackEl = document.getElementById("driverLicenseFallback");
    const driverLicenseSummaryEl = document.getElementById("driverLicenseSummary");
    const driverLicenseMetaEl = document.getElementById("driverLicenseMeta");

    const supportPanel = document.getElementById("supportPanel");
    const supportBackButton = document.getElementById("supportBackButton");
    const supportCallButton = document.getElementById("supportCallButton");
    const supportTextButton = document.getElementById("supportTextButton");

    const rideSummary = document.getElementById("rideSummary");
    const rideSummaryText = document.getElementById("rideSummaryText");

    const contactDriverBtn = document.getElementById("contactDriverBtn");
    const rideViewTabs = document.querySelectorAll("[data-view-tab]");
    const rideViewPanels = document.querySelectorAll("[data-view-panel]");
    const rideViewTabDestination = document.getElementById("rideViewTabDestination");
    const rideViewTabMembership = document.getElementById("rideViewTabMembership");
    const rideViewTabInfo = document.getElementById("rideViewTabInfo");

    const paymentOverlay = document.getElementById("paymentOverlay");
    const paymentOverlayTitle = document.getElementById("paymentOverlayTitle");
    const paymentOverlaySubtitle = document.getElementById("paymentOverlaySubtitle");
    const paymentOverlayClose = document.getElementById("paymentOverlayClose");
    const paymentOverlayConfirm = document.getElementById("paymentOverlayConfirm");
    const paymentOverlayMessage = document.getElementById("paymentOverlayMessage");
    const paymentElementContainer = document.getElementById("paymentElement");
    const paymentRedirectOverlay = document.getElementById("paymentRedirectOverlay");
    const paymentRedirectSubtitle = document.getElementById("paymentRedirectSubtitle");
    const paymentStatusOverlay = document.getElementById("paymentStatusOverlay");
    const paymentStatusTitle = document.getElementById("paymentStatusTitle");
    const paymentStatusMessage = document.getElementById("paymentStatusMessage");
    const paymentStatusBackButton = document.getElementById("paymentStatusBackButton");
    const rideFareOverlay = document.getElementById("rideFareOverlay");
    const rideFareSubtitle = document.getElementById("rideFareSubtitle");
    const rideFareAmount = document.getElementById("rideFareAmount");
    const rideFareDetails = document.getElementById("rideFareDetails");
    const rideFarePaymentRequest =
      document.getElementById("rideFarePaymentRequest");
    const rideFareUnavailable = document.getElementById("rideFareUnavailable");
    const rideFareStatus = document.getElementById("rideFareStatus");
    const rideFareClose = document.getElementById("rideFareClose");
    const rideFareBaseAmount = document.getElementById("rideFareBaseAmount");
    const rideFareTipAmount = document.getElementById("rideFareTipAmount");
    const rideFareMembershipRow = document.getElementById("rideFareMembershipRow");
    const rideFareMembershipLabel = document.getElementById("rideFareMembershipLabel");
    const rideFareMembershipNote = document.getElementById("rideFareMembershipNote");
    const rideCardElement = document.getElementById("rideCardElement");
    const rideCardSubmit = document.getElementById("rideCardSubmit");
    const rideCardMessage = document.getElementById("rideCardMessage");
    const rideCheckoutButton = document.getElementById("rideCheckoutButton");
    const rideCheckoutMessage = document.getElementById("rideCheckoutMessage");
    const preauthTipSection = document.getElementById("preauthTipSection");
    const preauthTipOptions = document.getElementById("preauthTipOptions");
    const preauthTipCustomInput = document.getElementById("preauthTipCustomInput");
    const preauthTipMessage = document.getElementById("preauthTipMessage");
    const preauthHoldAmount = document.getElementById("preauthHoldAmount");
    const preauthHoldSummary = document.getElementById("preauthHoldSummary");
    const finalTipSection = document.getElementById("finalTipSection");
    const finalTipInput = document.getElementById("finalTipInput");
    const finalTipDecrease = document.getElementById("finalTipDecrease");
    const finalTipIncrease = document.getElementById("finalTipIncrease");
    const finalTipHint = document.getElementById("finalTipHint");
    const finalizeTipButton = document.getElementById("finalizeTipButton");
    const finalizeTipMessage = document.getElementById("finalizeTipMessage");

    let latestRideForOverlay = null;
    const stripeInstancesByKey = new Map();
    let stripeElements = null;
    let stripePaymentElement = null;
    let activePaymentContext = null;
    let activePaymentLivemode = null;
    let stripeJsPromise = null;
    const ridePaymentState = {
      rideId: null,
      baseAmountCents: 0,
      tipAmountCents: 0,
      totalAmountCents: 0,
      clientSecret: null,
      summary: null,
      paymentRequest: null,
      paymentRequestElement: null,
      paymentRequestElementsInstance: null,
      paymentElements: null,
      paymentElement: null,
      processing: false,
      completed: false,
      showing: false,
      livemode: null,
      intentRequestId: 0,
      clientSecretContext: null,
    };

    const ridePreauthState = {
      rideId: null,
      fareAmountCents: 0,
      maxTipAmountCents: DEFAULT_MAX_TIP_CENTS,
      selectedTipCents: MIN_RIDE_TIP_CENTS,
      authAmountCents: 0,
      pendingResolve: null,
      pendingReject: null,
    };

    const syncConfirmState = {
      reserveFeeCents: 0,
      reserveTimeIso: null,
      reserveMode: "asap",
      referral: {
        code: null,
        discountCents: 0,
        description: "",
      },
    };

    const rideTipCaptureState = {
      rideId: null,
      paymentIntentId: null,
      maxTipAmountCents: DEFAULT_MAX_TIP_CENTS,
      baseFareAmountCents: 0,
      selectedTipCents: MIN_RIDE_TIP_CENTS,
      submitting: false,
    };

    const RIDER_STATES = {
      HIDDEN: "hidden",
      SEARCHING: "searching",
      DRIVER_TO_PICKUP: "driver_to_pickup",
      PICKUP_PIN: "pickup_pin",
      IN_TRIP: "in_trip",
      DROPOFF_PIN: "dropoff_pin",
      RATE_TIP: "rate_tip",
      THANKS: "thanks"
    };

    let riderOverlayState = RIDER_STATES.HIDDEN;
    let selectedRating = 0;
    let ratingSubmitting = false;
    let rideTipRefreshTimer = null;
    let lastPaymentOverlayOptions = null;
    let isSyncConfirmOpen = false;
    let syncTipUsesCustom = false;
    let syncSelectedMembershipPlan = "basic";
    let syncMembershipUpgradeMode = false;
    let syncMembershipTermsAccepted = false;
    let syncConfirmBusyState = false;

    let isSignupMode = false;
    let currentUserProfile = null;

    let map;
    let directionsService;
    let directionsRenderer;
    let pickupMarker;
    let destMarker;
    let destinationGeocoder = null;
    const pickupOverrideState = {
      label: "",
      location: null
    };
    let destinationPreviewMap;
    let destinationPreviewPickupMarker;
    let destinationPreviewDestMarker;
    let driverMiniMap;
    let driverMiniMapDriverMarker;
    let driverMiniMapPickupMarker;
    let driverMiniMapDropoffMarker;
    let lastDriverMiniMapData = null;
    let currentLocation = null;
    let destinationLatLng = null;
    let destAutocomplete = null;
    let lastRideMetrics = null;
    let activeRideViewSection = "destination";
    let hasOnlineDrivers = false;
    let driverAvailabilityUnsub = null;
    let driverAvailabilityPollTimer = null;
    const DRIVER_AVAILABILITY_POLL_INTERVAL_MS = 20000;

    let activeRideUnsub = null;
    let activeGroupUnsub = null;
    let groupOccupancyUnsub = null;
    const WAITLIST_RIDE_STATUSES = new Set([
      "pending_driver",
      "pending",
      "pool_searching",
      "pooled_pending_driver"
    ]);
    const PAYMENT_STATUSES_REQUIRING_COLLECTION = new Set([
      "fare_due",
      "preauthorized",
      "preauth_pending",
      "pending", // legacy rides may still report pending until paid
      "pending_payment"
    ]);
    const MAX_EXTRA_STOPS = 3;
    let extraStopIdCounter = 0;
    const extraStopsState = [];
    const DRIVER_BUSY_STATUSES = [
      "driver_assigned",
      "arrived_at_pickup",
      "pickup_code_verified",
      "arrived_at_dropoff"
    ];
    let driverOnlineUnsub = null;
    let driverBusyUnsub = null;
    const driverAvailability = {
      onlineCount: 0,
      onlineIds: new Set(),
      busyDriverIds: new Set()
    };
    const WAITLIST_AVAILABLE_DRIVER_MINUTES = 2;
    const WAITLIST_BUSY_BASE_MINUTES = 3;
    const WAITLIST_PER_BUSY_DRIVER_MINUTES = 1.5;
    const WAITLIST_MAX_FALLBACK_MINUTES = 12;
    const WAITLIST_OFFLINE_MINUTES = 8;
    const WAITLIST_FALLBACK_REFRESH_THRESHOLD_MS = 15000;
    const waitlistState = {
      active: false,
      timerId: null,
      etaTargetTimestamp: null,
      etaSource: null
    };
    const RIDE_CHAT_ACTIVE_STATUSES = new Set([
      "driver_assigned",
      "driver_arrived",
      "arrived_at_pickup",
      "pickup_code_verified",
      "in_progress",
      "arrived_at_dropoff"
    ]);
    const RIDE_CHAT_TERMINAL_STATUSES = new Set([
      "dropoff_code_verified",
      "completed",
      "canceled",
      "canceled_by_driver",
      "canceled_by_rider",
      "driver_declined"
    ]);
    const RIDE_CHAT_MAX_LENGTH = 500;
    const RIDE_CHAT_RATE_LIMIT_MS = 1200;
    const RIDE_CHAT_FETCH_LIMIT = 200;
    let rideChatUnsub = null;
    let rideChatCurrentRideId = null;
    let rideChatLastSendAt = 0;

    let currentRideId = null;
    let currentRideStatus = null;
    let currentRideWatcher = null;
    let wantsGroupRide = false;
    let activeRideIsGroup = false;
    let lastRideCompletionContext = null;
    let cooldownOverlayUnlockAt = null;
    let cooldownOverlayTimerId = null;

    if (numRidersEl) {
      const handleGroupSelectionChange = () => updateGroupRideIntentFromSelect();
      numRidersEl.addEventListener("input", handleGroupSelectionChange);
      numRidersEl.addEventListener("change", handleGroupSelectionChange);
      updateGroupRideIntentFromSelect();
    } else {
      wantsGroupRide = false;
    }

    const ACTIVE_RIDE_STORAGE_KEY = "ridesync.activeRide.v1";
    const TERMINAL_RIDE_STATUSES = new Set([
      "completed",
      "canceled",
      "canceled_by_driver",
      "canceled_by_rider",
      "driver_declined",
      "expired",
      "payment_failed",
      "payment_canceled",
      "ride_timed_out",
      "no_show",
      "archived"
    ]);
    const MAX_RIDE_RESUME_AGE_MINUTES = 360;

    function normalizeRideStatusForProtection(value) {
      if (typeof value !== "string") return "";
      return value.trim().toLowerCase();
    }

    function persistProtectedRideState(state = {}) {
      if (!state?.rideId || !state?.userId) {
        return;
      }
      const payload = {
        rideId: state.rideId,
        userId: state.userId,
        status: state.status || null,
        toDestination: state.toDestination || null,
        isGroupRide: !!state.isGroupRide,
        poolType: state.poolType || null,
        cachedAt: Date.now()
      };
      try {
        if (window?.localStorage) {
          window.localStorage.setItem(
            ACTIVE_RIDE_STORAGE_KEY,
            JSON.stringify(payload)
          );
        }
      } catch (err) {
        console.warn("Ride protection persist failed", err);
      }
    }

    function loadProtectedRideState() {
      try {
        if (!window?.localStorage) return null;
        const raw = window.localStorage.getItem(ACTIVE_RIDE_STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (err) {
        console.warn("Ride protection load failed", err);
        return null;
      }
    }

    function clearProtectedRideState() {
      try {
        if (window?.localStorage) {
          window.localStorage.removeItem(ACTIVE_RIDE_STORAGE_KEY);
        }
      } catch (err) {
        console.warn("Ride protection clear failed", err);
      }
    }

    function rememberRideProtectionState(rideId, rideData = {}) {
      if (!rideId) return;
      if (!isRideResumeEligible(rideData)) {
        clearProtectedRideState();
        return;
      }
      const userId = rideData.userId || auth?.currentUser?.uid || null;
      if (!userId) return;
      const destinationLabel =
        rideData.toDestination ||
        rideData.destination ||
        rideData.destinationLabel ||
        rideData.fare?.membershipLabel ||
        null;
      const maxRiders = Number(
        rideData.maxRiders ?? rideData.currentRiderCount ?? 1
      );
      const protectionPayload = {
        rideId,
        userId,
        status: rideData.status || null,
        toDestination: destinationLabel,
        isGroupRide: rideData.isGroupRide === true || maxRiders > 1,
        guestBypassEnabled:
          rideData.guestBypassEnabled === true || maxRiders >= 3,
        poolType: rideData.poolType || null
      };
      persistProtectedRideState(protectionPayload);
    }

    const riderCancelableStatuses = new Set([
      "pending_driver",
      "pooled_pending_driver",
      "pool_searching",
      "driver_assigned",
      "driver_arrived",
      "pending"
    ]);
    const COOLDOWN_ELIGIBLE_PLANS = new Set(["uofa_unlimited", "nwa_unlimited"]);

    function updateCancelButtonVisibility() {
      if (!cancelRideButton) return;
      const hasRide = !!currentRideId;
      const cancelable =
        !currentRideStatus || riderCancelableStatuses.has(currentRideStatus);
      const shouldShow = hasRide && cancelable;
      cancelRideButton.hidden = !shouldShow;
      if (!shouldShow && cancelError) {
        cancelError.textContent = "";
      }
    }

    function setRideViewPanel(targetKey) {
      if (!targetKey || !rideViewPanels.length) return;
      activeRideViewSection = targetKey;
      rideViewTabs.forEach((tab) => {
        if (!tab?.dataset?.viewTab) return;
        const isActive = tab.dataset.viewTab === targetKey;
        tab.classList.toggle("active", isActive);
        tab.setAttribute("aria-selected", isActive ? "true" : "false");
        tab.setAttribute("tabindex", isActive ? "0" : "-1");
      });
      rideViewPanels.forEach((panel) => {
        if (!panel?.dataset?.viewPanel) return;
        const isActive = panel.dataset.viewPanel === targetKey;
        panel.classList.toggle("active", isActive);
        panel.setAttribute("aria-hidden", isActive ? "false" : "true");
      });
      if (targetKey === "destination") {
        setTimeout(() => {
          if (destinationPreviewMap && window.google?.maps) {
            google.maps.event.trigger(destinationPreviewMap, "resize");
          }
          updateTripPreviewMap();
        }, 80);
      }
    }

    if (rideViewTabs.length && rideViewPanels.length) {
      rideViewTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          const key = tab.dataset?.viewTab;
          if (key && key !== activeRideViewSection) {
            setRideViewPanel(key);
          }
        });
      });
    }

    updateCancelButtonVisibility();

    function clearCurrentRideState() {
        currentRideId = null;
        currentRideStatus = null;
        if (currentRideWatcher) {
          currentRideWatcher();
          currentRideWatcher = null;
        }
        if (activeRideUnsub) {
          activeRideUnsub();
          activeRideUnsub = null;
        }
        if (activeGroupUnsub) {
          activeGroupUnsub();
          activeGroupUnsub = null;
        }
        teardownRideChat(true);
        deactivateWaitlistPanel();
        hideGroupQr();
        activeRideIsGroup = false;
        activeRideGuestBypass = false;
        appBody?.classList?.remove("host-guest-bypass");
        updateGuestBypassCopy();
        refreshGroupQrVisibility();
        updateSyncRidersButtonVisibility();
        updateCancelButtonVisibility();
        closeRideFareOverlay(true);
        resetFinalTipUi();
        clearProtectedRideState();
        syncRidersFlowActive = false;
        syncRidersAwaitingRideActivation = false;
        syncRidersJoinUrl = "";
        updateSyncRidersOccupancyLabel("");
        closeSyncRidersOverlay();
        disableJoinGuestBypassUi({ force: true });
      }

      function resetJoinModeUi() {
        joinMode = false;
        joinTargetRide = null;
        if (joinBanner) joinBanner.style.display = "none";
        if (ridersSection) ridersSection.style.display = "block";
        if (numRidersEl) {
          numRidersEl.disabled = false;
        }
        updateSyncButtonLabel();
        disableJoinGuestBypassUi({ force: true });
      }

      function returnToHomeAfterRide(message = "", isError = false) {
        clearCurrentRideState();
        setRiderOverlayState(RIDER_STATES.HIDDEN);
        supportPanel?.classList.remove("active");
        if (rideSummary) rideSummary.style.display = "none";
        showRideView();
        clearPoolGroupUI();
        resetJoinModeUi();
        hideGroupQr();
        resetTripPlanner();
        resetRatingForm();
        if (cancelError) cancelError.textContent = "";

        if (isError) {
          profileError.textContent = message || "";
          profileMessage.textContent = "";
        } else {
          profileMessage.textContent = message || "";
          profileError.textContent = "";
        }
      resetFinalTipUi();
      maybeShowPostRideCooldown();
    }

    function extractRideCompletionTime(data) {
      if (!data) return new Date();
      const candidates = [
        data.completedAt,
        data.dropoffCompletedAt,
        data.dropoffCodeVerifiedAt,
        data.updatedAt
      ];
      for (const candidate of candidates) {
        if (!candidate) continue;
        if (typeof candidate.toDate === "function") {
          return candidate.toDate();
        }
        if (candidate instanceof Date) {
          return candidate;
        }
        if (typeof candidate === "number") {
          return new Date(candidate);
        }
      }
      return new Date();
    }

    function rememberRideCompletionContext(status, data) {
      if (status !== "dropoff_code_verified" && status !== "completed") {
        lastRideCompletionContext = null;
        return;
      }
      const plan = normalizePlanKey(
        data?.membershipType ||
          currentUserProfile?.membershipType ||
          currentUserProfile?.membership ||
          "basic"
      );
      if (!COOLDOWN_ELIGIBLE_PLANS.has(plan)) {
        lastRideCompletionContext = null;
        return;
      }
      lastRideCompletionContext = {
        plan,
        completedAt: extractRideCompletionTime(data)
      };
    }

    function stopCooldownOverlayTimer() {
      if (cooldownOverlayTimerId) {
        clearInterval(cooldownOverlayTimerId);
        cooldownOverlayTimerId = null;
      }
    }

    function hideCooldownOverlay() {
      stopCooldownOverlayTimer();
      cooldownOverlayUnlockAt = null;
      if (cooldownOverlay) {
        cooldownOverlay.classList.remove("active");
        cooldownOverlay.setAttribute("aria-hidden", "true");
      }
    }

    function formatCooldownRemaining(ms) {
      const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
      const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
      const seconds = String(totalSeconds % 60).padStart(2, "0");
      return `${minutes}:${seconds}`;
    }

    function tickCooldownOverlay() {
      if (!cooldownOverlayUnlockAt || !cooldownTimerValue) return;
      const remainingMs = cooldownOverlayUnlockAt - Date.now();
      if (remainingMs <= 0) {
        cooldownTimerValue.textContent = "00:00";
        hideCooldownOverlay();
        return;
      }
      cooldownTimerValue.textContent = formatCooldownRemaining(remainingMs);
    }

    function showCooldownOverlay(options) {
      if (!cooldownOverlay) return;
      const { planLabel, unlockAt, coolMinutes } = options;
      cooldownOverlayUnlockAt = unlockAt;
      if (cooldownLabelEl) {
        cooldownLabelEl.textContent = `${planLabel} cooldown`;
      }
      if (cooldownTitleEl) {
        cooldownTitleEl.textContent = "Next ride unlocks in";
      }
      if (cooldownSubtitleEl) {
        const minuteLabel = coolMinutes === 1 ? "minute" : "minutes";
        cooldownSubtitleEl.textContent = `Hang tight for about ${coolMinutes} ${minuteLabel}.`;
      }
      if (cooldownHintText) {
        cooldownHintText.textContent = `${planLabel} riders take a short break between trips so everyone gets a driver.`;
      }
      cooldownOverlay.classList.add("active");
      cooldownOverlay.setAttribute("aria-hidden", "false");
      tickCooldownOverlay();
      if (!cooldownOverlayTimerId) {
        cooldownOverlayTimerId = window.setInterval(tickCooldownOverlay, 1000);
      }
    }

    function maybeShowPostRideCooldown() {
      if (!lastRideCompletionContext) return;
      const context = lastRideCompletionContext;
      lastRideCompletionContext = null;
      const coolMinutes = SURGE_MODE ? SURGE_COOLDOWN_MINUTES : UNLIMITED_COOLDOWN_MINUTES;
      if (!coolMinutes || coolMinutes <= 0) {
        hideCooldownOverlay();
        return;
      }
      if (!COOLDOWN_ELIGIBLE_PLANS.has(context.plan)) {
        hideCooldownOverlay();
        return;
      }
      const unlockAt = context.completedAt.getTime() + coolMinutes * 60000;
      const remainingMs = unlockAt - Date.now();
      if (remainingMs <= 0) {
        hideCooldownOverlay();
        return;
      }
      const planLabel = formatMembershipPlanLabel(context.plan);
      showCooldownOverlay({ planLabel, unlockAt, coolMinutes });
    }

    function safeImageUrl(url) {
      if (!url && url !== 0) return null;
      const value = String(url).trim();
      if (!value || value === "null" || value === "undefined") return null;
      return value;
    }

    function applyImage(imgEl, fallbackEl, url, placeholder) {
      if (!imgEl) return;
      const finalUrl = safeImageUrl(url);
      const hasRealImage = !!finalUrl;
      const source = hasRealImage ? finalUrl : (placeholder || null);
      if (source) {
        imgEl.src = source;
        imgEl.style.display = "block";
        imgEl.onerror = () => {
          imgEl.onerror = null;
          if (placeholder) {
            imgEl.src = placeholder;
          }
        };
        if (fallbackEl) {
          fallbackEl.style.display = hasRealImage ? "none" : "flex";
        }
      } else {
        imgEl.removeAttribute("src");
        imgEl.style.display = "none";
        if (fallbackEl) {
          fallbackEl.style.display = "flex";
        }
      }
    }

    function parseLatLngCandidate(value) {
      if (!value) return null;
      if (typeof value.lat === "number" && typeof value.lng === "number") {
        return { lat: value.lat, lng: value.lng };
      }
      if (typeof value.latitude === "number" && typeof value.longitude === "number") {
        return { lat: value.latitude, lng: value.longitude };
      }
      return null;
    }

    function extractLatLngFromPairs(target, pairs) {
      for (const [latKey, lngKey] of pairs) {
        const lat = target?.[latKey];
        const lng = target?.[lngKey];
        if (typeof lat === "number" && typeof lng === "number") {
          return { lat, lng };
        }
      }
      return null;
    }

    function extractPickupLocationFromRide(data) {
      if (!data) return null;
      const candidates = [
        data.pickupLocation,
        data.fromLocation,
        data.originLocation,
        data.pickupGeo,
        data.pickupCoordinates,
        data.fromCoordinates
      ];
      for (const candidate of candidates) {
        const parsed = parseLatLngCandidate(candidate);
        if (parsed) return parsed;
      }
      return extractLatLngFromPairs(data, [
        ["pickupLat", "pickupLng"],
        ["fromLat", "fromLng"],
        ["originLat", "originLng"]
      ]);
    }

    function extractDropoffLocationFromRide(data) {
      if (!data) return null;
      const candidates = [
        data.dropoffLocation,
        data.toLocation,
        data.destinationLocation,
        data.destLocation,
        data.dropoffGeo,
        data.toCoordinates,
        data.destCoordinates
      ];
      for (const candidate of candidates) {
        const parsed = parseLatLngCandidate(candidate);
        if (parsed) return parsed;
      }
      return extractLatLngFromPairs(data, [
        ["dropoffLat", "dropoffLng"],
        ["destLat", "destLng"],
        ["toLat", "toLng"],
        ["destinationLat", "destinationLng"]
      ]);
    }

    function extractDriverLocation(data) {
      if (!data) return null;
      const candidates = [
        data.driverLocation,
        data.driverCurrentLocation,
        data.currentDriverLocation
      ];
      for (const candidate of candidates) {
        const parsed = parseLatLngCandidate(candidate);
        if (parsed) return parsed;
      }
      return extractLatLngFromPairs(data, [
        ["driverLat", "driverLng"],
        ["driverLatitude", "driverLongitude"],
        ["driverCurrentLat", "driverCurrentLng"]
      ]);
    }

    function formatPhoneDisplay(phone) {
      if (!phone) return "";
      const digits = phone.replace(/\D/g, "");
      if (!digits) return "";
      let clean = digits;
      if (clean.length === 11 && clean.startsWith("1")) {
        clean = clean.slice(1);
      }
      if (clean.length === 10) {
        return `(${clean.slice(0, 3)}) ${clean.slice(3, 6)}-${clean.slice(6)}`;
      }
      return phone;
    }

    function renderDriverBadges(data) {
      if (!driverIdentityBadgesEl) return;
      const badges = [];
      if (data?.driverVerifiedId) badges.push("Verified ID");
      if (data?.driverDrugTestCleared) badges.push("Drug Test Cleared");
      if (data?.driverBackgroundCheckCleared) badges.push("Background Check Cleared");
      if (badges.length) {
        driverIdentityBadgesEl.innerHTML = badges
          .map((label) => `<span class="driver-badge-pill">${label}</span>`)
          .join("");
        driverIdentityBadgesEl.style.display = "flex";
      } else {
        driverIdentityBadgesEl.innerHTML = "";
        driverIdentityBadgesEl.style.display = "none";
      }
    }

    function renderDriverIdentity(data) {
      if (!driverIdentityCardEl) return;
      const name = data?.driverName || "RideSync driver";
      driverIdentityNameEl.textContent = name;

      const avatarUrl =
        safeImageUrl(data?.driverAvatarUrl) ||
        safeImageUrl(data?.driverPhotoUrl) ||
        safeImageUrl(data?.driverProfilePicUrl);
      applyImage(driverIdentityAvatarImg, driverIdentityAvatarFallback, avatarUrl, DRIVER_PLACEHOLDER_AVATAR);
      if (driverIdentityAvatarFallback) {
        const initials = name
          .split(" ")
          .filter(Boolean)
          .map((part) => part[0])
          .join("")
          .slice(0, 2)
          .toUpperCase() || "RS";
        driverIdentityAvatarFallback.textContent = initials;
      }

      const ratingValue = Number(data?.driverRating);
      const hasRating = !Number.isNaN(ratingValue) && ratingValue > 0;
      if (hasRating) {
        driverIdentityRatingEl.textContent = `★ ${ratingValue.toFixed(1)}`;
        driverIdentityRatingEl.style.display = "inline-flex";
        const rideCount = Number(data?.driverRatingCount);
        driverIdentityStatusEl.textContent = rideCount
          ? `${rideCount}+ RideSync trips`
          : "RideSync trusted";
      } else {
        driverIdentityRatingEl.style.display = "none";
        driverIdentityStatusEl.textContent = "New RideSync driver";
      }

      const rawPhone = data?.driverPhone || data?.driverPhoneNumber;
      const formattedPhone = formatPhoneDisplay(rawPhone || "");
      if (formattedPhone) {
        driverIdentityPhoneEl.textContent = `Call or text ${formattedPhone}`;
        driverIdentityPhoneRow?.classList.remove("hidden");
      } else if (data?.driverContactViaRideSync) {
        driverIdentityPhoneEl.textContent = "Contact RideSync support";
        driverIdentityPhoneRow?.classList.remove("hidden");
      } else {
        driverIdentityPhoneEl.textContent = "";
        driverIdentityPhoneRow?.classList.add("hidden");
      }

      if (driverIdentityEtaEl) {
        const statusCopy = friendlyDriverStatus(data);
        const etaCopy = formatDriverEtaText(data);
        const combined = [statusCopy, etaCopy].filter(Boolean).join(" • ");
        if (combined) {
          driverIdentityEtaEl.textContent = combined;
          driverIdentityEtaEl.style.display = "block";
        } else {
          driverIdentityEtaEl.textContent = "";
          driverIdentityEtaEl.style.display = "none";
        }
      }

      renderDriverBadges(data);
    }

    function buildVehicleName(data) {
      if (data?.driverVehicleName) return data.driverVehicleName;
      if (data?.driverVehicleDisplayName) return data.driverVehicleDisplayName;
      const parts = [
        data?.driverVehicleYear,
        data?.driverVehicleColor,
        data?.driverVehicleMake,
        data?.driverVehicleModel
      ].filter(Boolean);
      return parts.join(" ").replace(/\s+/g, " ").trim();
    }

    function renderVehicleSection(data) {
      if (!driverVehicleSection) return;
      const vehicleName = buildVehicleName(data);
      const plate = data?.driverVehiclePlate || data?.driverLicensePlate;
      const photoUrl = data?.driverVehiclePhotoUrl || data?.driverVehiclePhoto;
      const hasAny =
        vehicleName ||
        plate ||
        safeImageUrl(photoUrl);
      if (!hasAny) {
        driverVehicleSection.style.display = "none";
        return;
      }
      driverVehicleSection.style.display = "block";
      applyImage(driverVehiclePhotoImg, driverVehicleFallbackEl, photoUrl, VEHICLE_PLACEHOLDER_IMG);
      driverVehicleNameEl.textContent = vehicleName || "Vehicle verified with RideSync";
      driverVehiclePlateEl.textContent = plate ? `Plate: ${plate}` : "";
      driverVehiclePlateEl.style.display = plate ? "block" : "none";
      driverVehicleNoteEl.textContent = !vehicleName && !plate ? "Vehicle verified with RideSync" : "";
      driverVehicleNoteEl.style.display = driverVehicleNoteEl.textContent ? "block" : "none";
    }

    function renderLicenseSection(data) {
      if (!driverLicenseSection) return;
      const licenseSummary =
        data?.driverLicenseSummary ||
        data?.driverLicenseStatus ||
        (data?.driverLicenseVerified ? "License verified with RideSync" : "");
      const licenseMeta = data?.driverLicenseMeta || (data?.driverLicenseLast4 ? `Ending in ${data.driverLicenseLast4}` : "");
      const photoUrl = data?.driverLicenseImageUrl || data?.driverLicensePhotoUrl;
      const hasAny = licenseSummary || licenseMeta || safeImageUrl(photoUrl);
      if (!hasAny) {
        driverLicenseSection.style.display = "none";
        return;
      }
      driverLicenseSection.style.display = "block";
      applyImage(driverLicensePhotoImg, driverLicenseFallbackEl, photoUrl, LICENSE_PLACEHOLDER_IMG);
      driverLicenseSummaryEl.textContent = licenseSummary || "License verified with RideSync";
      driverLicenseMetaEl.textContent = licenseMeta || "";
      driverLicenseMetaEl.style.display = licenseMeta ? "block" : "none";
    }

    function ensureDriverMiniMap() {
      if (googleMapsLoadFailed) return false;
      if (!driverMiniMapEl) return false;
      if (!window.google || !google.maps) return false;
      if (!driverMiniMap) {
        driverMiniMap = new google.maps.Map(driverMiniMapEl, {
          center: { lat: 36.0626, lng: -94.1574 },
          zoom: 13,
          disableDefaultUI: true,
          gestureHandling: "none",
          clickableIcons: false
        });
        driverMiniMapDriverMarker = new google.maps.Marker({
          map: driverMiniMap,
          visible: false,
          zIndex: 3,
          icon: {
            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
            scale: 5,
            fillColor: "#f97316",
            fillOpacity: 1,
            strokeColor: "#fed7aa",
            strokeWeight: 1
          }
        });
        driverMiniMapPickupMarker = new google.maps.Marker({
          map: driverMiniMap,
          visible: false,
          zIndex: 2,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 6,
            fillColor: "#22c55e",
            fillOpacity: 1,
            strokeColor: "#022c22",
            strokeWeight: 2
          }
        });
        driverMiniMapDropoffMarker = new google.maps.Marker({
          map: driverMiniMap,
          visible: false,
          zIndex: 1,
          icon: "https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png"
        });
      }
      return true;
    }

    function setDriverMiniMapStatus(message) {
      if (!driverMiniMapShell || !driverMiniMapStatusEl) return;
      if (message) {
        driverMiniMapShell.classList.add("show-status");
        driverMiniMapStatusEl.textContent = message;
      } else {
        driverMiniMapShell.classList.remove("show-status");
        driverMiniMapStatusEl.textContent = "";
      }
    }

    function updateDriverMiniMap(data) {
      if (data) {
        lastDriverMiniMapData = data;
      } else if (lastDriverMiniMapData) {
        data = lastDriverMiniMapData;
      } else {
        return;
      }
      if (!driverMiniMapShell) return;

      const status = (data?.status || "").toLowerCase();
      const shouldShow =
        status === "driver_assigned" ||
        status === "driver_arrived" ||
        status === "pickup_code_verified" ||
        status === "in_progress";

      if (!shouldShow) {
        driverMiniMapShell.style.display = "none";
        setDriverMiniMapStatus("");
        return;
      }

      driverMiniMapShell.style.display = "block";

      if (!ensureDriverMiniMap()) {
        setDriverMiniMapStatus(googleMapsLoadFailed ? "Maps unavailable." : "Loading map…");
        return;
      }

      const driverLoc = extractDriverLocation(data);
      const pickupLoc = extractPickupLocationFromRide(data);
      const dropoffLoc = extractDropoffLocationFromRide(data);

      if (!driverLoc) {
        setDriverMiniMapStatus("Waiting for driver location…");
      } else {
        setDriverMiniMapStatus("");
      }

      if (driverMiniMapDriverMarker) {
        driverMiniMapDriverMarker.setVisible(!!driverLoc);
        if (driverLoc) {
          driverMiniMapDriverMarker.setPosition(driverLoc);
          const heading =
            typeof data?.driverHeading === "number"
              ? data.driverHeading
              : typeof data?.driverHeadingDeg === "number"
              ? data.driverHeadingDeg
              : null;
          if (heading != null && driverMiniMapDriverMarker.getIcon()) {
            const icon = { ...driverMiniMapDriverMarker.getIcon(), rotation: heading };
            driverMiniMapDriverMarker.setIcon(icon);
          }
        }
      }

      if (driverMiniMapPickupMarker) {
        driverMiniMapPickupMarker.setVisible(!!pickupLoc);
        if (pickupLoc) {
          driverMiniMapPickupMarker.setPosition(pickupLoc);
        }
      }

      if (driverMiniMapDropoffMarker) {
        driverMiniMapDropoffMarker.setVisible(!!dropoffLoc);
        if (dropoffLoc) {
          driverMiniMapDropoffMarker.setPosition(dropoffLoc);
        }
      }

      const bounds = new google.maps.LatLngBounds();
      let hasBounds = false;
      [driverLoc, pickupLoc, dropoffLoc].forEach((loc) => {
        if (loc) {
          bounds.extend(loc);
          hasBounds = true;
        }
      });

      if (hasBounds) {
        driverMiniMap.fitBounds(bounds, 30);
      } else {
        driverMiniMap.setCenter({ lat: 36.0626, lng: -94.1574 });
        driverMiniMap.setZoom(12);
      }
    }

    function refreshDriverMiniMap() {
      if (!driverMiniMap || !driverMiniMapShell || driverMiniMapShell.style.display === "none") {
        return;
      }
      google.maps.event.trigger(driverMiniMap, "resize");
      updateDriverMiniMap();
    }

    function friendlyDriverStatus(data) {
      if (!data?.status) return "";
      if (data.status === "driver_arrived") return "Driver has arrived";
      if (data.status === "driver_assigned") return "Driver en route to pickup";
      if (data.status === "in_progress") return "Ride in progress";
      if (data.status === "completed") return "Ride completed";
      return data.status.replaceAll("_", " ");
    }

    function formatDriverEtaText(data) {
      if (!data) return "";
      if (typeof data.driverEtaMinutes === "number") {
        const eta = Math.max(0, data.driverEtaMinutes);
        return eta < 1 ? "Less than a minute away" : `Approx. ${Math.round(eta)} min away`;
      }
      if (typeof data.remainingEtaMinutes === "number") {
        const remaining = Math.max(0, data.remainingEtaMinutes);
        return remaining < 1 ? "Almost there" : `About ${Math.round(remaining)} min remaining`;
      }
      return formatTripEstimate(data) || "";
    }

    function showAuthView() {
      authView.classList.add("active");
      rideView.classList.remove("active");
      loadingView.classList.remove("active");
    }
    function showRideView() {
      authView.classList.remove("active");
      rideView.classList.add("active");
      loadingView.classList.remove("active");
    }
    function showLoadingView() {
      authView.classList.remove("active");
      rideView.classList.remove("active");
      loadingView.classList.add("active");
    }

    function setMembershipBadge(profile) {
      const plan = normalizePlanKey(profile?.membershipType || profile?.membership);
      const isStudent = !!profile?.isStudent;
      const uofaVerified = !!profile?.uofaVerified;
      const tier = resolvePlanTier(plan);
      const badgeLabel =
        MEMBERSHIP_TIER_DETAILS[tier]?.label ||
        MEMBERSHIP_TIER_DETAILS[MEMBERSHIP_TIER_KEYS.BASIC].label;
      const defaultTag =
        MEMBERSHIP_TIER_DETAILS[tier]?.badgeTag || "";

      membershipBadgeEl.className = "badge";
      membershipBadgeLabelEl.textContent = badgeLabel;
      membershipBadgeTagEl.textContent = defaultTag;

      if (plan === "uofa_unlimited") {
        membershipBadgeEl.classList.add("badge-uofa");
        membershipBadgeTagEl.textContent = profile?.membershipStatus === "pending_verification"
          ? "Pending approval"
          : uofaVerified
          ? "Verified student"
          : isStudent
          ? "Student (pending ID)"
          : defaultTag;
      } else if (plan === "nwa_unlimited") {
        membershipBadgeEl.classList.add("badge-nwa");
        membershipBadgeTagEl.textContent = defaultTag;
      } else {
        membershipBadgeEl.classList.add("badge-basic");
        membershipBadgeTagEl.textContent = defaultTag;
      }
    }

    function formatCurrencyFromCents(amountCents = 0, currency = "usd") {
      const value = Number(amountCents || 0) / 100;
      try {
        return new Intl.NumberFormat("en-US", {
          style: "currency",
          currency: (currency || "usd").toUpperCase(),
        }).format(value);
      } catch (err) {
        return `$${value.toFixed(2)}`;
      }
    }

    function clampTipAmount(valueCents, minCents = MIN_RIDE_TIP_CENTS, maxCents = DEFAULT_MAX_TIP_CENTS) {
      const normalized = Number.isFinite(valueCents) ? Math.round(valueCents) : 0;
      const safeMin = Math.max(MIN_RIDE_TIP_CENTS, Math.round(minCents));
      const safeMax = Math.max(safeMin, Math.round(maxCents));
      return Math.min(Math.max(normalized, safeMin), safeMax);
    }

    function dollarsToCents(value) {
      if (!Number.isFinite(Number(value))) {
        return 0;
      }
      return Math.round(Number(value) * 100);
    }

    function formatPlanPriceLabel(planKey) {
      const key = normalizePlanKey(planKey);
      return (
        stripeMembershipConfig?.[key]?.priceDisplay ||
        MEMBERSHIP_PLAN_COPY[key]?.price ||
        MEMBERSHIP_PLAN_COPY.basic.price
      );
    }

    function resolvePlanPriceCents(planKey) {
      const key = normalizePlanKey(planKey);
      const configValue = stripeMembershipConfig?.[key]?.priceCents;
      if (Number.isFinite(configValue)) {
        return Math.max(0, Math.round(configValue));
      }
      const fallbackValue = MEMBERSHIP_PLAN_COPY[key]?.priceCents;
      if (Number.isFinite(fallbackValue)) {
        return Math.max(0, Math.round(fallbackValue));
      }
      return 0;
    }

    function updateMembershipPrices() {
      if (!membershipPriceEls || typeof membershipPriceEls.forEach !== "function") {
        return;
      }
      membershipPriceEls.forEach((node) => {
        const planKey = node?.dataset?.planPrice;
        if (!planKey) return;
        node.textContent = formatPlanPriceLabel(planKey);
      });
    }

    updateMembershipPrices();

    function canStartMembershipCheckout(planKey, profile = currentUserProfile) {
      if (!STRIPE_ENABLED || !profile) {
        return false;
      }
      const normalized = normalizePlanKey(planKey);
      if (normalized === "uofa_unlimited") {
        return !!(profile.isStudent && profile.uofaVerified);
      }
      if (normalized === "nwa_unlimited") {
        return true;
      }
      return false;
    }

    function getMembershipPlanDisabledReason(
      planKey,
      profile = currentUserProfile
    ) {
      const normalized = normalizePlanKey(planKey);
      if (!profile) {
        return "Sign in to manage memberships.";
      }
      if (normalized === "uofa_unlimited") {
        if (!profile.isStudent) {
          return "Mark yourself as a U of A student in your profile.";
        }
        if (!profile.uofaVerified) {
          return "Upload your student ID so RideSync can verify you.";
        }
      }
      if (normalized === "nwa_unlimited") {
        return "Contact RideSync support if you need help unlocking this plan.";
      }
      return "Contact RideSync support to manage this plan.";
    }

    function resolveMembershipActionCopy(
      planKey,
      profile = currentUserProfile
    ) {
      const normalized = normalizePlanKey(planKey);
      const planLabel = formatMembershipPlanLabel(normalized);
      const planMode = getMembershipPlanMode(normalized);
      const currentPlan = normalizePlanKey(
        profile?.membershipType || profile?.membership || "basic"
      );
      const status = (profile?.membershipStatus || "none").toLowerCase();
      const response = {
        label: `Activate ${planLabel}`,
        disabled: false,
        hint: "",
      };

      if (!STRIPE_ENABLED) {
        response.label = "Payments unavailable";
        response.disabled = true;
        response.hint = "Stripe payments are offline. Try again shortly.";
        return response;
      }

      if (planMode === "none") {
        response.label = "Contact support";
        response.disabled = true;
        response.hint = "RideSync support can help you manage this plan.";
        return response;
      }

      if (!profile) {
        response.label = "Sign in to activate";
        response.disabled = true;
        response.hint = "Load your RideSync profile to manage memberships.";
        return response;
      }

      if (
        membershipCheckoutState.status === "redirecting" &&
        membershipCheckoutState.activePlan === normalized
      ) {
        response.label = "Opening Stripe…";
        response.disabled = true;
        response.hint = "Hang tight while we redirect you to Stripe Checkout.";
        return response;
      }

      if (!canStartMembershipCheckout(normalized, profile)) {
        response.label = "Verification required";
        response.disabled = true;
        response.hint = getMembershipPlanDisabledReason(normalized, profile);
        return response;
      }

      if (currentPlan === normalized) {
        if (status === "active") {
          response.label = "Plan active";
          response.disabled = true;
          response.hint = `${planLabel} is active.`;
          return response;
        }
        if (status === "pending_verification") {
          response.label = "Awaiting approval";
          response.disabled = true;
          response.hint =
            "RideSync is verifying your student ID. You'll be notified once it's active.";
          return response;
        }
        response.label = "Renew membership";
        response.disabled = false;
        response.hint = "Restart your unlimited coverage through Stripe.";
        return response;
      }

      response.label =
        normalized === "uofa_unlimited"
          ? "Review U of A Unlimited"
          : "Review NWA Unlimited";
      response.disabled = false;
      response.hint =
        "Opens a checkout panel so you can compare one-time fares with unlimited savings before Stripe.";
      return response;
    }

    function updateMembershipPlanButtons(profile = currentUserProfile) {
      if (!membershipPlanButtons.size) {
        return;
      }
      membershipPlanButtons.forEach((button, planKey) => {
        const ui = resolveMembershipActionCopy(planKey, profile);
        button.textContent = ui.label;
        button.disabled = !!ui.disabled;
        button.setAttribute("aria-disabled", ui.disabled ? "true" : "false");
        const hintEl = membershipPlanHints.get(planKey);
        if (hintEl) {
          hintEl.textContent = ui.hint || "";
          hintEl.style.display = ui.hint ? "" : "none";
        }
      });
      if (membershipPlanCards.length && profile) {
        const profilePlan = normalizePlanKey(
          profile.membershipType || profile.membership || "basic"
        );
        membershipPlanCards.forEach((card) => {
          const planKey = normalizePlanKey(card.dataset.plan);
          card.classList.toggle("active", planKey === profilePlan);
        });
      }
    }

    function handleMembershipPlanAction(planKey) {
      const normalized = normalizePlanKey(planKey);
      if (!STRIPE_ENABLED) {
        setMembershipMessage("Stripe payments are not available right now.");
        return;
      }
      const planMode = getMembershipPlanMode(normalized);
      if (planMode === "none") {
        setMembershipMessage("Contact RideSync support to manage this plan.");
        return;
      }
      if (!canStartMembershipCheckout(normalized)) {
        setMembershipMessage(getMembershipPlanDisabledReason(normalized));
        return;
      }
      const user = auth.currentUser;
      if (!user) {
        setMembershipMessage("Sign in to manage memberships.");
        return;
      }
      membershipCheckoutState.activePlan = normalized;
      membershipCheckoutState.status = "ready";
      membershipCheckoutState.processing = false;
      openMembershipCheckoutOverlay(normalized);
      setMembershipMessage("Compare plans before redirecting to Stripe.");
    }

    function planRequiresStripeCheckout(planKey) {
      const mode = getMembershipPlanMode(planKey);
      return mode === "subscription" || mode === "payment";
    }

    function setMembershipCheckoutError(message) {
      if (membershipCheckoutError) {
        membershipCheckoutError.textContent = message || "";
      }
    }

    function updateMembershipCheckoutSummary() {
      if (!membershipCheckoutPrice || !membershipCheckoutButton) return;
      const selectedPlan =
        membershipCheckoutState.selectedPlan || getProfilePlanKey() || "basic";
      membershipCheckoutPrice.textContent = formatPlanPriceLabel(selectedPlan);
      if (membershipCheckoutHint) {
        membershipCheckoutHint.textContent =
          selectedPlan === "basic"
            ? "Stick with pay-per-ride pricing. Stripe will prompt you after each trip."
            : "Upgrade now to unlock unlimited coverage. We'll send you to Stripe Checkout.";
      }
      const requiresCheckout = planRequiresStripeCheckout(selectedPlan);
      membershipCheckoutButton.disabled =
        !requiresCheckout || membershipCheckoutState.processing;
      membershipCheckoutButton.textContent = membershipCheckoutState.processing
        ? "Preparing Stripe…"
        : requiresCheckout
        ? "Checkout with Stripe"
        : "Pay per ride at checkout";
    }

    function renderMembershipCheckoutOptions() {
      if (!membershipCheckoutOptions) return;
      const plans = ["basic", "uofa_unlimited", "nwa_unlimited"];
      const selectedPlan =
        membershipCheckoutState.selectedPlan || getProfilePlanKey() || "basic";
      const fragment = document.createDocumentFragment();
      plans.forEach((planKey) => {
        const planCopy =
          MEMBERSHIP_PLAN_COPY[planKey] || MEMBERSHIP_PLAN_COPY.basic;
        const button = document.createElement("button");
        button.type = "button";
        button.dataset.membershipOption = planKey;
        button.className = "membership-plan membership-plan-card checkout-option";
        button.setAttribute("role", "radio");
        button.setAttribute("aria-checked", selectedPlan === planKey ? "true" : "false");
        const selectable = planKey === "basic" || isPlanSelectable(planKey);
        if (!selectable) {
          button.disabled = true;
          button.classList.add("disabled");
        }
        if (selectedPlan === planKey) {
          button.classList.add("active");
        }
        const lockReason = !selectable ? getPlanLockReason(planKey) : "";
        const planHint =
          planKey === "basic"
            ? "Keep paying per ride with standard fares."
            : lockReason ||
              "Unlimited riders only pay tips after each trip.";
        button.innerHTML = `
          <div class="membership-plan-title">${planCopy.label}</div>
          <div class="membership-plan-price">${formatPlanPriceLabel(planKey)}</div>
          <p class="membership-plan-desc">${planCopy.description}</p>
          <p class="membership-plan-desc">${planHint}</p>
        `;
        fragment.appendChild(button);
      });
      membershipCheckoutOptions.innerHTML = "";
      membershipCheckoutOptions.appendChild(fragment);
    }

    function selectMembershipCheckoutPlan(planKey) {
      membershipCheckoutState.selectedPlan = normalizePlanKey(planKey || "basic");
      setMembershipCheckoutError("");
      renderMembershipCheckoutOptions();
      updateMembershipCheckoutSummary();
    }

    function openMembershipCheckoutOverlay(initialPlan) {
      if (!membershipCheckoutOverlay) return;
      const fallbackPlan = getProfilePlanKey() || "basic";
      const normalized = normalizePlanKey(initialPlan || fallbackPlan);
      membershipCheckoutState.selectedPlan = normalized;
      membershipCheckoutState.status = "ready";
      membershipCheckoutState.activePlan = null;
      membershipCheckoutState.processing = false;
      setMembershipCheckoutError("");
      renderMembershipCheckoutOptions();
      updateMembershipCheckoutSummary();
      toggleOverlay(membershipCheckoutOverlay, true, membershipCheckoutClose);
    }

    function closeMembershipCheckoutOverlay() {
      if (!membershipCheckoutOverlay) return;
      membershipCheckoutState.processing = false;
      membershipCheckoutState.status = "idle";
      membershipCheckoutState.selectedPlan = null;
      membershipCheckoutState.activePlan = null;
      toggleOverlay(membershipCheckoutOverlay, false);
      setMembershipCheckoutError("");
      updateMembershipPlanButtons(currentUserProfile);
      setMembershipMessage("");
    }

    async function startMembershipCheckout() {
      const planKey =
        membershipCheckoutState.selectedPlan || getProfilePlanKey() || "basic";
      if (!planRequiresStripeCheckout(planKey)) {
        setMembershipMessage(
          "Basic rides are billed from your fare overlay. No membership checkout needed."
        );
        closeMembershipCheckoutOverlay();
        return;
      }
      if (!canStartMembershipCheckout(planKey)) {
        setMembershipCheckoutError(getMembershipPlanDisabledReason(planKey));
        return;
      }
      membershipCheckoutState.processing = true;
      membershipCheckoutState.status = "redirecting";
      membershipCheckoutState.activePlan = planKey;
      updateMembershipPlanButtons(currentUserProfile);
      updateMembershipCheckoutSummary();
      setMembershipCheckoutError("");
      logStripeDebug("membership_checkout_start", {
        plan: planKey,
        mode: getMembershipPlanMode(planKey),
      });
      showPaymentRedirectOverlay("Redirecting you to Stripe Checkout…");
      try {
        const redirectBaseUrl =
          typeof window !== "undefined" && window.location?.origin
            ? window.location.origin
            : undefined;
        const response = await createMembershipCheckoutSessionFn({
          plan: planKey,
          planId: planKey,
          mode: getMembershipPlanMode(planKey),
          redirectBaseUrl,
        });
        const data = response?.data || {};
        if (data.pendingId && !membershipCheckoutReturnState.pendingId) {
          membershipCheckoutReturnState.pendingId = data.pendingId;
          membershipCheckoutReturnState.status = "waiting";
        }
        if (!data.url) {
          throw new Error(MEMBERSHIP_CHECKOUT_ERROR_FALLBACK);
        }
        window.location.href = data.url;
      } catch (err) {
        const normalizedError = handleCallableError(
          "createMembershipCheckoutSession",
          err,
          MEMBERSHIP_CHECKOUT_ERROR_FALLBACK
        );
        hidePaymentRedirectOverlay();
        membershipCheckoutState.processing = false;
        membershipCheckoutState.status = "ready";
        membershipCheckoutState.activePlan = null;
        updateMembershipPlanButtons(currentUserProfile);
        updateMembershipCheckoutSummary();
        setMembershipCheckoutError(
          normalizedError.message || MEMBERSHIP_CHECKOUT_ERROR_FALLBACK
        );
      }
    }

    async function startMembershipUpgradeCheckout(planKey) {
      const normalizedPlan = normalizePlanKey(planKey || "basic");
      if (!STRIPE_ENABLED) {
        throw new Error("Stripe payments are not available right now.");
      }
      if (!canStartMembershipCheckout(normalizedPlan)) {
        throw new Error(getMembershipPlanDisabledReason(normalizedPlan));
      }
      membershipCheckoutState.processing = true;
      membershipCheckoutState.status = "redirecting";
      membershipCheckoutState.activePlan = normalizedPlan;
      logStripeDebug("membership_checkout_via_sync_overlay", {
        plan: normalizedPlan,
        mode: getMembershipPlanMode(normalizedPlan),
      });
      showPaymentRedirectOverlay("Redirecting you to Stripe Checkout…");
      try {
        const redirectBaseUrl =
          typeof window !== "undefined" && window.location?.origin
            ? window.location.origin
            : undefined;
        const response = await createMembershipCheckoutSessionFn({
          plan: normalizedPlan,
          planId: normalizedPlan,
          mode: getMembershipPlanMode(normalizedPlan),
          redirectBaseUrl,
        });
        const data = response?.data || {};
        if (data.pendingId && !membershipCheckoutReturnState.pendingId) {
          membershipCheckoutReturnState.pendingId = data.pendingId;
          membershipCheckoutReturnState.status = "waiting";
        }
        if (!data.url) {
          throw new Error(MEMBERSHIP_CHECKOUT_ERROR_FALLBACK);
        }
        window.location.href = data.url;
      } catch (err) {
        const normalizedError = handleCallableError(
          "createMembershipCheckoutSession",
          err,
          MEMBERSHIP_CHECKOUT_ERROR_FALLBACK
        );
        hidePaymentRedirectOverlay();
        membershipCheckoutState.processing = false;
        membershipCheckoutState.status = "ready";
        membershipCheckoutState.activePlan = null;
        throw normalizedError;
      }
    }

    updateMembershipPlanButtons();

    function normalizePlanKey(plan) {
      const raw = (plan ?? "").toString().trim().toLowerCase();
      if (!raw) {
        return "basic";
      }
      for (const [planKey, aliases] of Object.entries(MEMBERSHIP_PLAN_KEY_ALIASES)) {
        if (aliases.has(raw) || raw === planKey) {
          return planKey;
        }
      }
      return raw;
    }

    function getMembershipPlanMode(planKey) {
      const normalized = normalizePlanKey(planKey);
      const configMode =
        stripeMembershipConfig?.[normalized]?.mode ||
        stripeMembershipConfig?.[normalized]?.billingMode ||
        stripeMembershipConfig?.[normalized]?.type;
      if (
        typeof configMode === "string" &&
        MEMBERSHIP_PLAN_VALID_MODES.has(configMode.toLowerCase())
      ) {
        return configMode.toLowerCase();
      }
      if (MEMBERSHIP_PLAN_DEFAULT_MODES[normalized]) {
        return MEMBERSHIP_PLAN_DEFAULT_MODES[normalized];
      }
      return "payment";
    }

    function formatMembershipPlanLabel(planKey) {
      const normalized = normalizePlanKey(planKey);
      return (
        MEMBERSHIP_PLAN_COPY[normalized]?.label ||
        MEMBERSHIP_PLAN_COPY.basic.label
      );
    }

    function formatMembershipStatusLabel(status) {
      const normalized = (status || "active").toString().toLowerCase();
      if (normalized === "pending_verification") return "Pending approval";
      if (normalized === "expired") return "Expired";
      if (normalized === "none") return "Not active";
      if (normalized === "inactive") return "Inactive";
      if (normalized === "canceled") return "Canceled";
      return "Active";
    }

    // === RIDE SYNC STRIPE: START membership summary helper ===
    function formatMembershipSummary(planKey, status) {
      const plan = normalizePlanKey(planKey);
      const normalizedStatus = (status || "none").toLowerCase();
      const tierLabel = formatPlanTierLabel(plan);
      if (normalizedStatus === "pending_verification") {
        return `${tierLabel} (Pending verification)`;
      }
      if (normalizedStatus === "active") {
        return `${tierLabel} (Active)`;
      }
      if (normalizedStatus === "expired") {
        return `${tierLabel} (Expired)`;
      }
      if (normalizedStatus === "none") {
        return `${tierLabel} (Not active)`;
      }
      return `${tierLabel} (${normalizedStatus})`;
    }
    function isUnlimitedMembershipActive(planKey, status) {
      const plan = normalizePlanKey(planKey);
      const normalizedStatus = (status || "none").toLowerCase();
      if (normalizedStatus !== "active") return false;
      return plan === "uofa_unlimited" || plan === "nwa_unlimited";
    }
    // === RIDE SYNC STRIPE: END membership summary helper ===

    function planRequiresApproval(planKey) {
      return normalizePlanKey(planKey) === "uofa_unlimited";
    }

    function renderMembershipCard(profile) {
      if (!membershipCard) return;
      const plan = normalizePlanKey(profile?.membershipType || profile?.membership || "basic");
      const planCopy = MEMBERSHIP_PLAN_COPY[plan] || MEMBERSHIP_PLAN_COPY.basic;
      const statusLabel = formatMembershipStatusLabel(profile?.membershipStatus);
      const summaryLabel = formatMembershipSummary(plan, profile?.membershipStatus);

      const normalizedStatus = (profile?.membershipStatus || "none").toLowerCase();
      const isActive = normalizedStatus === "active";
      const isPending = normalizedStatus === "pending_verification";

      if (membershipStatusText) {
        membershipStatusText.textContent = `Plan: ${planCopy.label}`;
      }
      if (membershipCurrentLabel) {
        membershipCurrentLabel.textContent = summaryLabel;
      }

      if (membershipStatusBadge) {
        membershipStatusBadge.textContent = statusLabel;
        membershipStatusBadge.classList.toggle("active", isActive);
        membershipStatusBadge.classList.toggle("pending", isPending);
        membershipStatusBadge.classList.toggle(
          "inactive",
          !isActive && !isPending
        );
      }
      const unlimitedActive = isUnlimitedMembershipActive(
        plan,
        profile?.membershipStatus
      );
      const infoMessage = (() => {
        if (plan === "basic") {
          if (
            canStartMembershipCheckout("uofa_unlimited", profile) ||
            canStartMembershipCheckout("nwa_unlimited", profile)
          ) {
            return "Activate an unlimited plan below to pay instantly with Stripe.";
          }
          return "Membership charges are bundled with each fare. Contact RideSync support if you'd like information about unlimited plans.";
        }
        if (normalizedStatus === "pending_verification") {
          return "We received your payment and are verifying your student ID. You'll be notified once it is active.";
        }
        if (unlimitedActive) {
          return "Your unlimited coverage is active. Reach out to RideSync support if you need to update or pause it.";
        }
        return "Tap Renew below to restart your unlimited coverage through Stripe checkout.";
      })();
      setMembershipMessage(infoMessage);
      updateMembershipPlanButtons(profile);
    }

    function updateSyncButtonLabel() {
      if (!syncButton) return;
      syncButton.disabled = false;
      if (!hasOnlineDrivers) {
        syncButton.textContent = joinMode
          ? "Join Ride (notify drivers)"
          : "Sync destination (notify drivers)";
        return;
      }
      if (joinMode) {
        syncButton.textContent = "Join Ride";
        return;
      }
      syncButton.textContent = "Sync destination";
    }

    function setDriverAvailabilityState(hasDriversOnline) {
      hasOnlineDrivers = !!hasDriversOnline;
      if (driverAvailabilityNotice) {
        driverAvailabilityNotice.textContent = hasOnlineDrivers
          ? "Drivers are online. Tap Sync destination to request a ride."
          : "No drivers are online right now. Tap Sync destination to notify them and we'll queue your ride.";
      }
      updateSyncButtonLabel();
    }

    function isPermissionDeniedError(err) {
      if (!err) return false;
      if (err.code === "permission-denied") {
        return true;
      }
      const message = (err.message || "").toLowerCase();
      return (
        message.includes("missing or insufficient permissions") ||
        message.includes("permission-denied")
      );
    }

    function applyDriverAvailabilityPayload(payload = {}) {
      const onlineIds = Array.isArray(payload.onlineDriverIds)
        ? payload.onlineDriverIds
        : [];
      const busyIds = Array.isArray(payload.busyDriverIds)
        ? payload.busyDriverIds
        : [];
      driverAvailability.onlineIds = new Set(onlineIds);
      driverAvailability.busyDriverIds = new Set(busyIds);
      const onlineCount =
        typeof payload.onlineCount === "number"
          ? payload.onlineCount
          : onlineIds.length;
      driverAvailability.onlineCount = onlineCount;
      const hasDrivers =
        typeof payload.hasOnlineDrivers === "boolean"
          ? payload.hasOnlineDrivers
          : onlineCount > 0;
      setDriverAvailabilityState(hasDrivers);
      updateWaitlistCopy();
      maybeToggleWaitlistPanel();
    }

    async function fetchDriverAvailabilityStatsOnce() {
      if (!getDriverAvailabilityStatsFn) {
        return;
      }
      try {
        const result = await getDriverAvailabilityStatsFn();
        const payload = result?.data || {};
        applyDriverAvailabilityPayload(payload);
      } catch (err) {
        console.warn("driver availability stats fetch error", err);
      }
    }

    function startDriverAvailabilityPolling(immediate = false) {
      if (driverAvailabilityPollTimer) {
        return;
      }
      if (immediate) {
        fetchDriverAvailabilityStatsOnce();
      }
      driverAvailabilityPollTimer = window.setInterval(
        fetchDriverAvailabilityStatsOnce,
        DRIVER_AVAILABILITY_POLL_INTERVAL_MS
      );
    }

    function stopDriverAvailabilityPolling() {
      if (!driverAvailabilityPollTimer) {
        return;
      }
      clearInterval(driverAvailabilityPollTimer);
      driverAvailabilityPollTimer = null;
    }

    function handleDriverAvailabilityPermissionError(err) {
      if (!isPermissionDeniedError(err)) {
        return false;
      }
      startDriverAvailabilityPolling(true);
      return true;
    }

    function subscribeToDriverAvailability() {
      if (driverAvailabilityUnsub) {
        driverAvailabilityUnsub();
        driverAvailabilityUnsub = null;
      }
      try {
        const availabilityQuery = query(
          collection(db, "drivers"),
          where("isOnline", "==", true),
          limit(1)
        );
        driverAvailabilityUnsub = onSnapshot(
          availabilityQuery,
          (snap) => {
            stopDriverAvailabilityPolling();
            setDriverAvailabilityState(!snap.empty);
          },
          (err) => {
            console.error("driver availability watcher error", err);
            driverAvailabilityUnsub = null;
            setDriverAvailabilityState(false);
            const handled = handleDriverAvailabilityPermissionError(err);
            if (!handled && driverAvailabilityNotice) {
              driverAvailabilityNotice.textContent =
                "Can't confirm driver availability right now.";
            }
          }
        );
      } catch (err) {
        console.error("driver availability subscribe error", err);
        setDriverAvailabilityState(false);
        handleDriverAvailabilityPermissionError(err);
      }
    }

    toggleLink.addEventListener("click", () => {
      isSignupMode = !isSignupMode;
      if (isSignupMode) {
        signupFields.style.display = "block";
        authButton.textContent = "Create account";
        toggleLink.textContent = "Already have an account? Log in";
      } else {
        signupFields.style.display = "none";
        authButton.textContent = "Log in";
        toggleLink.textContent = "New here? Create account";
      }
      authError.textContent = "";
    });
      authButton.addEventListener("click", async () => {
        authError.textContent = "";
        const email = emailEl.value.trim();
        const password = passwordEl.value.trim();
        if (!email || !password) {
          authError.textContent = "Email and password required.";
          return;
        }

        try {
          if (isSignupMode) {
            const cred = await createUserWithEmailAndPassword(auth, email, password);
            await saveUserProfile(email);
          } else {
            await signInWithEmailAndPassword(auth, email, password);
          }
        } catch (err) {
          console.error(err);
          authError.textContent = err.message || "Authentication error.";
        }
      });

    logoutButton.addEventListener("click", async () => {
      stopDriverAvailabilityWatchers();
      await signOut(auth);
      clearCurrentRideState();
      joinMode = false;
      joinTargetRide = null;
      clearPoolGroupUI();
      resetTripPlanner();
      if (joinBanner) {
        joinBanner.style.display = "none";
      }
      if (ridersSection) {
        ridersSection.style.display = "block";
      }
      showAuthView();
      updateCancelButtonVisibility();
    });

    updateAddStopAvailability();
    renderFareExtraStops();

    if (addStopButton) {
      addStopButton.addEventListener("click", () => {
        addExtraStopField();
      });
    }

    if (destinationEl) {
      destinationEl.addEventListener("input", () => {
        const currentValue = destinationEl.value.trim();
        const lastValue = (lastDestinationPlace?.formatted_address || "").trim();
        if (!currentValue || currentValue !== lastValue) {
          clearDestinationSelection();
        }
        updateSyncRidersButtonVisibility();
      });
    }

    if (pickupOverrideInput) {
      pickupOverrideInput.addEventListener("input", () => {
        pickupOverrideState.label = pickupOverrideInput.value.trim();
        pickupOverrideState.location = null;
        setPickupOverrideError("");
      });
    }

    async function uploadFileIfAny(fileInput, path) {
      if (!fileInput || !fileInput.files || !fileInput.files.length) {
        return null;
      }
      const file = fileInput.files[0];
      const storageRef = ref(storage, path);
      await uploadBytes(storageRef, file);
      return await getDownloadURL(storageRef);
    }

    async function tryUploadFileWithGrace(fileInput, path, label) {
      if (!fileInput || !fileInput.files || !fileInput.files.length) {
        return { url: null, error: null, label };
      }
      try {
        const url = await uploadFileIfAny(fileInput, path);
        return { url, error: null, label };
      } catch (err) {
        console.warn(`Upload failed for ${label}`, err);
        return { url: null, error: err, label };
      }
    }

    async function saveUserProfile(email) {
      const activeUser = auth.currentUser;
      if (!activeUser) {
        throw new Error("Log in to update your profile.");
      }
      const profilePayload = {
        fullName: fullNameEl.value.trim(),
        gender: (genderEl.value || "").trim().toLowerCase(),
        phone: phoneEl.value.trim(),
        street: streetEl.value.trim(),
        city: cityEl.value.trim(),
        state: stateEl.value.trim(),
        zip: zipEl.value.trim(),
        isStudent: isStudentEl.value === "true",
        email: email || auth.currentUser?.email || null,
      };

      try {
        profilePayload.profilePicUrl = await uploadFileIfAny(
          profilePicInput,
          `users/${activeUser.uid}/profile.jpg`
        );
      } catch (err) {
        console.warn("Upload error", err);
      }

      await saveUserProfileFn(profilePayload);
    }

    async function loadUserProfile(uid, email) {
      const refDoc = doc(db, "users", uid);
      let snap = await getDoc(refDoc);
      if (!snap.exists()) {
        try {
          await saveUserProfileFn({ email: email || auth.currentUser?.email || null });
          snap = await getDoc(refDoc);
        } catch (err) {
          console.warn("Failed to bootstrap profile", err);
        }
      }
      if (snap.exists()) {
        currentUserProfile = { uid, email, ...snap.data() };
      } else {
        currentUserProfile = {
          uid,
          email,
          membershipType: "basic",
          membershipStatus: "none"
        };
      }

      renderProfile();
    }

    function renderProfile() {
      if (!currentUserProfile) return;
      const p = currentUserProfile;

      const name =
        p.fullName ||
        p.name ||
        p.displayName ||
        (p.email ? p.email.split("@")[0] : "Rider");
      const phone = p.phone || p.phoneNumber || "";

      riderNameEl.textContent = name;
      if (riderEmailDetailEl) {
        riderEmailDetailEl.textContent = p.email || "Not set";
      }

      riderPhoneDetailEl.textContent = phone || "Not set";
      const addressParts = [
        p.street || "",
        [p.city, p.state].filter(Boolean).join(", "),
        p.zip || ""
      ].filter(Boolean);
      riderAddressDetailEl.textContent = addressParts.join(" • ") || "Not set";

      const planKey = normalizePlanKey(p.membershipType || p.membership || "basic");
      const membershipSummary = formatMembershipSummary(planKey, p.membershipStatus);
      riderMembershipDetailEl.textContent = membershipSummary;

      editFullNameEl.value = p.fullName || "";
      editPhoneEl.value = phone || "";
      editStreetEl.value = p.street || "";
      editCityEl.value = p.city || "";
      editStateEl.value = p.state || "";
      editZipEl.value = p.zip || "";
      if (editGenderEl) {
        const g = (p.gender || "").toLowerCase();
        if (g === "male" || g === "female" || g === "other") {
          editGenderEl.value = g;
        } else {
          editGenderEl.value = "";
        }
      }

      const photoUrl = p.profilePicUrl || p.photoURL || null;
      if (photoUrl) {
        avatarEl.style.backgroundImage = `url(${photoUrl})`;
        avatarEl.style.backgroundSize = "cover";
        avatarEl.style.backgroundPosition = "center";
        avatarEl.textContent = "";
      } else {
        avatarEl.style.backgroundImage = "";
        const initials = (name || "RS")
          .split(" ")
          .map((s) => s[0])
          .join("")
          .slice(0, 2)
          .toUpperCase();
        avatarEl.textContent = initials || "RS";
      }

      setMembershipBadge(p);
      renderMembershipCard(p);
      updateSyncButtonLabel();
    }

    editProfileButton.addEventListener("click", () => {
      if (!currentUserProfile) return;
      const isHidden =
        editProfileSection.style.display === "none" ||
        !editProfileSection.style.display;
      editProfileSection.style.display = isHidden ? "block" : "none";
    });

    saveProfileButton.addEventListener("click", async () => {
      profileError.textContent = "";
      profileMessage.textContent = "";
      const user = auth.currentUser;
      if (!user) return;

      const updates = {
        fullName: editFullNameEl.value.trim(),
        phone: editPhoneEl.value.trim(),
        street: editStreetEl.value.trim(),
        city: editCityEl.value.trim(),
        state: editStateEl.value.trim(),
        zip: editZipEl.value.trim(),
        gender: (editGenderEl.value || "").trim().toLowerCase(),
      };
      const uploadDescriptors = [
        {
          input: editProfilePicInput,
          path: `users/${user.uid}/profile.jpg`,
          key: "profilePicUrl",
          label: "profile photo"
        }
      ];

      const uploadResults = [];
      for (const descriptor of uploadDescriptors) {
        const result = await tryUploadFileWithGrace(
          descriptor.input,
          descriptor.path,
          descriptor.label
        );
        uploadResults.push({ ...result, key: descriptor.key });
        if (result.url) {
          updates[descriptor.key] = result.url;
        }
      }

      try {
        await saveUserProfileFn(updates);
        await loadUserProfile(user.uid, user.email);
        editProfileSection.style.display = "none";

        editProfilePicInput.value = "";

        const failedUploads = uploadResults
          .filter((item) => item.error)
          .map((item) => item.label);
        if (failedUploads.length) {
          profileMessage.textContent = "Profile updated, but some files could not upload.";
          profileError.textContent = `Skipped: ${failedUploads.join(", ")}`;
        } else {
          profileMessage.textContent = "Profile updated.";
          profileError.textContent = "";
        }
      } catch (err) {
        console.error(err);
        profileError.textContent = "Could not update profile.";
      }
    });

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        clearCurrentRideState();
        stopDriverAvailabilityWatchers();
        stopRiderPresenceHeartbeat(true);
        currentUserProfile = null;
        showAuthView();
        teardownRideChat(true);
        if (hasPendingMembershipCheckoutReturn()) {
          openPaymentStatusOverlay(
            "Sign in to finish membership",
            "Stripe approved your payment. Log in so we can finalize your membership."
          );
        } else if (hasPendingCheckoutReturn()) {
          openPaymentStatusOverlay(
            "Sign in to finish payment",
            "Stripe approved your payment. Log in so we can finalize your ride."
          );
        } else {
          closePaymentStatusOverlay();
        }
        return;
      }
      await loadUserProfile(user.uid, user.email);
      startRiderPresenceHeartbeat(user.uid);
      showRideView();
      subscribeToDriverAvailability();
      initMapOnce();
      startDriverAvailabilityWatchers();
      await resumeActiveRideSession(user);
      let pendingOverlay = false;
      if (hasPendingMembershipCheckoutReturn()) {
        pendingOverlay = true;
        await finalizeMembershipCheckoutSessionIfNeeded(user);
      }
      if (hasPendingCheckoutReturn()) {
        pendingOverlay = true;
        await finalizeCheckoutSessionIfNeeded(user);
      }
      if (!pendingOverlay) {
        closePaymentStatusOverlay();
      }

      if (joinRideIdFromUrl && !joinMode) {
        await enterJoinMode(joinRideIdFromUrl);
      }
    });

    function haversineDistanceMiles(lat1, lon1, lat2, lon2) {
      const R = 3958.8;
      const toRad = (v) => (v * Math.PI) / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) *
          Math.cos(toRad(lat2)) *
          Math.sin(dLon / 2) *
          Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function initMapOnce() {
      if (googleMapsLoadFailed) return;
      if (!window.google || !google.maps) return;
      if (map) return;
      map = new google.maps.Map(mapEl, {
        center: { lat: 36.06, lng: -94.16 },
        zoom: 12,
        disableDefaultUI: true
      });
      directionsService = new google.maps.DirectionsService();
      directionsRenderer = new google.maps.DirectionsRenderer({
        map,
        suppressMarkers: true,
        preserveViewport: false
      });

      pickupMarker = new google.maps.Marker({
        map,
        title: "Pickup",
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 7,
          fillColor: "#22c55e",
          fillOpacity: 1,
          strokeColor: "#022c22",
          strokeWeight: 2
        }
      });

      destMarker = new google.maps.Marker({
        map,
        title: "Destination",
        icon: "https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png"
      });

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const literal = {
              lat: pos.coords.latitude,
              lng: pos.coords.longitude
            };
            hidePickupOverrideField();
            pickupOverrideState.label = "";
            pickupOverrideState.location = null;
            setPickupOverrideError("");
            applyPickupLocation(literal, { recenterMap: true });
          },
          (err) => {
            handleGeolocationError(err);
          }
        );
      } else {
        handleGeolocationError(null);
      }

      setupDestinationAutocomplete();
    }

    function setupDestinationAutocomplete() {
      if (googleMapsLoadFailed) return;
      if (!window.google || !google.maps || !google.maps.places) return;
      if (!destAutocomplete && window.google && google.maps.places) {
        destAutocomplete = new google.maps.places.Autocomplete(destinationEl, {
          types: ["geocode"],
          componentRestrictions: { country: "us" }
        });

        destAutocomplete.addListener("place_changed", () => {
          const place = destAutocomplete.getPlace();
          if (!place || !place.geometry || !place.geometry.location) return;

          lastDestinationPlace = place;
          lastDestinationIsFayetteville = isFayettevilleFromPlace(place);

          destinationLatLng = place.geometry.location;

          destMarker.setPosition(destinationLatLng);
          destMarker.setVisible(true);

          updateTripPreviewMap();
          updateRouteAndFare();
        });
      }
    }

    function setPickupOverrideError(message) {
      if (pickupOverrideError) {
        pickupOverrideError.textContent = message || "";
      }
    }

    function showPickupOverrideField(message) {
      if (!pickupOverrideField) return;
      pickupOverrideField.style.display = "block";
      if (pickupOverrideHint) {
        pickupOverrideHint.textContent =
          message ||
          "Location access is off. Enter your pickup address to continue.";
      }
    }

    function hidePickupOverrideField() {
      if (pickupOverrideField) {
        pickupOverrideField.style.display = "none";
      }
      if (pickupOverrideInput) {
        pickupOverrideInput.value = "";
      }
      pickupOverrideState.label = "";
      pickupOverrideState.location = null;
      setPickupOverrideError("");
    }

    function applyPickupLocation(literal, options = {}) {
      if (!isLatLngLiteral(literal)) {
        return;
      }
      currentLocation = { lat: literal.lat, lng: literal.lng };
      if (pickupMarker) {
        pickupMarker.setPosition(currentLocation);
        pickupMarker.setVisible(true);
      }
      if (options.recenterMap && map) {
        map.setCenter(currentLocation);
      }
      if (destinationLatLng) {
        updateTripPreviewMap();
        updateRouteAndFare();
      } else {
        updateTripPreviewMap();
      }
    }

    function handleGeolocationError(err) {
      console.warn("Geolocation error", err);
      const denied = err?.code === 1;
      const message = denied
        ? "Location access is blocked. Enter your pickup address below or enable location services."
        : "We couldn't detect your location. Enter a pickup address or try again.";
      showPickupOverrideField(message);
      if (profileError) {
        profileError.textContent = message;
      }
      pickupOverrideInput?.focus();
    }

    async function ensurePickupLocationReady() {
      if (currentLocation && isLatLngLiteral(currentLocation)) {
        return true;
      }
      if (!pickupOverrideInput) {
        if (profileError) {
          profileError.textContent = "Turn on location services to sync your ride.";
        }
        return false;
      }
      showPickupOverrideField();
      const manualValue = pickupOverrideInput.value.trim();
      if (!manualValue) {
        setPickupOverrideError("Enter your pickup address to continue.");
        pickupOverrideInput.focus();
        return false;
      }
      if (
        pickupOverrideState.location &&
        pickupOverrideState.label.toLowerCase() === manualValue.toLowerCase()
      ) {
        applyPickupLocation(pickupOverrideState.location, { recenterMap: false });
        setPickupOverrideError("");
        return true;
      }
      try {
        const place = await geocodeDestinationInput(manualValue, {
          emptyMessage: "Enter a pickup address to continue.",
          notFoundMessage: "We couldn't find that pickup location. Try a different address.",
          rateLimitMessage: "We're seeing a lot of lookups. Please try again shortly.",
          genericErrorMessage: "Maps couldn't look up that pickup location. Please try again."
        });
        const literal = latLngToLiteral(place?.geometry?.location);
        if (!isLatLngLiteral(literal)) {
          throw new Error("We couldn't find that pickup location. Try a different address.");
        }
        pickupOverrideState.location = literal;
        pickupOverrideState.label = place?.formatted_address || manualValue;
        pickupOverrideInput.value = pickupOverrideState.label;
        setPickupOverrideError("");
        applyPickupLocation(literal, { recenterMap: true });
        return true;
      } catch (err) {
        console.error("Pickup override geocode failed", err);
        setPickupOverrideError(
          err?.message || "We couldn't find that pickup location. Try again."
        );
        pickupOverrideInput.focus();
        return false;
      }
    }

    function updateAddStopAvailability() {
      if (!addStopButton) return;
      const isFull = extraStopsState.length >= MAX_EXTRA_STOPS;
      addStopButton.disabled = isFull;
      addStopButton.setAttribute("aria-disabled", isFull ? "true" : "false");
    }

    function renderFareExtraStops() {
      if (!fareExtraStops) return;
      fareExtraStops.innerHTML = "";
      const visibleStops = extraStopsState.filter((stop) =>
        stop.inputEl && stop.inputEl.value.trim()
      );
      if (!visibleStops.length) {
        fareExtraStops.style.display = "none";
        return;
      }
      fareExtraStops.style.display = "block";
      visibleStops.forEach((stop, index) => {
        const row = document.createElement("div");
        row.className = "fare-row";
        const label = document.createElement("div");
        label.className = "fare-label";
        label.textContent = `Extra stop ${index + 1}`;
        const value = document.createElement("div");
        value.className = "fare-value";
        value.textContent = stop.inputEl.value.trim();
        row.appendChild(label);
        row.appendChild(value);
        fareExtraStops.appendChild(row);
      });
    }

    function setupExtraStopAutocomplete(stopEntry) {
      if (!stopEntry || stopEntry.autocomplete) return;
      if (googleMapsLoadFailed) return;
      if (!window.google || !google.maps || !google.maps.places) return;
      stopEntry.autocomplete = new google.maps.places.Autocomplete(stopEntry.inputEl, {
        types: ["geocode"],
        componentRestrictions: { country: "us" }
      });
      stopEntry.autocomplete.addListener("place_changed", () => {
        const place = stopEntry.autocomplete?.getPlace();
        if (!place || !place.geometry || !place.geometry.location) {
          stopEntry.location = null;
          return;
        }
        const literal = latLngToLiteral(place.geometry.location);
        stopEntry.location = literal;
        stopEntry.label =
          place.formatted_address || place.name || stopEntry.inputEl.value.trim();
        stopEntry.inputEl.value = stopEntry.label;
        renderFareExtraStops();
        updateRouteAndFare();
      });
    }

    function addExtraStopField(options = {}) {
      if (!extraStopsContainer) return null;
      if (extraStopsState.length >= MAX_EXTRA_STOPS) return null;
      extraStopIdCounter += 1;
      const stopId = `extra-stop-${extraStopIdCounter}`;
      const wrapper = document.createElement("div");
      wrapper.className = "extra-stop-field";
      wrapper.dataset.stopId = stopId;

      const input = document.createElement("input");
      input.type = "text";
      input.className = "extra-stop-input";
      input.placeholder = "Extra stop address";
      input.setAttribute("aria-label", `Extra stop ${extraStopsState.length + 1}`);

      const removeButton = document.createElement("button");
      removeButton.type = "button";
      removeButton.className = "remove-stop-btn";
      removeButton.setAttribute("aria-label", "Remove stop");
      removeButton.textContent = "x";

      wrapper.appendChild(input);
      wrapper.appendChild(removeButton);
      extraStopsContainer.appendChild(wrapper);

      const stopEntry = {
        id: stopId,
        wrapper,
        inputEl: input,
        removeButton,
        autocomplete: null,
        location: null,
        label: ""
      };
      extraStopsState.push(stopEntry);

      input.addEventListener("input", () => {
        stopEntry.location = null;
        stopEntry.label = input.value.trim();
        renderFareExtraStops();
        updateRouteAndFare();
      });
      removeButton.addEventListener("click", () => removeExtraStop(stopEntry.id));

      setupExtraStopAutocomplete(stopEntry);
      updateAddStopAvailability();
      renderFareExtraStops();

      if (options.focus !== false) {
        setTimeout(() => input.focus(), 0);
      }

      return stopEntry;
    }

    function removeExtraStop(stopId) {
      const targetIndex = extraStopsState.findIndex((stop) => stop.id === stopId);
      if (targetIndex === -1) return;
      const [entry] = extraStopsState.splice(targetIndex, 1);
      if (entry?.wrapper?.parentNode) {
        entry.wrapper.parentNode.removeChild(entry.wrapper);
      }
      if (entry) {
        entry.autocomplete = null;
      }
      updateAddStopAvailability();
      renderFareExtraStops();
      updateRouteAndFare();
    }

    function getExtraStopWaypoints() {
      return extraStopsState
        .map((stop) => stop.location)
        .filter((loc) => isLatLngLiteral(loc));
    }

    function collectExtraStopsForRide() {
      const collected = [];
      extraStopsState.forEach((stop, index) => {
        if (!stop.inputEl) {
          return;
        }
        const label = stop.inputEl.value.trim();
        if (!label) {
          return;
        }
        const literal = latLngToLiteral(stop.location);
        if (!isLatLngLiteral(literal)) {
          throw new Error(
            `Confirm extra stop ${index + 1} by selecting an address from the list.`
          );
        }
        collected.push({
          order: index + 1,
          label,
          location: literal
        });
      });
      return collected;
    }

    function latLngToLiteral(value) {
      if (!value) return null;
      if (typeof value.lat === "function" && typeof value.lng === "function") {
        return { lat: value.lat(), lng: value.lng() };
      }
      if (typeof value.lat === "number" && typeof value.lng === "number") {
        return value;
      }
      return null;
    }

    function isLatLngLiteral(value) {
      return (
        !!value &&
        Number.isFinite(value.lat) &&
        Number.isFinite(value.lng)
      );
    }

    function ensureDestinationPreviewMap() {
      if (googleMapsLoadFailed) return;
      if (!destinationPreviewMapEl || destinationPreviewMap) return;
      if (!window.google || !google.maps) return;
      destinationPreviewMap = new google.maps.Map(destinationPreviewMapEl, {
        center: { lat: 36.06, lng: -94.16 },
        zoom: 13,
        disableDefaultUI: true,
        draggable: false,
        keyboardShortcuts: false,
        gestureHandling: "none",
        mapTypeControl: false,
        clickableIcons: false,
        styles: [
          { featureType: "poi", stylers: [{ visibility: "off" }] },
          { featureType: "transit", stylers: [{ visibility: "off" }] }
        ]
      });

      destinationPreviewPickupMarker = new google.maps.Marker({
        map: destinationPreviewMap,
        title: "Pickup",
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 6,
          fillColor: "#22c55e",
          fillOpacity: 1,
          strokeColor: "#022c22",
          strokeWeight: 2
        },
        visible: false
      });

      destinationPreviewDestMarker = new google.maps.Marker({
        map: destinationPreviewMap,
        title: "Destination",
        icon: "https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png",
        visible: false
      });
    }

    function hideTripPreviewMap() {
      if (tripMapPreviewEl) {
        tripMapPreviewEl.classList.remove("has-destination");
        tripMapPreviewEl.setAttribute("aria-hidden", "true");
      }
      if (destinationPreviewPickupMarker) {
        destinationPreviewPickupMarker.setVisible(false);
      }
      if (destinationPreviewDestMarker) {
        destinationPreviewDestMarker.setVisible(false);
      }
      if (destinationPreviewEmptyEl) {
        destinationPreviewEmptyEl.style.opacity = "";
      }
    }

    function updateTripPreviewMap() {
      if (!tripMapPreviewEl || !destinationLatLng) {
        hideTripPreviewMap();
        return;
      }
      if (googleMapsLoadFailed) return;
      if (!window.google || !google.maps) {
        setTimeout(updateTripPreviewMap, 700);
        return;
      }
      ensureDestinationPreviewMap();
      if (!destinationPreviewMap) return;

      const destLiteral = latLngToLiteral(destinationLatLng);
      if (!destLiteral) return;

      destinationPreviewDestMarker.setPosition(destLiteral);
      destinationPreviewDestMarker.setVisible(true);

      const bounds = new google.maps.LatLngBounds();
      bounds.extend(destLiteral);

      if (currentLocation && typeof currentLocation.lat === "number" && typeof currentLocation.lng === "number") {
        destinationPreviewPickupMarker.setPosition(currentLocation);
        destinationPreviewPickupMarker.setVisible(true);
        bounds.extend(currentLocation);
      } else if (destinationPreviewPickupMarker) {
        destinationPreviewPickupMarker.setVisible(false);
      }

      if (destinationPreviewPickupMarker?.getVisible()) {
        destinationPreviewMap.fitBounds(bounds);
      } else {
        destinationPreviewMap.setCenter(destLiteral);
        destinationPreviewMap.setZoom(14);
      }

      tripMapPreviewEl.classList.add("has-destination");
      tripMapPreviewEl.setAttribute("aria-hidden", "false");
    }

    async function updateRouteAndFare() {
      if (googleMapsLoadFailed) return false;
      if (!window.google || !google.maps) return false;
      if (profileError) {
        profileError.textContent = "";
      }
      if (!currentLocation || !destinationLatLng || !directionsService) {
        return false;
      }

      const request = {
        origin: currentLocation,
        destination: destinationLatLng,
        travelMode: google.maps.TravelMode.DRIVING
      };
      const waypointLocations = getExtraStopWaypoints();
      if (waypointLocations.length) {
        request.waypoints = waypointLocations.map((loc) => ({
          location: loc,
          stopover: true
        }));
      }

      return await new Promise((resolve) => {
        directionsService.route(request, (result, status) => {
          if (status !== "OK" || !result?.routes?.length) {
            console.warn("Directions failed", status);
            resolve(false);
            return;
          }
          directionsRenderer.setDirections(result);

          const legs = result.routes[0].legs || [];
          const totalDurationSec = legs.reduce(
            (sum, leg) => sum + (leg?.duration?.value || 0),
            0
          );
          const totalDistanceMeters = legs.reduce(
            (sum, leg) => sum + (leg?.distance?.value || 0),
            0
          );

          const minutes = totalDurationSec / 60;
          const plan = normalizePlanKey(
            currentUserProfile?.membershipType || currentUserProfile?.membership || "basic"
          );

          let pickupCovered = false;
          if (plan === "uofa_unlimited" && currentLocation) {
            pickupCovered =
              haversineDistanceMiles(
                FAYETTEVILLE_CENTER.lat,
                FAYETTEVILLE_CENTER.lng,
                currentLocation.lat,
                currentLocation.lng
              ) <= FAYETTEVILLE_RADIUS_MILES;
          } else if (plan === "nwa_unlimited" && currentLocation) {
            pickupCovered =
              haversineDistanceMiles(
                NWA_CENTER.lat,
                NWA_CENTER.lng,
                currentLocation.lat,
                currentLocation.lng
              ) <= NWA_RADIUS_MILES;
          }

          const fareInfo = computeFareForMembership(plan, minutes, pickupCovered);

          lastRideMetrics = {
            durationMinutes: minutes,
            distanceMeters: totalDistanceMeters,
            inHomeZone: pickupCovered,
            pickupCovered,
            fareBreakdown: fareInfo,
            membershipLabel: fareInfo.membershipLabel
          };

          if (fareNotReady) {
            fareNotReady.style.display = "none";
          }
          if (fareReady) {
            fareReady.style.display = "block";
          }
          if (fareTime) {
            fareTime.textContent = `${minutes.toFixed(1)} min`;
          }
          if (fareDistance) {
            fareDistance.textContent = `${(totalDistanceMeters / 1609.34).toFixed(2)} mi`;
          }
          if (fareMembership) {
            let fareMembershipLabel = fareInfo.membershipLabel;
            if (plan === "uofa_unlimited" || plan === "nwa_unlimited") {
              fareMembershipLabel = pickupCovered
                ? `${fareInfo.membershipLabel} • Covered pickup`
                : `${fareInfo.membershipLabel} • Outside coverage`;
            }
            fareMembership.textContent = fareMembershipLabel;
          }
          if (fareTotal) {
            fareTotal.textContent = `$${fareInfo.total.toFixed(2)}`;
          }

          updateSyncButtonLabel();
          updateTripPreviewMap();
          resolve(true);
        });
      });
    }

    function getDestinationGeocoder() {
      if (googleMapsLoadFailed) {
        return null;
      }
      if (!window.google || !google.maps) {
        return null;
      }
      if (!destinationGeocoder) {
        destinationGeocoder = new google.maps.Geocoder();
      }
      return destinationGeocoder;
    }

    async function geocodeDestinationInput(address, options = {}) {
      const {
        emptyMessage = "Enter a destination before syncing.",
        notFoundMessage = "We couldn't find that destination. Try a more complete address.",
        rateLimitMessage = "We're seeing a lot of lookups. Please try again shortly.",
        genericErrorMessage = "Maps couldn't look up that destination. Please try again."
      } = options;
      const trimmed = address?.trim();
      if (!trimmed) {
        throw new Error(emptyMessage);
      }
      if (googleMapsLoadFailed) {
        throw new Error("Maps aren't available right now. Please refresh and try again.");
      }
      const geocoder = getDestinationGeocoder();
      if (!geocoder) {
        throw new Error("Maps are still loading. Try again in a moment.");
      }
      return await new Promise((resolve, reject) => {
        geocoder.geocode(
          {
            address: trimmed,
            componentRestrictions: { country: "us" }
          },
          (results, status) => {
            if (status === "OK" && results?.length) {
              resolve(results[0]);
              return;
            }
            if (status === "ZERO_RESULTS") {
              reject(new Error(notFoundMessage));
              return;
            }
            if (status === "OVER_QUERY_LIMIT") {
              reject(new Error(rateLimitMessage));
              return;
            }
            reject(new Error(genericErrorMessage));
          }
        );
      });
    }

    function setButtonBusy(button, loadingLabel) {
      if (!button) {
        return () => {};
      }
      const previousText = button.textContent;
      button.disabled = true;
      if (loadingLabel) {
        button.textContent = loadingLabel;
      }
      return () => {
        button.disabled = false;
        if (typeof previousText === "string") {
          button.textContent = previousText;
        }
      };
    }

    async function ensureDestinationReadyForSync() {
      if (destinationLatLng && lastRideMetrics) {
        return true;
      }
      if (!destinationEl) {
        return false;
      }
      const typedDestination = destinationEl.value.trim();
      if (!destinationLatLng) {
        try {
          const place = await geocodeDestinationInput(typedDestination);
          if (!place?.geometry?.location) {
            throw new Error("Choose a destination from the list to continue.");
          }
          lastDestinationPlace = place;
          lastDestinationIsFayetteville = isFayettevilleFromPlace(place);
          destinationLatLng = place.geometry.location;
          if (destinationEl && place.formatted_address) {
            destinationEl.value = place.formatted_address;
            updateSyncRidersButtonVisibility();
          }
          if (destMarker) {
            destMarker.setPosition(destinationLatLng);
            destMarker.setVisible(true);
          }
        } catch (err) {
          console.error("Destination geocode failed", err);
          if (profileError) {
            profileError.textContent =
              err?.message ||
              "We couldn't find that destination. Please try again.";
          }
          destinationEl.focus();
          return false;
        }
      }

      initMapOnce();
      ensureBackgroundMapReady();

      const pickupReady = await ensurePickupLocationReady();
      if (!pickupReady) {
        return false;
      }

      if (!lastRideMetrics) {
        const routeReady = await updateRouteAndFare();
        if (!routeReady) {
          if (profileError) {
            profileError.textContent =
              "We couldn't calculate your fare yet. Check your pickup or destination.";
          }
          return false;
        }
      }
      return true;
    }

    function clearDestinationSelection(options = {}) {
      const { resetInput = false } = options;
      lastDestinationPlace = null;
      lastDestinationIsFayetteville = false;
      destinationLatLng = null;
      lastRideMetrics = null;
      hideTripPreviewMap();
      if (resetInput && destinationEl) {
        destinationEl.value = "";
      }
      if (fareReady) {
        fareReady.style.display = "none";
      }
      if (fareNotReady) {
        fareNotReady.style.display = "block";
      }
      fareTime.textContent = "";
      fareDistance.textContent = "";
      fareMembership.textContent = "";
      fareTotal.textContent = "";
      if (destMarker) {
        destMarker.setVisible(false);
      }
      if (directionsRenderer) {
        directionsRenderer.set("directions", null);
      }
      updateSyncRidersButtonVisibility();
    }

    function resetTripPlanner() {
      hidePickupOverrideField();
      clearDestinationSelection({ resetInput: true });
      if (numRidersEl) {
        numRidersEl.value = "1";
        numRidersEl.disabled = false;
      }
      updateGroupRideIntentFromSelect();
      [...extraStopsState].forEach((stop) => removeExtraStop(stop.id));
      updateAddStopAvailability();
      renderFareExtraStops();
    }

    function clearPoolGroupUI() {
      poolGroupTitle.style.display = "none";
      poolGroupBox.style.display = "none";
      poolGroupStatus.textContent = "";
      poolGroupList.innerHTML = "";
    }

    function renderPoolGroup(riders) {
      if (!riders || riders.length === 0) {
        poolGroupTitle.style.display = "block";
        poolGroupBox.style.display = "block";
        poolGroupStatus.textContent = "Searching for other U of A riders…";
        poolGroupList.innerHTML = "";
        return;
      }

      poolGroupTitle.style.display = "block";
      poolGroupBox.style.display = "block";
      poolGroupStatus.textContent = `You are pooled with ${riders.length} other U of A rider${riders.length > 1 ? "s" : ""}.`;

      poolGroupList.innerHTML = riders
        .map((r) => {
          const name = r.riderName || "U of A rider";
          const phone = r.riderPhone || "";
          const membership =
            r.membershipType === "uofa_unlimited"
              ? "U OF A STUDENT — UNLIMITED"
              : r.membershipType === "nwa_unlimited"
              ? "NORTHWEST ARKANSAS — UNLIMITED"
              : "BASIC (default)";
          const initials = (name || "RS")
            .split(" ")
            .map((s) => s[0])
            .join("")
            .slice(0, 2)
            .toUpperCase();

          return `
            <div class="fare-row" style="align-items:center; gap:8px;">
              <div style="display:flex; align-items:center; gap:8px;">
                <div style="
                  width:28px;
                  height:28px;
                  border-radius:999px;
                  border:1px solid rgba(148,163,184,0.7);
                  background:#020617;
                  display:flex;
                  align-items:center;
                  justify-content:center;
                  font-size:0.7rem;
                  color:#9ca3af;
                ">
                  ${initials}
                </div>
                <div>
                  <div class="fare-label" style="margin-bottom:1px;">${name}</div>
                  <div class="fare-value" style="font-size:0.7rem;">
                    ${membership}${phone ? " • " + phone : ""}
                  </div>
                </div>
              </div>
            </div>
          `;
        })
        .join("");
    }

    function startPoolGroupWatcher(rideId) {
      clearPoolGroupUI();

      if (activeRideUnsub) {
        activeRideUnsub();
        activeRideUnsub = null;
      }
      if (activeGroupUnsub) {
        activeGroupUnsub();
        activeGroupUnsub = null;
      }

      const rideRef = doc(db, "rideRequests", rideId);
      activeRideUnsub = onSnapshot(rideRef, (snap) => {
        if (!snap.exists()) return;
        const data = snap.data();
        if (data.groupId) {
          subscribeToPoolGroup(data.groupId, rideId);
        }
      });
    }

    function subscribeToPoolGroup(groupId, myRideId) {
      if (activeGroupUnsub) {
        activeGroupUnsub();
        activeGroupUnsub = null;
      }

      const qRef = query(
        collection(db, "rideRequests"),
        where("groupId", "==", groupId)
      );

      const myGender = normalizePoolGender(currentUserProfile?.gender);

      activeGroupUnsub = onSnapshot(qRef, (qsnap) => {
        const otherRiders = [];

        qsnap.forEach((docSnap) => {
          if (docSnap.id === myRideId) return;
          const data = docSnap.data();
          const otherGender = normalizePoolGender(data.gender);
          if (!myGender || !otherGender || otherGender !== myGender) {
            return;
          }
          otherRiders.push(data);
        });

        renderPoolGroup(otherRiders);
      });
    }

    function computeBasicFareBreakdown(minutesRaw) {
      const minutes = Number(minutesRaw);
      if (!Number.isFinite(minutes) || minutes <= 0) {
        return {
          rideSubtotal: 0,
          processingFee: 0,
          total: 0
        };
      }
      const clampedMinutes = Math.min(Math.max(minutes, 1), 600);
      const {
        BASIC_RATE_PER_MIN,
        BASIC_PLATFORM_FEE,
        BASIC_PER_RIDE_FEE,
        BASIC_PROCESSING_FEE_RATE
      } = FARE_SETTINGS;
      const rideSubtotal =
        clampedMinutes * BASIC_RATE_PER_MIN +
        BASIC_PLATFORM_FEE +
        BASIC_PER_RIDE_FEE;
      const processingFee = rideSubtotal * BASIC_PROCESSING_FEE_RATE;
      const total = rideSubtotal + processingFee;
      return {
        rideSubtotal,
        processingFee,
        total
      };
    }

    function computeFareForMembership(plan, minutes, pickupCovered) {
      const normalizedPlan = normalizePlanKey(plan);
      const tier = MEMBERSHIP_PLAN_COPY[normalizedPlan]?.tier || MEMBERSHIP_TIER_KEYS.BASIC;
      const tierLabel =
        MEMBERSHIP_TIER_DETAILS[tier]?.label ||
        MEMBERSHIP_TIER_DETAILS[MEMBERSHIP_TIER_KEYS.BASIC].label;
      const breakdown = computeBasicFareBreakdown(minutes);
      const baseResult = {
        rideSubtotal: breakdown.rideSubtotal,
        processingFee: breakdown.processingFee,
        total: breakdown.total,
        membershipLabel: tierLabel
      };

      if (normalizedPlan === "uofa_unlimited" || normalizedPlan === "nwa_unlimited") {
        if (pickupCovered) {
          return {
            rideSubtotal: 0,
            processingFee: 0,
            total: 0,
            membershipLabel: tierLabel
          };
        }
        return baseResult;
      }

      return baseResult;
    }

    async function checkCooldown(userId, plan) {
      const normalizedPlan = normalizePlanKey(plan);
      if (normalizedPlan !== "uofa_unlimited" && normalizedPlan !== "nwa_unlimited") {
        return { allowed: true };
      }

      const coolMinutes = SURGE_MODE ? SURGE_COOLDOWN_MINUTES : UNLIMITED_COOLDOWN_MINUTES;

      const ridesRef = collection(db, "rideRequests");
      const qRef = query(
        ridesRef,
        where("userId", "==", userId),
        orderBy("createdAt", "desc"),
        limit(10)
      );

      const snap = await getDocs(qRef);
      if (snap.empty) return { allowed: true };

      let lastCompleted = null;
      snap.forEach((docSnap) => {
        if (lastCompleted) return;
        const data = docSnap.data();
        if (
          data.status === "completed" &&
          normalizePlanKey(data.membershipType) === normalizedPlan &&
          data.completedAt &&
          typeof data.completedAt.toDate === "function"
        ) {
          lastCompleted = data;
        }
      });

      if (!lastCompleted) return { allowed: true };

      const completedAt = lastCompleted.completedAt.toDate();
      const diffMs = Date.now() - completedAt.getTime();
      const diffMin = diffMs / 60000;
      if (diffMin >= coolMinutes) return { allowed: true };

      return {
        allowed: false,
        remainingMinutes: Math.ceil(coolMinutes - diffMin)
      };
    }

    function formatTripEstimate(data) {
      const estMinutes =
        data && typeof data.estimatedDurationMinutes === "number"
          ? data.estimatedDurationMinutes
          : null;
      if (!estMinutes) return "";
      if (estMinutes < 1) return "Trip under 1 minute.";
      if (estMinutes < 10) return `Estimated trip: ~${estMinutes.toFixed(1)} min.`;
      return `Estimated trip: about ${Math.round(estMinutes)} min.`;
    }

    function normalizeRiderStatus(data) {
      const status = (data?.status || "").toLowerCase();
      if (status === "driver_arrived") return "arrived_at_pickup";
      if (status === "in_progress") return "pickup_code_verified";
      return status;
    }

    function getStateElementByState(state) {
      switch (state) {
        case RIDER_STATES.SEARCHING:
          return riderStateElements.searching;
        case RIDER_STATES.DRIVER_TO_PICKUP:
          return riderStateElements.driverEta;
        case RIDER_STATES.PICKUP_PIN:
          return riderStateElements.pickupPin;
        case RIDER_STATES.IN_TRIP:
          return riderStateElements.inTrip;
        case RIDER_STATES.DROPOFF_PIN:
          return riderStateElements.dropoffPin;
        case RIDER_STATES.RATE_TIP:
          return riderStateElements.rateTip;
        case RIDER_STATES.THANKS:
          return riderStateElements.thanks;
        default:
          return null;
      }
    }

    function setRiderOverlayState(state) {
      riderOverlayState = state;
      if (state === RIDER_STATES.HIDDEN) {
        if (driverInfoStack) {
          driverInfoStack.style.display = "none";
        }
        if (driverMiniMapShell) {
          driverMiniMapShell.style.display = "none";
          setDriverMiniMapStatus("");
        }
        riderOverlay?.classList.remove("active");
        return;
      }

      Object.values(riderStateElements).forEach((el) => el?.classList.remove("active"));
      const target = getStateElementByState(state);
      if (target) {
        target.classList.add("active");
      }

      riderOverlay?.classList.add("active");

      if (driverInfoStack) {
        const needsDriverInfo =
          state === RIDER_STATES.DRIVER_TO_PICKUP || state === RIDER_STATES.IN_TRIP;
        if (needsDriverInfo) {
          const slot =
            state === RIDER_STATES.DRIVER_TO_PICKUP ? driverInfoSlotPickup : driverInfoSlotTrip;
          if (slot) {
            slot.appendChild(driverInfoStack);
            driverInfoStack.style.display = "flex";
            refreshDriverMiniMap();
          }
        } else {
          driverInfoStack.style.display = "none";
          if (driverMiniMapShell) {
            driverMiniMapShell.style.display = "none";
            setDriverMiniMapStatus("");
          }
        }
      }
      maybeToggleWaitlistPanel();
      if (
        state === RIDER_STATES.RATE_TIP &&
        joinGuestBypassActive &&
        guestContributionState.tipCents > 0 &&
        profileMessage
      ) {
        profileMessage.textContent = `Tip reminder: you set aside ${formatCurrencyFromCents(
          guestContributionState.tipCents
        )} for your driver. Adjust any time before submitting.`;
      }
    }

    function setOverlayCopy(title, subtitle) {
      if (riderOverlayTitle) riderOverlayTitle.textContent = title || "RideSync";
      if (riderOverlaySubtitle) riderOverlaySubtitle.textContent = subtitle || "";
    }

    function activateWaitlistPanel() {
      if (!riderWaitlistPanel) return;
      if (!waitlistState.active) {
        waitlistState.active = true;
      }
      riderWaitlistPanel.classList.add("active");
      riderWaitlistPanel.setAttribute("aria-hidden", "false");
      refreshWaitlistEtaEstimate(latestRideForOverlay?.data || null);
      if (!waitlistState.timerId) {
        waitlistState.timerId = window.setInterval(tickWaitlistTimer, 1000);
      }
      tickWaitlistTimer();
    }

    function deactivateWaitlistPanel() {
      if (waitlistState.timerId) {
        clearInterval(waitlistState.timerId);
        waitlistState.timerId = null;
      }
      waitlistState.active = false;
      clearWaitlistEta();
      if (riderWaitlistPanel) {
        riderWaitlistPanel.classList.remove("active");
        riderWaitlistPanel.setAttribute("aria-hidden", "true");
      }
      if (riderWaitlistTimerEl) {
        riderWaitlistTimerEl.textContent = "--:--";
      }
      if (riderWaitlistBadgeEl) {
        riderWaitlistBadgeEl.textContent = "";
        riderWaitlistBadgeEl.style.display = "none";
      }
    }

    function tickWaitlistTimer() {
      if (!waitlistState.active || !riderWaitlistTimerEl) {
        return;
      }
      if (typeof waitlistState.etaTargetTimestamp === "number") {
        const remainingSeconds = Math.max(
          0,
          Math.round((waitlistState.etaTargetTimestamp - Date.now()) / 1000)
        );
        riderWaitlistTimerEl.textContent = formatWaitlistClockValue(remainingSeconds);
        return;
      }
      riderWaitlistTimerEl.textContent = "--:--";
    }

    function formatWaitlistClockValue(totalSeconds) {
      const safeSeconds = Math.max(0, Math.round(totalSeconds));
      const minutes = String(Math.floor(safeSeconds / 60)).padStart(2, "0");
      const seconds = String(safeSeconds % 60).padStart(2, "0");
      return `${minutes}:${seconds}`;
    }

    function parseTimestampMillis(candidate) {
      if (!candidate) return null;
      try {
        if (typeof candidate.toDate === "function") {
          const date = candidate.toDate();
          return Number.isNaN(date.getTime()) ? null : date.getTime();
        }
        if (typeof candidate.seconds === "number") {
          return candidate.seconds * 1000;
        }
        if (typeof candidate === "number") {
          return candidate > 1e12 ? candidate : candidate * 1000;
        }
        if (typeof candidate === "string") {
          const parsed = Date.parse(candidate);
          return Number.isNaN(parsed) ? null : parsed;
        }
      } catch (_) {
        return null;
      }
      return null;
    }

    function deriveRideRecencyTimestamp(ride = {}) {
      const recencyCandidates = [
        ride.updatedAt,
        ride.updated_at,
        ride.createdAt,
        ride.created_at,
        ride.cachedAt,
        ride.completedAt,
        ride.dropoffCompletedAt,
        ride.dropoff_code_verified_at,
      ];
      for (const field of recencyCandidates) {
        const millis = parseTimestampMillis(field);
        if (typeof millis === "number") {
          return millis;
        }
      }
      return null;
    }

    function isRideResumeEligible(ride = {}) {
      const normalizedStatus = normalizeRideStatusForProtection(ride.status);
      if (!normalizedStatus || TERMINAL_RIDE_STATUSES.has(normalizedStatus)) {
        return false;
      }
      const rideTimestamp = deriveRideRecencyTimestamp(ride);
      if (rideTimestamp == null) {
        return true;
      }
      const ageMinutes = (Date.now() - rideTimestamp) / 60000;
      return ageMinutes <= MAX_RIDE_RESUME_AGE_MINUTES;
    }

    function resolveRidePickupEtaSeconds(ride) {
      if (!ride) return null;
      const minuteFields = [
        "driverEtaMinutes",
        "pickupEtaMinutes",
        "matchEtaMinutes",
        "estimatedPickupMinutes",
        "estimatedDriverEtaMinutes",
        "waitlistEtaMinutes"
      ];
      for (const field of minuteFields) {
        if (Object.prototype.hasOwnProperty.call(ride, field)) {
          const minutes = Number(ride[field]);
          if (Number.isFinite(minutes) && minutes > 0) {
            return Math.round(minutes * 60);
          }
        }
      }
      const secondFields = [
        "driverEtaSeconds",
        "pickupEtaSeconds",
        "matchEtaSeconds",
        "waitlistEtaSeconds"
      ];
      for (const field of secondFields) {
        if (Object.prototype.hasOwnProperty.call(ride, field)) {
          const seconds = Number(ride[field]);
          if (Number.isFinite(seconds) && seconds > 0) {
            return Math.round(seconds);
          }
        }
      }
      const timestampFields = [
        "reservePickupAt",
        "reserveTimeIso",
        "reservePickupTime",
        "scheduledPickupAt"
      ];
      for (const field of timestampFields) {
        if (!Object.prototype.hasOwnProperty.call(ride, field)) {
          continue;
        }
        const millis = parseTimestampMillis(ride[field]);
        if (typeof millis === "number") {
          const diffSeconds = Math.round((millis - Date.now()) / 1000);
          if (diffSeconds > 0) {
            return diffSeconds;
          }
        }
      }
      return null;
    }

    function estimateWaitSecondsFromAvailability() {
      const online = Number(driverAvailability.onlineCount || 0);
      const busy = Math.min(getBusyOnlineDriverCount(), online);
      if (online <= 0) {
        return Math.round(Math.max(1, WAITLIST_OFFLINE_MINUTES) * 60);
      }
      const available = online - busy;
      if (available > 0) {
        return Math.round(Math.max(0.5, WAITLIST_AVAILABLE_DRIVER_MINUTES) * 60);
      }
      const estimateMinutes = Math.min(
        WAITLIST_MAX_FALLBACK_MINUTES,
        WAITLIST_BUSY_BASE_MINUTES + Math.max(1, busy) * WAITLIST_PER_BUSY_DRIVER_MINUTES
      );
      return Math.round(Math.max(estimateMinutes, 1) * 60);
    }

    function setWaitlistEtaSeconds(seconds, source = "ride") {
      if (!Number.isFinite(seconds) || seconds <= 0) {
        clearWaitlistEta();
        return;
      }
      waitlistState.etaSource = source;
      waitlistState.etaTargetTimestamp = Date.now() + Math.round(seconds) * 1000;
      if (waitlistState.active) {
        tickWaitlistTimer();
      }
    }

    function clearWaitlistEta() {
      waitlistState.etaTargetTimestamp = null;
      waitlistState.etaSource = null;
      if (waitlistState.active && riderWaitlistTimerEl) {
        riderWaitlistTimerEl.textContent = "--:--";
      }
    }

    function refreshWaitlistEtaEstimate(rideData = null) {
      const waitingViewActive =
        waitlistState.active || riderOverlayState === RIDER_STATES.SEARCHING;
      if (!waitingViewActive) {
        clearWaitlistEta();
        return;
      }
      const directSeconds = resolveRidePickupEtaSeconds(rideData);
      if (directSeconds != null) {
        setWaitlistEtaSeconds(directSeconds, "ride");
        return;
      }
      const fallbackSeconds = estimateWaitSecondsFromAvailability();
      if (!fallbackSeconds) {
        clearWaitlistEta();
        return;
      }
      if (
        waitlistState.etaSource === "ride" &&
        waitlistState.etaTargetTimestamp &&
        waitlistState.etaTargetTimestamp > Date.now()
      ) {
        return;
      }
      const fallbackTarget = Date.now() + fallbackSeconds * 1000;
      if (
        !waitlistState.etaTargetTimestamp ||
        Math.abs(waitlistState.etaTargetTimestamp - fallbackTarget) >
          WAITLIST_FALLBACK_REFRESH_THRESHOLD_MS
      ) {
        setWaitlistEtaSeconds(fallbackSeconds, "fallback");
      }
    }

    function getBusyOnlineDriverCount() {
      if (!driverAvailability.onlineIds || !driverAvailability.onlineIds.size) {
        return Math.min(driverAvailability.busyDriverIds.size, driverAvailability.onlineCount);
      }
      let count = 0;
      driverAvailability.busyDriverIds.forEach((driverId) => {
        if (driverAvailability.onlineIds.has(driverId)) {
          count += 1;
        }
      });
      return count;
    }

    function updateWaitlistCopy() {
      if (riderWaitlistStatusEl) {
        const online = driverAvailability.onlineCount;
        const busy = Math.min(getBusyOnlineDriverCount(), online);
        if (online > 0) {
          const label = online === 1 ? "driver is" : "drivers are";
          if (busy >= online) {
            riderWaitlistStatusEl.textContent = `All ${online} online ${label} currently on trips. We’ll connect you as soon as one finishes.`;
          } else {
            const available = online - busy;
            const availLabel = available === 1 ? "driver" : "drivers";
            riderWaitlistStatusEl.textContent = `${available} ${availLabel} getting ready now.`;
          }
        } else {
          riderWaitlistStatusEl.textContent = "Checking for online drivers nearby…";
        }
      }
      if (riderWaitlistBadgeEl) {
        const online = driverAvailability.onlineCount;
        const busy = Math.min(getBusyOnlineDriverCount(), online);
        if (online > 0) {
          riderWaitlistBadgeEl.textContent = `${busy} / ${online} drivers busy`;
          riderWaitlistBadgeEl.style.display = "inline-flex";
        } else {
          riderWaitlistBadgeEl.textContent = "";
          riderWaitlistBadgeEl.style.display = "none";
        }
      }
    }

    function maybeToggleWaitlistPanel() {
      if (!riderWaitlistPanel) return;
      const waitingOnDrivers =
        WAITLIST_RIDE_STATUSES.has(currentRideStatus) ||
        riderOverlayState === RIDER_STATES.SEARCHING;
      const online = driverAvailability.onlineCount;
      const busy = getBusyOnlineDriverCount();
      const available = online - busy;
      const shouldShow = waitingOnDrivers && online > 0 && available <= 0;
      if (shouldShow) {
        updateWaitlistCopy();
        refreshWaitlistEtaEstimate(latestRideForOverlay?.data || null);
        activateWaitlistPanel();
      } else if (waitlistState.active) {
        deactivateWaitlistPanel();
      }
    }

    function startDriverAvailabilityWatchers() {
      if (driverOnlineUnsub || driverBusyUnsub) return;
      try {
        const onlineQuery = query(collection(db, "drivers"), where("isOnline", "==", true));
        driverOnlineUnsub = onSnapshot(
          onlineQuery,
          (snap) => {
            stopDriverAvailabilityPolling();
            const ids = new Set();
            snap.forEach((docSnap) => ids.add(docSnap.id));
            driverAvailability.onlineIds = ids;
            driverAvailability.onlineCount = ids.size;
            updateWaitlistCopy();
            maybeToggleWaitlistPanel();
          },
          (err) => {
            console.warn("driver availability watcher error", err);
            driverOnlineUnsub = null;
            handleDriverAvailabilityPermissionError(err);
          }
        );
      } catch (err) {
        console.warn("driver availability query error", err);
        handleDriverAvailabilityPermissionError(err);
      }

      try {
        const busyQuery = query(
          collection(db, "rideRequests"),
          where("status", "in", DRIVER_BUSY_STATUSES)
        );
        driverBusyUnsub = onSnapshot(
          busyQuery,
          (snap) => {
            stopDriverAvailabilityPolling();
            const ids = new Set();
            snap.forEach((docSnap) => {
              const data = docSnap.data();
              const driverId = data?.driverId || data?.assignedDriverId || null;
              if (driverId) {
                ids.add(driverId);
              }
            });
            driverAvailability.busyDriverIds = ids;
            updateWaitlistCopy();
            maybeToggleWaitlistPanel();
          },
          (err) => {
            console.warn("driver busy watcher error", err);
            driverBusyUnsub = null;
            handleDriverAvailabilityPermissionError(err);
          }
        );
      } catch (err) {
        console.warn("driver busy query error", err);
        handleDriverAvailabilityPermissionError(err);
      }
    }

    function stopDriverAvailabilityWatchers() {
      if (driverAvailabilityUnsub) {
        driverAvailabilityUnsub();
        driverAvailabilityUnsub = null;
      }
      setDriverAvailabilityState(false);
      if (driverOnlineUnsub) {
        driverOnlineUnsub();
        driverOnlineUnsub = null;
      }
      if (driverBusyUnsub) {
        driverBusyUnsub();
        driverBusyUnsub = null;
      }
      driverAvailability.onlineCount = 0;
      driverAvailability.onlineIds = new Set();
      driverAvailability.busyDriverIds = new Set();
      deactivateWaitlistPanel();
      stopDriverAvailabilityPolling();
    }

    function updateDriverModules(data) {
      renderDriverIdentity(data);
      renderVehicleSection(data);
      renderLicenseSection(data);
      updateDriverMiniMap(data);
      supportPanel?.classList.remove("active");
    }

    function sanitizeRideChatText(value) {
      if (typeof value !== "string") return "";
      return value.replace(/[&<>]/g, (char) => {
        switch (char) {
          case "&":
            return "&amp;";
          case "<":
            return "&lt;";
          case ">":
            return "&gt;";
          default:
            return char;
        }
      });
    }

    function formatRideChatTimestamp(ts) {
      if (!ts) return "";
      try {
        const date =
          typeof ts.toDate === "function"
            ? ts.toDate()
            : typeof ts.seconds === "number"
            ? new Date(ts.seconds * 1000)
            : new Date(ts);
        if (Number.isNaN(date.getTime())) {
          return "";
        }
        return date.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
      } catch (_) {
        return "";
      }
    }

    function ensureRideChatCardVisible() {
      if (rideChatCard) {
        rideChatCard.style.display = "flex";
      }
    }

    function hideRideChatCard() {
      if (rideChatCard) {
        rideChatCard.style.display = "none";
      }
    }

    function setRideChatNote(message = "") {
      if (!rideChatOfflineNote) return;
      if (message) {
        rideChatOfflineNote.textContent = message;
        rideChatOfflineNote.style.display = "block";
      } else {
        rideChatOfflineNote.textContent = "";
        rideChatOfflineNote.style.display = "none";
      }
    }

    function setRideChatUiEnabled(enabled, noteMessage = "") {
      if (rideChatInputEl) {
        rideChatInputEl.disabled = !enabled;
      }
      if (rideChatSendButton) {
        rideChatSendButton.disabled = !enabled;
      }
      if (!enabled && noteMessage) {
        setRideChatNote(noteMessage);
      } else if (enabled) {
        setRideChatNote("");
      }
    }

    function renderRideChatMessages(docs) {
      if (!rideChatMessagesEl) return;
      const atBottom =
        rideChatMessagesEl.scrollHeight - rideChatMessagesEl.scrollTop - rideChatMessagesEl.clientHeight <
        40;
      rideChatMessagesEl.innerHTML = "";
      if (!docs?.length) {
        const placeholder = document.createElement("div");
        placeholder.className = "ride-chat-placeholder";
        placeholder.textContent = "No messages yet. Say hi!";
        rideChatMessagesEl.appendChild(placeholder);
        return;
      }
      docs.forEach((docSnap) => {
        const data = docSnap.data() || {};
        const senderRole = (data.senderRole || "").toLowerCase() === "driver" ? "driver" : "rider";
        const senderId = data.senderUserId || "";
        const isSelf = senderId && senderId === auth.currentUser?.uid;
        const item = document.createElement("div");
        item.className = `ride-chat-message ${isSelf ? "from-self" : "from-peer"}`;

        const bubble = document.createElement("div");
        bubble.className = "ride-chat-bubble";
        bubble.innerHTML = sanitizeRideChatText(data.text || "");

        const meta = document.createElement("div");
        meta.className = "ride-chat-meta";
        const nameLabel = isSelf ? "You" : senderRole === "driver" ? "Driver" : "Rider";
        const timeLabel = formatRideChatTimestamp(data.createdAt);
        meta.textContent = timeLabel ? `${nameLabel} • ${timeLabel}` : nameLabel;

        item.appendChild(bubble);
        item.appendChild(meta);
        rideChatMessagesEl.appendChild(item);
      });
      if (atBottom) {
        rideChatMessagesEl.scrollTop = rideChatMessagesEl.scrollHeight;
      }
    }

    function teardownRideChat(hideCard = false) {
      if (rideChatUnsub) {
        rideChatUnsub();
        rideChatUnsub = null;
      }
      rideChatCurrentRideId = null;
      if (rideChatMessagesEl) {
        rideChatMessagesEl.innerHTML = "";
      }
      setRideChatUiEnabled(false);
      if (hideCard) {
        hideRideChatCard();
      }
    }

    function initRideChat(rideId) {
      if (!rideId || !rideChatMessagesEl) {
        teardownRideChat(true);
        return;
      }
      if (rideChatCurrentRideId === rideId && rideChatUnsub) {
        ensureRideChatCardVisible();
        setRideChatUiEnabled(true);
        return;
      }
      teardownRideChat();
      rideChatCurrentRideId = rideId;
      ensureRideChatCardVisible();
      const messagesRef = collection(db, "ride_chats", rideId, "messages");
      const chatQuery = query(messagesRef, orderBy("createdAt", "asc"), limit(RIDE_CHAT_FETCH_LIMIT));
      rideChatUnsub = onSnapshot(
        chatQuery,
        (snapshot) => {
          renderRideChatMessages(snapshot.docs);
        },
        (err) => {
          console.warn("ride chat watcher error", err);
          setRideChatUiEnabled(false, "Chat is unavailable right now.");
        }
      );
    }

    function updateRideChatState(rideId, status) {
      const normalizedStatus = (status || "").toLowerCase();
      const isActive = rideId && RIDE_CHAT_ACTIVE_STATUSES.has(normalizedStatus);
      if (isActive) {
        initRideChat(rideId);
        setRideChatUiEnabled(true);
        return;
      }
      if (!rideId || RIDE_CHAT_TERMINAL_STATUSES.has(normalizedStatus)) {
        teardownRideChat(true);
        return;
      }
      teardownRideChat(true);
      setRideChatUiEnabled(false, "Chat becomes available once a driver is on the way.");
    }

    async function handleRideChatSend() {
      if (!rideChatInputEl || !rideChatSendButton) return;
      if (!rideChatCurrentRideId) return;
      const user = auth.currentUser;
      if (!user) {
        setRideChatUiEnabled(false, "Sign in to chat with your driver.");
        return;
      }
      const rawValue = rideChatInputEl.value || "";
      const trimmed = rawValue.trim();
      if (!trimmed) return;
      const normalized = trimmed.slice(0, RIDE_CHAT_MAX_LENGTH);
      const now = Date.now();
      if (now - rideChatLastSendAt < RIDE_CHAT_RATE_LIMIT_MS) {
        setRideChatNote("Please wait a moment before sending another message.");
        return;
      }
      rideChatSendButton.disabled = true;
      rideChatInputEl.disabled = true;
      try {
        const messagesRef = collection(db, "ride_chats", rideChatCurrentRideId, "messages");
        const messageRef = doc(messagesRef);
        await setDoc(messageRef, {
          rideId: rideChatCurrentRideId,
          messageId: messageRef.id,
          senderRole: "rider",
          senderUserId: user.uid,
          text: normalized,
          createdAt: serverTimestamp()
        });
        rideChatLastSendAt = now;
        rideChatInputEl.value = "";
        setRideChatUiEnabled(true);
        setRideChatNote("");
        if (rideChatMessagesEl) {
          rideChatMessagesEl.scrollTop = rideChatMessagesEl.scrollHeight;
        }
      } catch (err) {
        console.error("ride chat send error", err);
        setRideChatNote("Unable to send message. Try again in a moment.");
      } finally {
        rideChatInputEl.disabled = false;
        rideChatSendButton.disabled = false;
      }
    }

    function formatPinValue(value) {
      if (value == null) return "----";
      const str = String(value).trim().toUpperCase();
      if (!str) return "----";
      return str.split("").join(" ");
    }

    function updatePickupPinDisplay(code) {
      if (riderPickupPinValue) {
        riderPickupPinValue.textContent = formatPinValue(code);
      }
    }

    function updateDropoffPinDisplay(code) {
      if (riderDropoffPinValue) {
        riderDropoffPinValue.textContent = formatPinValue(code);
      }
    }

    function hasRiderRating(data) {
      return (
        typeof data?.rating === "number" ||
        typeof data?.riderRating === "number"
      );
    }

    function handleRideSnapshot(rideId, data) {
      latestRideForOverlay = { rideId, data };
      const status = normalizeRiderStatus(data);
      const waitingOnDriver = WAITLIST_RIDE_STATUSES.has(status);
      if (!waitingOnDriver) {
        clearWaitlistEta();
      }
      rememberRideCompletionContext(status, data);
      const destinationLabel =
        data.toDestination || data.toAddress || data.destAddress || "Destination";
      refreshRideTipCaptureState(rideId, data);

      if (status === "canceled_by_driver" || status === "driver_declined") {
        const declineCopy =
          status === "driver_declined"
            ? "Driver declined your ride. Choose a destination to try again."
            : "Driver canceled your ride. You're back on the home screen.";
        returnToHomeAfterRide(declineCopy, true);
        return;
      }

      if (status === "canceled_by_rider") {
        returnToHomeAfterRide("Ride canceled.");
        return;
      }

      switch (status) {
        case "pending_driver":
        case "pending":
        case "pool_searching":
        case "pooled_pending_driver":
          setOverlayCopy("Syncing your ride", "Looking for a verified driver…");
          setRiderOverlayState(RIDER_STATES.SEARCHING);
          refreshWaitlistEtaEstimate(data);
          break;
        case "driver_assigned":
          updateDriverModules(data);
          setOverlayCopy("Driver en route", destinationLabel);
          setRiderOverlayState(RIDER_STATES.DRIVER_TO_PICKUP);
          break;
        case "arrived_at_pickup":
          updatePickupPinDisplay(getPickupCodeFromRide(data));
          setOverlayCopy("Share your pickup code", "Only give this to your driver.");
          setRiderOverlayState(RIDER_STATES.PICKUP_PIN);
          break;
        case "pickup_code_verified":
          updateDriverModules(data);
          riderTripEtaText.textContent =
            formatTripEstimate(data) || "Sit back and relax.";
          setOverlayCopy("On the way", destinationLabel);
          setRiderOverlayState(RIDER_STATES.IN_TRIP);
          break;
        case "arrived_at_dropoff":
          updateDropoffPinDisplay(getDropoffCodeFromRide(data));
          setOverlayCopy("Share your dropoff code", "Tell your driver to finish the ride.");
          setRiderOverlayState(RIDER_STATES.DROPOFF_PIN);
          break;
        case "dropoff_code_verified":
        case "completed": {
          const needsCapture = rideRequiresFarePayment(data) > 0;
          if (needsCapture) {
            resetRatingForm();
            setOverlayCopy("Rate & finish payment", "Adjust your tip and leave feedback.");
            setRiderOverlayState(RIDER_STATES.RATE_TIP);
            break;
          }
          if (hasRiderRating(data)) {
            setOverlayCopy("All set", "Thanks for riding with RideSync.");
            setRiderOverlayState(RIDER_STATES.THANKS);
            setTimeout(() => returnToHomeAfterRide("Thanks for riding!"), 1800);
          } else {
            resetRatingForm();
            setOverlayCopy("Rate your ride", "Let us know how it went.");
            setRiderOverlayState(RIDER_STATES.RATE_TIP);
          }
          break;
        }
        default:
          updateDriverModules(data);
          setOverlayCopy("Ride update", destinationLabel);
          setRiderOverlayState(RIDER_STATES.DRIVER_TO_PICKUP);
      }
      updateRideChatState(rideId, status);
      maybeToggleWaitlistPanel();
    }

    function resetRatingForm() {
      selectedRating = 0;
      ratingSubmitting = false;
      ratingError.textContent = "";
      riderFeedbackInput.value = "";
      updateRatingButtons();
    }

    function updateRatingButtons() {
      if (!ratingStarsContainer) return;
      ratingStarsContainer.querySelectorAll("button[data-rating]").forEach((btn) => {
        const value = Number(btn.dataset.rating);
        btn.classList.toggle("active", value <= selectedRating);
      });
    }

    function handleRatingStarClick(event) {
      const button = event.target.closest("button[data-rating]");
      if (!button) return;
      const value = Number(button.dataset.rating);
      if (Number.isNaN(value)) return;
      selectedRating = value;
      updateRatingButtons();
    }

    async function submitRideRating() {
      ratingError.textContent = "";
      if (ratingSubmitting) return;
      if (!currentRideId) {
        ratingError.textContent = "Ride not found.";
        return;
      }
      if (selectedRating < 1) {
        ratingError.textContent = "Select a rating.";
        return;
      }
      ratingSubmitting = true;
      submitRatingButton.disabled = true;
      try {
        await submitRideRatingFn({
          rideId: currentRideId,
          rating: selectedRating,
          feedback: riderFeedbackInput.value.trim() || null,
        });
        setOverlayCopy("Thank you!", "Sending your feedback now.");
        setRiderOverlayState(RIDER_STATES.THANKS, { forceReveal: true });
        setTimeout(() => returnToHomeAfterRide("Thanks for riding!"), 2000);
      } catch (err) {
        console.error("submitRating error", err);
        ratingError.textContent = err.message || "Could not submit rating.";
      } finally {
        ratingSubmitting = false;
        submitRatingButton.disabled = false;
      }
    }

    function getPickupCodeFromRide(ride) {
      return (
        ride?.pickupCode ??
        ride?.pickup_code ??
        ride?.pickupPin ??
        ride?.pickupPIN ??
        ride?.boardingCode ??
        null
      );
    }

    function getDropoffCodeFromRide(ride) {
      return (
        ride?.dropoffCode ??
        ride?.dropoff_code ??
        ride?.dropoffPin ??
        ride?.dropoffPIN ??
        ride?.dropoffBoardingCode ??
        null
      );
    }

    function startRideStatusWatcher(rideId) {
      if (currentRideWatcher) {
        currentRideWatcher();
        currentRideWatcher = null;
      }
      const rideRef = doc(db, "rideRequests", rideId);
      currentRideWatcher = onSnapshot(rideRef, (snap) => {
        if (!snap.exists()) return;
        const data = snap.data();
        currentRideStatus = data.status || null;
        updateCancelButtonVisibility();
        rememberRideProtectionState(rideId, data);
        handleRideSnapshot(rideId, data);
      });
    }
      
    function updateSyncRidersOccupancyLabel(text) {
      if (!syncRidersModalOccupancy) return;
      if (text) {
        syncRidersModalOccupancy.textContent = text;
        syncRidersModalOccupancy.style.display = "block";
      } else {
        syncRidersModalOccupancy.textContent = "";
        syncRidersModalOccupancy.style.display = "none";
      }
    }

    function openSyncRidersOverlay(rideId) {
      if (!rideId || !syncRidersOverlay || !syncRidersModalCanvas) {
        return;
      }
      const joinUrl = buildJoinUrl(rideId);
      syncRidersJoinUrl = joinUrl;
      if (!syncRidersQr) {
        syncRidersQr = new QRious({
          element: syncRidersModalCanvas,
          size: 220,
          value: joinUrl
        });
      } else {
        syncRidersQr.set({ value: joinUrl });
      }
      const existingOccupancy = groupOccupancyLabel?.textContent?.trim();
      if (existingOccupancy) {
        updateSyncRidersOccupancyLabel(existingOccupancy);
      } else if (!activeRideIsGroup) {
        updateSyncRidersOccupancyLabel("");
      }
      if (syncRidersCopyFeedback) {
        syncRidersCopyFeedback.textContent = "";
      }
      syncRidersFlowActive = false;
      syncRidersAwaitingRideActivation = false;
      toggleOverlay(syncRidersOverlay, true, syncRidersOverlayClose);
    }

    function closeSyncRidersOverlay() {
      if (!syncRidersOverlay) return;
      toggleOverlay(syncRidersOverlay, false);
    }

    function hideGroupQr() {
      setGroupQrVisibility(false);
      if (groupQrIntro) {
        groupQrIntro.style.display = "none";
      }
      if (groupQrCanvas) {
        groupQrCanvas.style.display = "none";
      }
      if (groupQrPendingMessage) {
        groupQrPendingMessage.textContent = "";
        groupQrPendingMessage.style.display = "none";
      }
      if (groupOccupancyLabel) {
        groupOccupancyLabel.textContent = "";
        groupOccupancyLabel.style.display = "none";
      }
      if (groupOccupancyUnsub) {
        groupOccupancyUnsub();
        groupOccupancyUnsub = null;
      }
      updateSyncRidersOccupancyLabel("");
    }

    function showGroupQrPlaceholder(message) {
      if (!groupQrSection) return;
      if (groupOccupancyUnsub) {
        groupOccupancyUnsub();
        groupOccupancyUnsub = null;
      }
      setGroupQrVisibility(true);
      if (groupQrIntro) {
        groupQrIntro.style.display = "block";
      }
      if (groupQrPendingMessage) {
        const placeholderMessage =
          message ||
          (isGuestBypassEnabled()
            ? "Guest Sync ready. Sync your ride, then tap Sync QR so friends can skip accounts and chip in."
            : "Sync your ride first, then tap Sync QR to open the overlay code.");
        groupQrPendingMessage.textContent = placeholderMessage;
        groupQrPendingMessage.style.display = "block";
      }
      if (groupQrCanvas) {
        groupQrCanvas.style.display = "none";
      }
      if (groupOccupancyLabel) {
        groupOccupancyLabel.textContent = "";
        groupOccupancyLabel.style.display = "none";
      }
      updateSyncRidersOccupancyLabel("");
    }

    function showGroupQr(rideId) {
      if (!groupQrSection) return;
      if (!rideId) {
        showGroupQrPlaceholder();
        return;
      }
      setGroupQrVisibility(true);
      if (groupQrIntro) {
        groupQrIntro.style.display = "block";
      }
      if (groupQrPendingMessage) {
        groupQrPendingMessage.textContent = "";
        groupQrPendingMessage.style.display = "none";
      }
      if (groupQrCanvas) {
        groupQrCanvas.style.display = "none";
      }
      if (groupOccupancyLabel) {
        groupOccupancyLabel.style.display = "block";
      }
      updateSyncRidersOccupancyLabel(groupOccupancyLabel?.textContent || "");
      activeRideIsGroup = true;
      wantsGroupRide = true;
      startGroupOccupancyWatcher(rideId);
    }

    function isGuestBypassEnabled() {
      return Boolean(guestBypassEligible || activeRideGuestBypass);
    }

    function buildJoinUrl(rideId, options = {}) {
      if (!rideId) {
        return window.location.origin;
      }
      const { guestOverride = null } = options;
      const enableGuestParam =
        typeof guestOverride === "boolean"
          ? guestOverride
          : isGuestBypassEnabled();
      const params = new URLSearchParams({ join: rideId });
      if (enableGuestParam) {
        params.set("guest", "1");
      }
      return `${window.location.origin}?${params.toString()}`;
    }

    function updateGuestBypassCopy() {
      if (!groupQrIntro) return;
      if (isGuestBypassEnabled()) {
        groupQrIntro.textContent =
          "Guest Sync is on: friends skip the account screen, help pay now, and tip together at dropoff.";
      } else {
        groupQrIntro.textContent = groupQrIntroDefaultCopy;
      }
    }

    function enableJoinGuestBypassUi(hostRide = null) {
      if (joinGuestBypassActive) {
        if (guestContributionHint && hostRide?.toDestination) {
          guestContributionHint.textContent = `Breeze past the account screen. You're joining ${hostRide.toDestination}. Split the fare or tip below.`;
        }
        return;
      }
      joinGuestBypassActive = true;
      appBody?.classList?.add("guest-bypass-active");
      if (guestContributionCard) {
        guestContributionCard.style.display = "block";
      }
      if (guestContributionHint && hostRide?.toDestination) {
        guestContributionHint.textContent = `You're joining ${hostRide.toDestination}. Split the fare now or line up your tip.`;
      }
      if (rideViewTabMembership) {
        rideViewTabMembership.setAttribute("hidden", "true");
      }
      if (rideViewTabInfo) {
        rideViewTabInfo.setAttribute("hidden", "true");
      }
      updateGuestContributionSummary();
      if (profileMessage || profileError) {
        if (profileMessage) {
          profileMessage.textContent =
            "Guest Sync activated. Add your share or tip whenever you're ready.";
        }
        if (profileError) {
          profileError.textContent = "";
        }
      }
    }

    function disableJoinGuestBypassUi(options = {}) {
      const { force = false } = options;
      if (!joinGuestBypassActive && !force) {
        return;
      }
      joinGuestBypassActive = false;
      appBody?.classList?.remove("guest-bypass-active");
      if (rideViewTabMembership) {
        rideViewTabMembership.removeAttribute("hidden");
      }
      if (rideViewTabInfo) {
        rideViewTabInfo.removeAttribute("hidden");
      }
      if (guestContributionCard) {
        guestContributionCard.style.display = "none";
      }
      resetGuestContributionState();
    }

    function applyGuestBypassFromHost(hostRide = null) {
      const hostAllowsGuestBypass =
        hostRide?.guestBypassEnabled === true ||
        Number(hostRide?.maxRiders || 1) >= 3 ||
        joinGuestBypassRequested;
      if (hostAllowsGuestBypass) {
        enableJoinGuestBypassUi(hostRide);
      } else {
        disableJoinGuestBypassUi();
      }
    }

    function updateGuestContributionSummary() {
      if (!guestContributionSummary) return;
      if (!joinGuestBypassActive) {
        guestContributionSummary.textContent = "";
        return;
      }
      const parts = [];
      if (guestContributionState.shareCents > 0) {
        parts.push(`Paying ${formatCurrencyFromCents(guestContributionState.shareCents)}`);
      }
      if (guestContributionState.tipCents > 0) {
        parts.push(`Tip ready: ${formatCurrencyFromCents(guestContributionState.tipCents)}`);
      }
      guestContributionSummary.textContent =
        parts.length > 0
          ? parts.join(" • ")
          : "Set how much you want to cover or tip.";
    }

    function resetGuestContributionState() {
      guestContributionState = { shareCents: 0, tipCents: 0 };
      if (guestShareInput) guestShareInput.value = "";
      if (guestTipInput) guestTipInput.value = "";
      if (guestContributionSummary) guestContributionSummary.textContent = "";
    }

    function handleGuestShareSubmit() {
      if (!joinGuestBypassActive) return;
      const dollars = Number(guestShareInput?.value || 0);
      const cents = Math.max(0, dollarsToCents(dollars));
      guestContributionState.shareCents = cents;
      updateGuestContributionSummary();
      if (profileMessage) {
        profileMessage.textContent =
          cents > 0
            ? `Thanks! We'll flag ${formatCurrencyFromCents(cents)} as your share.`
            : "Contribution cleared.";
      }
    }

    function handleGuestTipSubmit() {
      if (!joinGuestBypassActive) return;
      const dollars = Number(guestTipInput?.value || 0);
      const cents = Math.max(0, dollarsToCents(dollars));
      guestContributionState.tipCents = cents;
      updateGuestContributionSummary();
      if (profileMessage) {
        profileMessage.textContent =
          cents > 0
            ? `Tip locked in at ${formatCurrencyFromCents(cents)} for dropoff.`
            : "Tip amount removed.";
      }
    }

    function updateSyncRidersButtonVisibility() {
      if (!syncRidersButton) return;
      const hasDestinationInput =
        typeof destinationEl?.value === "string" && destinationEl.value.trim().length > 0;
      const shouldShow = (wantsGroupRide && hasDestinationInput) || activeRideIsGroup;
      syncRidersButton.style.display = shouldShow ? "inline-flex" : "none";
    }

    function updateGroupRideIntentFromSelect() {
      if (!numRidersEl) {
        wantsGroupRide = false;
        refreshGroupQrVisibility();
        return;
      }
      const selectedValue = parseInt(numRidersEl.value || "1", 10);
      wantsGroupRide = selectedValue > 1;
      guestBypassEligible = selectedValue >= 3;
      appBody?.classList?.toggle("host-guest-bypass", guestBypassEligible || activeRideGuestBypass);
      updateGuestBypassCopy();
      refreshGroupQrVisibility();
      updateSyncRidersButtonVisibility();
    }

    function refreshGroupQrVisibility() {
      if (activeRideIsGroup && currentRideId) {
        showGroupQr(currentRideId);
        return;
      }
      if (wantsGroupRide) {
        showGroupQrPlaceholder();
        return;
      }
      hideGroupQr();
      updateSyncRidersButtonVisibility();
    }

    function startGroupOccupancyWatcher(rideId) {
      if (groupOccupancyUnsub) {
        groupOccupancyUnsub();
        groupOccupancyUnsub = null;
      }
      const rideRef = doc(db, "rideRequests", rideId);
      groupOccupancyUnsub = onSnapshot(rideRef, (snap) => {
        if (!snap.exists()) return;
        const data = snap.data();
        const cur = data.currentRiderCount || 1;
        const max = data.maxRiders || 1;
        if (groupOccupancyLabel) {
          groupOccupancyLabel.textContent = `Group: ${cur} of ${max} riders.`;
        }
        updateSyncRidersOccupancyLabel(`Group: ${cur} of ${max} riders.`);
        const groupFull = max > 0 && cur >= max;
        if (
          groupFull &&
          syncRidersOverlay?.classList?.contains("active")
        ) {
          closeSyncRidersOverlay();
          if (profileMessage) {
            profileMessage.textContent =
              "All riders joined. Sync your destination when you're ready.";
          }
        }
      });
    }

      cancelRideButton.addEventListener("click", async () => {
        cancelError.textContent = "";
        profileMessage.textContent = "";
        if (!currentRideId) {
          cancelError.textContent = "No active ride to cancel.";
          return;
        }

        if (currentRideStatus && !riderCancelableStatuses.has(currentRideStatus)) {
          cancelError.textContent = "Ride can no longer be canceled.";
          return;
        }

        try {
          await cancelRideRequestFn({ rideId: currentRideId });
          returnToHomeAfterRide("Ride canceled, you won't be charged.");
        } catch (err) {
          console.error(err);
          cancelError.textContent = err.message || "Could not cancel ride.";
        }
      });

    if (rideChatSendButton) {
      rideChatSendButton.addEventListener("click", handleRideChatSend);
    }
    if (rideChatInputEl) {
      rideChatInputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          handleRideChatSend();
        }
      });
    }

    // Rider overlay buttons
    if (ratingStarsContainer) {
      ratingStarsContainer.addEventListener("click", handleRatingStarClick);
    }
    if (submitRatingButton) {
      submitRatingButton.addEventListener("click", submitRideRating);
    }
    if (rideTipOptions) {
      rideTipOptions.addEventListener("click", handleRideTipButtonClick);
    }
    if (rideTipCustomInput) {
      rideTipCustomInput.addEventListener("input", handleRideTipCustomInput);
    }
    if (preauthTipOptions) {
      preauthTipOptions.addEventListener("click", handlePreauthTipButtonClick);
    }
    if (preauthTipCustomInput) {
      preauthTipCustomInput.addEventListener("input", handlePreauthTipCustomInput);
    }
    if (finalTipDecrease) {
      finalTipDecrease.addEventListener("click", () => adjustFinalTip(-100));
    }
    if (finalTipIncrease) {
      finalTipIncrease.addEventListener("click", () => adjustFinalTip(100));
    }
    if (finalTipInput) {
      finalTipInput.addEventListener("change", handleFinalTipInputChange);
      finalTipInput.addEventListener("input", handleFinalTipInputChange);
    }
    if (finalizeTipButton) {
      finalizeTipButton.addEventListener("click", handleFinalizeTipSubmit);
    }
    if (rideCheckoutButton) {
      rideCheckoutButton.addEventListener("click", handleRideCheckoutSubmit);
    }
    if (rideCardSubmit) {
      rideCardSubmit.addEventListener("click", handleRideCardSubmit);
    }
    if (guestShareButton) {
      guestShareButton.addEventListener("click", handleGuestShareSubmit);
    }
    if (guestTipButton) {
      guestTipButton.addEventListener("click", handleGuestTipSubmit);
    }

    if (membershipPlanGrid) {
      membershipPlanGrid.addEventListener("click", (event) => {
        const button = event.target.closest("[data-plan-action]");
        if (!button || button.disabled) {
          return;
        }
        const planKey = button.dataset.planAction;
        if (!planKey) return;
        handleMembershipPlanAction(planKey);
      });
    }

    if (membershipCheckoutButton) {
      membershipCheckoutButton.addEventListener("click", startMembershipCheckout);
    }
    if (membershipCheckoutClose) {
      membershipCheckoutClose.addEventListener("click", closeMembershipCheckoutOverlay);
    }
    if (membershipCheckoutCancel) {
      membershipCheckoutCancel.addEventListener("click", closeMembershipCheckoutOverlay);
    }
    if (membershipCheckoutOverlay) {
      membershipCheckoutOverlay.addEventListener("click", (event) => {
        if (event.target === membershipCheckoutOverlay) {
          closeMembershipCheckoutOverlay();
        }
      });
    }
    if (membershipCheckoutOptions) {
      membershipCheckoutOptions.addEventListener("click", (event) => {
        const option = event.target.closest("[data-membership-option]");
        if (!option || option.disabled) return;
        selectMembershipCheckoutPlan(option.dataset.membershipOption);
      });
    }

    if (cooldownDismissButton) {
      cooldownDismissButton.addEventListener("click", () => {
        hideCooldownOverlay();
      });
    }
    if (cooldownOverlay) {
      cooldownOverlay.addEventListener("click", (event) => {
        if (event.target === cooldownOverlay) {
          hideCooldownOverlay();
        }
      });
    }

    if (supportCallButton) {
      supportCallButton.href = SUPPORT_TEL_LINK;
    }
    if (supportTextButton) {
      supportTextButton.href = SUPPORT_SMS_LINK;
    }

    if (contactDriverBtn) {
      contactDriverBtn.addEventListener("click", () => {
        if (!supportPanel) return;
        supportPanel.classList.add("active");
        supportPanel.scrollIntoView({ behavior: "smooth", block: "start" });
      });
    }

    if (supportBackButton) {
      supportBackButton.addEventListener("click", () => {
        supportPanel?.classList.remove("active");
      });
    }

    // === RIDE SYNC STRIPE: overlay + status helpers ===
    const overlayFocusMemory = new WeakMap();
    const focusableOverlaySelector =
      "[data-default-focus], button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex='-1'])";

    function setMembershipMessage(text) {
      if (membershipCardMessage) {
        membershipCardMessage.textContent =
          text || MEMBERSHIP_CARD_DEFAULT_MESSAGE;
      }
    }

    function toggleOverlay(el, show, focusTarget) {
      if (!el) return;
      if (show) {
        if (document.activeElement instanceof HTMLElement) {
          overlayFocusMemory.set(el, document.activeElement);
        } else {
          overlayFocusMemory.delete(el);
        }
        el.classList.add("active");
        el.setAttribute("aria-hidden", "false");
        el.removeAttribute("inert");
        const preferredTarget =
          (focusTarget && typeof focusTarget.focus === "function" && focusTarget) ||
          el.querySelector("[data-default-focus]") ||
          el.querySelector(focusableOverlaySelector);
        if (preferredTarget && typeof preferredTarget.focus === "function") {
          requestAnimationFrame(() => preferredTarget.focus());
        }
      } else {
        el.classList.remove("active");
        el.setAttribute("aria-hidden", "true");
        el.setAttribute("inert", "");
        if (
          el.contains(document.activeElement) &&
          document.activeElement instanceof HTMLElement &&
          typeof document.activeElement.blur === "function"
        ) {
          document.activeElement.blur();
        }
        const previousFocus = overlayFocusMemory.get(el);
        overlayFocusMemory.delete(el);
        if (previousFocus && typeof previousFocus.focus === "function") {
          previousFocus.focus();
        }
      }
    }

    // === Rider sync confirmation overlay helpers ===
    function getDestinationSummaryText() {
      const typed = (destinationEl?.value || "").trim();
      if (typed) return typed;
      if (lastDestinationPlace?.name) {
        return lastDestinationPlace.name;
      }
      if (lastDestinationPlace?.formatted_address) {
        return lastDestinationPlace.formatted_address;
      }
      return "";
    }

    function getProfilePlanKey() {
      return normalizePlanKey(
        currentUserProfile?.membershipType ||
          currentUserProfile?.membership ||
          "basic"
      );
    }

    function isPlanSelectable(planKey, profile = currentUserProfile) {
      const normalized = normalizePlanKey(planKey);
      if (normalized === "basic") {
        return true;
      }
      return canStartMembershipCheckout(normalized, profile);
    }

    function getPlanLockReason(planKey) {
      const normalized = normalizePlanKey(planKey);
      if (normalized === "uofa_unlimited") {
        if (!currentUserProfile?.isStudent) {
          return "Only verified U of A students can activate this plan.";
        }
        if (!currentUserProfile?.uofaVerified) {
          return "Upload your student ID so RideSync can verify you.";
        }
      }
      if (normalized === "nwa_unlimited") {
        return "Contact RideSync support to unlock NWA Unlimited.";
      }
      return "";
    }

    function getDefaultSyncMembershipPlan() {
      const profilePlan = getProfilePlanKey();
      if (profilePlan === "uofa_unlimited" || profilePlan === "nwa_unlimited") {
        return profilePlan;
      }
      return "basic";
    }

    function initializeSyncMembershipSelection({ preserveSelection = false } = {}) {
      const profilePlan = getProfilePlanKey();
      let desiredPlan = preserveSelection
        ? normalizePlanKey(syncSelectedMembershipPlan || profilePlan || "basic")
        : getDefaultSyncMembershipPlan();
      if (
        desiredPlan !== "basic" &&
        desiredPlan !== profilePlan &&
        !isPlanSelectable(desiredPlan)
      ) {
        desiredPlan = getDefaultSyncMembershipPlan();
      }
      syncSelectedMembershipPlan = desiredPlan;
      syncMembershipTermsAccepted = false;
      if (syncMembershipTermsCheckbox) {
        syncMembershipTermsCheckbox.checked = false;
      }
      renderSyncMembershipOptions();
      updateSyncMembershipState();
    }

    function updateSyncMembershipHint(
      selectedPlan = syncSelectedMembershipPlan,
      profilePlan = getProfilePlanKey()
    ) {
      if (!syncMembershipHint) return;
      const planCopy =
        MEMBERSHIP_PLAN_COPY[selectedPlan] || MEMBERSHIP_PLAN_COPY.basic;
      if (selectedPlan === "basic") {
        const upgradeAvailable =
          canStartMembershipCheckout("uofa_unlimited") ||
          canStartMembershipCheckout("nwa_unlimited");
        syncMembershipHint.textContent = upgradeAvailable
          ? "Pay per ride with the fare shown above or pick an unlimited plan when you're ready."
          : "Pay per ride with standard fares. Contact RideSync support for membership changes.";
        return;
      }
      if (!syncMembershipUpgradeMode && selectedPlan === profilePlan) {
        syncMembershipHint.textContent = `${planCopy.label} is already active for your rides. Tips stay optional; contact RideSync support if you need to change plans.`;
        return;
      }
      const amountCents = resolvePlanPriceCents(selectedPlan);
      const amountLabel = amountCents
        ? formatCurrencyFromCents(amountCents, "usd")
        : formatPlanPriceLabel(selectedPlan);
      syncMembershipHint.textContent = `We'll redirect you to Stripe to pay ${amountLabel} for ${planCopy.label}. Tips remain separate after each trip.`;
    }

    function renderSyncMembershipOptions() {
      if (!syncMembershipList) return;
      const plans = ["basic", "uofa_unlimited", "nwa_unlimited"];
      const profilePlan = getProfilePlanKey();
      const selectedPlan = normalizePlanKey(
        syncSelectedMembershipPlan || getDefaultSyncMembershipPlan()
      );
      syncSelectedMembershipPlan = selectedPlan;
      const fragment = document.createDocumentFragment();
      plans.forEach((planKey) => {
        const planCopy =
          MEMBERSHIP_PLAN_COPY[planKey] || MEMBERSHIP_PLAN_COPY.basic;
        const lockReason = !isPlanSelectable(planKey)
          ? getPlanLockReason(planKey)
          : "";
        const isSelected = planKey === selectedPlan;
        const planSelectable =
          planKey === "basic" ||
          planKey === profilePlan ||
          isPlanSelectable(planKey);
        const helperCopy =
          planKey === "basic"
            ? "Pay per ride with standard fees."
            : lockReason || "Unlimited riders only pay tips after each trip.";
        const card = document.createElement("div");
        card.className = "sync-membership-card";
        if (isSelected) {
          card.classList.add("active");
        }
        if (!planSelectable) {
          card.classList.add("disabled");
        }
        card.dataset.plan = planKey;
        card.setAttribute("role", "radio");
        card.setAttribute("aria-checked", isSelected ? "true" : "false");
        card.setAttribute("aria-disabled", planSelectable ? "false" : "true");
        card.tabIndex = planSelectable ? 0 : -1;
        card.innerHTML = `
          <span class="plan-pill" aria-hidden="true"></span>
          <span class="plan-content">
            <span class="plan-label">${planCopy.label}</span>
            <span class="plan-price">${formatPlanPriceLabel(planKey)}</span>
            <p class="plan-desc">${planCopy.description}</p>
            <p class="plan-desc">${helperCopy}</p>
          </span>
        `;
        fragment.appendChild(card);
      });
      syncMembershipList.innerHTML = "";
      syncMembershipList.appendChild(fragment);
    }

    function resetSyncConfirmState() {
      syncConfirmState.reserveFeeCents = 0;
      syncConfirmState.reserveTimeIso = null;
      syncConfirmState.reserveMode = "asap";
      syncConfirmState.referral = {
        code: null,
        discountCents: 0,
        description: "",
      };
    }

    function getBaseFareCents() {
      const total = Number(lastRideMetrics?.fareBreakdown?.total || 0);
      if (!Number.isFinite(total)) {
        return 0;
      }
      return Math.max(0, Math.round(total * 100));
    }

    function getChargeableFareCents() {
      let cents = getBaseFareCents();
      cents += Math.max(0, Number(syncConfirmState.reserveFeeCents) || 0);
      cents -= Math.max(0, Number(syncConfirmState.referral.discountCents) || 0);
      return Math.max(0, cents);
    }

    function updateSyncConfirmTotalDisplay() {
      if (!syncConfirmTotal) return;
      if (syncMembershipUpgradeMode) {
        const cents = resolvePlanPriceCents(syncSelectedMembershipPlan);
        syncConfirmTotal.textContent = cents
          ? formatCurrencyFromCents(cents, "usd")
          : formatPlanPriceLabel(syncSelectedMembershipPlan);
        return;
      }
      const cents = getChargeableFareCents();
      syncConfirmTotal.textContent = cents
        ? formatCurrencyFromCents(cents, "usd")
        : "—";
    }

    function computeDefaultReserveDate() {
      const target = new Date();
      target.setMinutes(target.getMinutes() + RESERVATION_MIN_LEAD_MINUTES);
      return target;
    }

    function formatDateInputValue(date) {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
        return "";
      }
      const year = date.getFullYear();
      const month = `${date.getMonth() + 1}`.padStart(2, "0");
      const day = `${date.getDate()}`.padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    function formatTimeInputValue(date) {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
        return "";
      }
      const hours = `${date.getHours()}`.padStart(2, "0");
      const minutes = `${date.getMinutes()}`.padStart(2, "0");
      return `${hours}:${minutes}`;
    }

    function populateReserveTimeSelect() {
      if (!reserveTimeInput) return;
      if (!reserveTimeInput.step) {
        reserveTimeInput.step = "900"; // default to 15-minute increments
      }
      if (!reserveTimeInput.value) {
        reserveTimeInput.value = formatTimeInputValue(computeDefaultReserveDate());
      }
    }

    function formatLocalPickupTimeLabel(date) {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
        return "";
      }
      return date.toLocaleString([], {
        weekday: "short",
        hour: "numeric",
        minute: "2-digit",
      });
    }

    function updateReserveDateBounds() {
      if (!reserveDateInput) return;
      const now = new Date();
      const maxDate = new Date(now.getTime() + RESERVATION_MAX_LEAD_MINUTES * 60000);
      reserveDateInput.min = formatDateInputValue(now);
      reserveDateInput.max = formatDateInputValue(maxDate);
    }

    function setReserveInputsFromDate(date) {
      if (!reserveDateInput || !reserveTimeInput) return;
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
        const fallback = computeDefaultReserveDate();
        setReserveInputsFromDate(fallback);
        return;
      }
      reserveDateInput.value = formatDateInputValue(date);
      reserveTimeInput.value = formatTimeInputValue(date);
    }

    function resolveReserveInputDate() {
      if (!reserveDateInput || !reserveTimeInput) return null;
      const dateValue = reserveDateInput.value;
      const timeValue = reserveTimeInput.value;
      if (!dateValue || !timeValue) return null;
      const [year, month, day] = dateValue.split("-").map((part) => Number(part));
      const [hours, minutes] = timeValue.split(":").map((part) => Number(part));
      if (
        !Number.isFinite(year) ||
        !Number.isFinite(month) ||
        !Number.isFinite(day) ||
        !Number.isFinite(hours) ||
        !Number.isFinite(minutes)
      ) {
        return null;
      }
      const scheduled = new Date(year, month - 1, day, hours, minutes);
      if (Number.isNaN(scheduled.getTime())) {
        return null;
      }
      return scheduled;
    }

    function updateReserveModeUi() {
      const isScheduled = syncConfirmState.reserveMode === "schedule";
      if (reserveDateTimeRow) {
        reserveDateTimeRow.style.display = isScheduled ? "flex" : "none";
      }
      reserveModeRadios?.forEach?.((radio) => {
        radio.checked = radio.value === syncConfirmState.reserveMode;
      });
    }

    function updateReserveTimeHint(dateOverride = null, messageOverride = "") {
      if (!reserveTimeHint) return;
      if (messageOverride) {
        reserveTimeHint.textContent = messageOverride;
        return;
      }
      if (
        syncConfirmState.reserveMode !== "schedule" ||
        !syncConfirmState.reserveTimeIso
      ) {
        reserveTimeHint.textContent = "Scheduling a pickup adds a $5 reserve fee.";
        return;
      }
      const date =
        dateOverride instanceof Date
          ? dateOverride
          : new Date(syncConfirmState.reserveTimeIso);
      const label = formatLocalPickupTimeLabel(date);
      reserveTimeHint.textContent = label
        ? `Scheduled pickup at ${label}. A $5 reserve fee applies.`
        : "Scheduling a pickup adds a $5 reserve fee.";
    }

    function updateScheduledReserveState({ showErrors = true } = {}) {
      if (syncConfirmState.reserveMode !== "schedule") {
        syncConfirmState.reserveFeeCents = 0;
        syncConfirmState.reserveTimeIso = null;
        updateReserveTimeHint();
        updateSyncConfirmTotalDisplay();
        return { valid: true };
      }
      const targetDate = resolveReserveInputDate();
      if (!targetDate) {
        const message = "Choose both a date and time for your pickup.";
        if (showErrors) {
          updateReserveTimeHint(null, message);
        }
        syncConfirmState.reserveFeeCents = 0;
        syncConfirmState.reserveTimeIso = null;
        updateSyncConfirmTotalDisplay();
        return { valid: false, message };
      }
      const diffMinutes = (targetDate.getTime() - Date.now()) / 60000;
      if (diffMinutes < RESERVATION_MIN_LEAD_MINUTES) {
        const message = `Pick a time at least ${RESERVATION_MIN_LEAD_MINUTES} minutes from now.`;
        if (showErrors) {
          updateReserveTimeHint(null, message);
        }
        syncConfirmState.reserveFeeCents = 0;
        syncConfirmState.reserveTimeIso = null;
        updateSyncConfirmTotalDisplay();
        return { valid: false, message };
      }
      if (diffMinutes > RESERVATION_MAX_LEAD_MINUTES) {
        const message = "Pick a time within the next 24 hours.";
        if (showErrors) {
          updateReserveTimeHint(null, message);
        }
        syncConfirmState.reserveFeeCents = 0;
        syncConfirmState.reserveTimeIso = null;
        updateSyncConfirmTotalDisplay();
        return { valid: false, message };
      }
      syncConfirmState.reserveFeeCents = RESERVE_FEE_CENTS;
      syncConfirmState.reserveTimeIso = targetDate.toISOString();
      updateReserveTimeHint(targetDate);
      updateSyncConfirmTotalDisplay();
      return { valid: true };
    }

    function ensureValidReserveSelection({ showErrors = true } = {}) {
      if (syncConfirmState.reserveMode !== "schedule") {
        return { valid: true };
      }
      return updateScheduledReserveState({ showErrors });
    }

    function handleReserveModeChange(value) {
      const normalized = value === "schedule" ? "schedule" : "asap";
      if (syncConfirmState.reserveMode === normalized) return;
      syncConfirmState.reserveMode = normalized;
      if (normalized === "schedule" && !syncConfirmState.reserveTimeIso) {
        setReserveInputsFromDate(computeDefaultReserveDate());
      } else if (normalized === "asap") {
        syncConfirmState.reserveFeeCents = 0;
        syncConfirmState.reserveTimeIso = null;
      }
      updateReserveModeUi();
      updateScheduledReserveState({ showErrors: normalized === "schedule" });
    }

    function initializeReserveInputs({ preserveSelection = false } = {}) {
      updateReserveDateBounds();
      if (syncConfirmState.reserveMode === "schedule" && syncConfirmState.reserveTimeIso) {
        const existingDate = new Date(syncConfirmState.reserveTimeIso);
        setReserveInputsFromDate(existingDate);
      } else if (!preserveSelection) {
        setReserveInputsFromDate(computeDefaultReserveDate());
      }
      updateReserveModeUi();
      updateReserveTimeHint();
      updateScheduledReserveState({ showErrors: false });
    }

    function updateReferralMessage(message) {
      const copy = message || "";
      if (referralCodeMessage) {
        referralCodeMessage.textContent = copy;
      }
      if (discountCodeMessage) {
        discountCodeMessage.textContent = copy;
      }
    }

    function syncReferralInputsFromState() {
      const value = syncConfirmState.referral.code || "";
      if (referralCodeInput) {
        referralCodeInput.value = value;
      }
      if (discountCodeInput) {
        discountCodeInput.value = value;
      }
    }

    function clearReferralState(message = "", { preserveInputs = true } = {}) {
      syncConfirmState.referral = { code: null, discountCents: 0, description: "" };
      if (!preserveInputs) {
        syncReferralInputsFromState();
      }
      updateReferralMessage(message);
      updateSyncConfirmTotalDisplay();
    }

    function setReferralState({ code, discountCents, description }) {
      syncConfirmState.referral = {
        code: code || null,
        discountCents: Math.max(0, Math.round(discountCents || 0)),
        description: description || "",
      };
      syncReferralInputsFromState();
      updateReferralMessage(
        syncConfirmState.referral.description ||
          (syncConfirmState.referral.code ? "Code applied." : "")
      );
      updateSyncConfirmTotalDisplay();
    }

    function handleCodeInputChange(inputEl) {
      if (!inputEl) return;
      const rawValue = inputEl.value || "";
      const value = rawValue.trim();
      const otherInput =
        inputEl === referralCodeInput ? discountCodeInput : referralCodeInput;
      const previousCode = syncConfirmState.referral.code;
      if (!value) {
        if (previousCode && otherInput && otherInput.value.trim() === previousCode) {
          otherInput.value = "";
        }
        clearReferralState("", { preserveInputs: true });
        updateReferralMessage("");
        return;
      }
      if (previousCode && value !== previousCode) {
        if (otherInput && otherInput.value.trim() === previousCode) {
          otherInput.value = "";
        }
        clearReferralState("", { preserveInputs: true });
        updateReferralMessage("");
        return;
      }
      updateReferralMessage("");
    }

    function buildReferralFareContext() {
      return {
        plan: getProfilePlanKey(),
        membershipStatus: currentUserProfile?.membershipStatus || "none",
        pickupCovered: !!lastRideMetrics?.pickupCovered,
        estimatedFareCents:
          getBaseFareCents() + Math.max(0, syncConfirmState.reserveFeeCents || 0),
        durationMinutes: lastRideMetrics?.durationMinutes
          ? Number(lastRideMetrics.durationMinutes.toFixed(1))
          : null,
        distanceMeters: lastRideMetrics?.distanceMeters || null,
        userId: auth?.currentUser?.uid || null,
      };
    }

    async function handleReferralCodeApply(
      inputEl = referralCodeInput,
      triggerButton = applyReferralCodeButton
    ) {
      if (!inputEl) return;
      const code = inputEl.value.trim();
      if (!code) {
        clearReferralState("Enter a code first.", { preserveInputs: false });
        syncReferralInputsFromState();
        return;
      }
      updateReferralMessage("");
      if (!validateReferralCodeForRideFn) {
        updateReferralMessage("Code validation is unavailable right now.");
        return;
      }
      if (triggerButton) {
        triggerButton.disabled = true;
      }
      try {
        const payload = {
          code,
          context: buildReferralFareContext(),
        };
        const response = await validateReferralCodeForRideFn(payload);
        const result = response?.data || {};
        if (!result.valid) {
          clearReferralState(result.message || "Code is invalid or expired.");
          return;
        }
        setReferralState({
          code,
          discountCents: result.discountCents || 0,
          description: result.description || "",
        });
      } catch (err) {
        console.error("validateReferralCodeForRide failed", err);
        updateReferralMessage("Could not apply code. Try again.");
      } finally {
        if (triggerButton) {
          triggerButton.disabled = false;
        }
      }
    }

    populateReserveTimeSelect();
    updateReserveTimeHint();

    function resolveSyncMemberDisplayName(profile = currentUserProfile) {
      if (profile) {
        const first = (profile.firstName || "").trim();
        const last = (profile.lastName || "").trim();
        const combined = `${first} ${last}`.trim();
        if (combined) return combined;
        if (profile.fullName) return profile.fullName;
        if (profile.displayName) return profile.displayName;
        if (profile.name) return profile.name;
        if (profile.email) return profile.email;
      }
      const authUser = auth?.currentUser;
      return (
        (authUser?.displayName || authUser?.email || "RideSync Member").trim() ||
        "RideSync Member"
      );
    }

    function updateSyncMembershipTermsDetails(planKey) {
      if (syncMembershipTermsCustomerName) {
        syncMembershipTermsCustomerName.textContent =
          resolveSyncMemberDisplayName() || "RideSync Member";
      }
      if (syncMembershipTermsPlanLabel) {
        const normalized = normalizePlanKey(
          planKey || syncSelectedMembershipPlan || getDefaultSyncMembershipPlan()
        );
        syncMembershipTermsPlanLabel.textContent =
          formatMembershipPlanLabel(normalized);
      }
    }

    function updateSyncMembershipTermsVisibility() {
      if (!syncMembershipTermsContainer) return;
      if (syncMembershipUpgradeMode) {
        syncMembershipTermsContainer.style.display = "block";
        updateSyncMembershipTermsDetails(syncSelectedMembershipPlan);
      } else {
        syncMembershipTermsContainer.style.display = "none";
        syncMembershipTermsAccepted = false;
        if (syncMembershipTermsCheckbox) {
          syncMembershipTermsCheckbox.checked = false;
        }
      }
    }

    function updateSyncConfirmButtonState() {
      if (!syncConfirmButton) return;
      if (syncConfirmBusyState) {
        syncConfirmButton.disabled = true;
        return;
      }
      const requiresTerms =
        syncMembershipUpgradeMode && !syncMembershipTermsAccepted;
      syncConfirmButton.disabled = !!requiresTerms;
      syncConfirmButton.textContent = "Sync & pay";
    }

    function updateSyncMembershipState() {
      const profilePlan = getProfilePlanKey();
      const normalizedSelection = normalizePlanKey(
        syncSelectedMembershipPlan || getDefaultSyncMembershipPlan()
      );
      syncSelectedMembershipPlan = normalizedSelection;
      const cards = syncMembershipList
        ? Array.from(syncMembershipList.querySelectorAll(".sync-membership-card"))
        : [];
      cards.forEach((card) => {
        const planKey = normalizePlanKey(card.dataset.plan);
        const isSelected = planKey === normalizedSelection;
        const planSelectable =
          planKey === "basic" ||
          planKey === profilePlan ||
          isPlanSelectable(planKey);
        card.classList.toggle("active", isSelected);
        card.classList.toggle("disabled", !planSelectable);
        card.setAttribute("aria-checked", isSelected ? "true" : "false");
        card.setAttribute("aria-disabled", planSelectable ? "false" : "true");
        card.tabIndex = planSelectable ? 0 : -1;
      });
      syncMembershipUpgradeMode =
        normalizedSelection !== "basic" && normalizedSelection !== profilePlan;
      updateSyncMembershipHint(normalizedSelection, profilePlan);
      updateSyncConfirmTotalDisplay();
      updateSyncMembershipTermsVisibility();
      updateSyncConfirmButtonState();
    }

    function selectSyncMembershipPlan(planKey) {
      const normalized = normalizePlanKey(planKey || "basic");
      if (normalized === syncSelectedMembershipPlan) {
        return;
      }
      const profilePlan = getProfilePlanKey();
      const canSelect =
        normalized === "basic" ||
        normalized === profilePlan ||
        isPlanSelectable(normalized);
      if (!canSelect) {
        return;
      }
      syncSelectedMembershipPlan = normalized;
      syncMembershipTermsAccepted = false;
      if (syncMembershipTermsCheckbox) {
        syncMembershipTermsCheckbox.checked = false;
      }
      updateSyncMembershipState();
    }

    function handleSyncMembershipCardClick(event) {
      const card = event.target.closest(".sync-membership-card");
      if (!card || card.classList.contains("disabled")) {
        return;
      }
      selectSyncMembershipPlan(card.dataset.plan);
    }

    function handleSyncMembershipCardKeydown(event) {
      if (event.key !== "Enter" && event.key !== " ") {
        return;
      }
      const card = event.target.closest(".sync-membership-card");
      if (!card || card.classList.contains("disabled")) {
        return;
      }
      event.preventDefault();
      selectSyncMembershipPlan(card.dataset.plan);
    }

    function isPresetTipValue(cents) {
      if (!syncTipOptions) return false;
      const buttons = syncTipOptions.querySelectorAll(".tip-button");
      for (const button of buttons) {
        const tipValue = button.dataset?.tip;
        if (!tipValue || tipValue === "custom") continue;
        const dollars = Number(tipValue);
        if (!Number.isFinite(dollars)) continue;
        if (Math.round(dollars * 100) === cents) {
          return true;
        }
      }
      return false;
    }

    function updateSyncTipUi() {
      if (!syncTipOptions) return;
      const selectedCents = clampTipAmount(
        ridePreauthState.selectedTipCents || MIN_RIDE_TIP_CENTS,
        MIN_RIDE_TIP_CENTS,
        ridePreauthState.maxTipAmountCents || DEFAULT_MAX_TIP_CENTS
      );
      ridePreauthState.selectedTipCents = selectedCents;
      const buttons = Array.from(
        syncTipOptions.querySelectorAll(".tip-button")
      );
      let matchedPreset = false;
      buttons.forEach((button) => {
        const value = button.dataset?.tip;
        if (!value || value === "custom") {
          return;
        }
        const dollars = Number(value);
        if (!Number.isFinite(dollars)) {
          button.classList.remove("active");
          return;
        }
        const cents = Math.round(dollars * 100);
        const isActive = !syncTipUsesCustom && cents === selectedCents;
        if (isActive) {
          matchedPreset = true;
        }
        button.classList.toggle("active", isActive);
      });
      const customButton = syncTipOptions.querySelector(
        '.tip-button[data-tip="custom"]'
      );
      if (customButton) {
        const highlightCustom = syncTipUsesCustom || !matchedPreset;
        customButton.classList.toggle("active", highlightCustom);
      }
      const shouldShowCustomInput = syncTipUsesCustom || !matchedPreset;
      if (syncTipCustomInput) {
        syncTipCustomInput.style.display = shouldShowCustomInput
          ? "block"
          : "none";
        if (shouldShowCustomInput) {
          syncTipCustomInput.value =
            selectedCents > 0
              ? Math.round(selectedCents / 100).toString()
              : "";
        } else {
          syncTipCustomInput.value = "";
        }
      }
      if (syncTipMessage) {
        if (selectedCents > 0) {
          syncTipMessage.textContent = `We'll charge your fare plus ${formatCurrencyFromCents(
            selectedCents,
            "usd"
          )} right now. You can change it before confirming payment.`;
        } else {
          syncTipMessage.textContent =
            "No tip selected. Tips are optional and go directly to your driver.";
        }
      }
    }

    function handleSyncTipOptionClick(event) {
      const target = event.target.closest(".tip-button");
      if (!target || target.disabled) return;
      const tipValue = target.dataset?.tip;
      if (tipValue === "custom") {
        syncTipUsesCustom = true;
        if (syncTipCustomInput) {
          syncTipCustomInput.style.display = "block";
          syncTipCustomInput.focus();
          syncTipCustomInput.select();
        }
        updateSyncTipUi();
        return;
      }
      const dollars = Number(tipValue);
      if (!Number.isFinite(dollars)) return;
      syncTipUsesCustom = false;
      ridePreauthState.selectedTipCents = clampTipAmount(
        Math.round(dollars * 100),
        MIN_RIDE_TIP_CENTS,
        ridePreauthState.maxTipAmountCents || DEFAULT_MAX_TIP_CENTS
      );
      updateSyncTipUi();
    }

    function handleSyncTipCustomInput() {
      if (!syncTipCustomInput) return;
      syncTipUsesCustom = true;
      const cents = dollarsToCents(syncTipCustomInput.value);
      ridePreauthState.selectedTipCents = clampTipAmount(
        cents,
        MIN_RIDE_TIP_CENTS,
        ridePreauthState.maxTipAmountCents || DEFAULT_MAX_TIP_CENTS
      );
      updateSyncTipUi();
    }

    function closeSyncConfirmOverlay(options = {}) {
      if (!syncConfirmOverlay) return;
      toggleOverlay(syncConfirmOverlay, false);
      setSyncConfirmBusy(false);
      isSyncConfirmOpen = false;
      if (!syncRidersAwaitingRideActivation || options.resetSyncRiders) {
        syncRidersFlowActive = false;
        syncRidersAwaitingRideActivation = false;
      }
    }

    function openSyncConfirmOverlay(options = {}) {
      const {
        preserveError = false,
        preserveSelection = false,
        preserveFareExtras = false,
      } = options;
      if (!syncConfirmOverlay) return false;
      if (!currentUserProfile) {
        profileError.textContent = "Load your RideSync profile before syncing a destination.";
        return false;
      }
      if (!destinationLatLng || !lastRideMetrics) {
        profileError.textContent =
          "Set destination and wait for the fare estimate first.";
        updateRouteAndFare();
        return false;
      }
      const destinationSummary = getDestinationSummaryText() || "your ride";
      if (syncConfirmDestination) {
        syncConfirmDestination.textContent = destinationSummary;
      }
      if (syncConfirmSubtitle) {
        syncConfirmSubtitle.textContent = hasOnlineDrivers
          ? "Drivers are online. Confirm these details to sync instantly."
          : "Drivers look offline. We'll notify them as soon as you confirm.";
      }
      if (syncConfirmTime) {
        const minutes = Number(lastRideMetrics.durationMinutes || 0);
        syncConfirmTime.textContent = minutes
          ? `${minutes.toFixed(1)} min`
          : "—";
      }
      if (syncConfirmDistance) {
        const meters = Number(lastRideMetrics.distanceMeters || 0);
        syncConfirmDistance.textContent = meters
          ? `${(meters / 1609.34).toFixed(2)} mi`
          : "—";
      }
      if (syncConfirmTotal) {
        const total = Number(lastRideMetrics.fareBreakdown?.total || 0);
        syncConfirmTotal.textContent = total
          ? `$${total.toFixed(2)}`
          : "—";
      }
      if (!preserveFareExtras) {
        resetSyncConfirmState();
        syncReferralInputsFromState();
        updateReferralMessage("");
      } else {
        syncReferralInputsFromState();
        updateReferralMessage(
          syncConfirmState.referral.description ||
            (syncConfirmState.referral.code ? "Code applied." : "")
        );
      }
      initializeReserveInputs({ preserveSelection: preserveFareExtras });
      updateSyncConfirmTotalDisplay();
      initializeSyncMembershipSelection({ preserveSelection });
      const presetMatch = isPresetTipValue(
        ridePreauthState.selectedTipCents || MIN_RIDE_TIP_CENTS
      );
      syncTipUsesCustom = !presetMatch;
      updateSyncTipUi();
      if (syncConfirmError && !preserveError) {
        syncConfirmError.textContent = "";
      }
      toggleOverlay(syncConfirmOverlay, true, syncConfirmClose);
      isSyncConfirmOpen = true;
      return true;
    }

    function setSyncConfirmBusy(isBusy) {
      syncConfirmBusyState = !!isBusy;
      if (syncConfirmButton) {
        if (syncConfirmBusyState) {
          syncConfirmButton.disabled = true;
          syncConfirmButton.textContent = syncMembershipUpgradeMode
            ? "Redirecting…"
            : "Syncing…";
        } else {
          updateSyncConfirmButtonState();
        }
      }
      if (syncConfirmClose) {
        syncConfirmClose.disabled = !!isBusy;
      }
      if (syncConfirmCancel) {
        syncConfirmCancel.disabled = !!isBusy;
      }
    }

    async function handleSyncConfirmSubmit() {
      if (!syncConfirmOverlay || !isSyncConfirmOpen) {
        return;
      }
      if (syncMembershipUpgradeMode && !syncMembershipTermsAccepted) {
        if (syncConfirmError) {
          syncConfirmError.textContent =
            "Agree to the membership terms to continue.";
        }
        if (syncMembershipTermsCheckbox) {
          syncMembershipTermsCheckbox.focus();
        }
        return;
      }
      const reserveValidation = ensureValidReserveSelection({ showErrors: true });
      if (!reserveValidation.valid) {
        if (syncConfirmError) {
          syncConfirmError.textContent =
            reserveValidation.message || "Choose a valid pickup time.";
        }
        return;
      }
      if (syncConfirmError) {
        syncConfirmError.textContent = "";
      }
      const upgradePlan = syncMembershipUpgradeMode
        ? syncSelectedMembershipPlan
        : null;
      if (syncRidersFlowActive) {
        syncRidersAwaitingRideActivation = true;
      }
      setSyncConfirmBusy(true);
      closeSyncConfirmOverlay();
      try {
        if (upgradePlan) {
          await startMembershipUpgradeCheckout(upgradePlan);
        } else {
          await handleNewRide();
        }
      } catch (err) {
        console.error(
          upgradePlan
            ? "Membership upgrade checkout failed"
            : "handleSyncConfirmSubmit error",
          err
        );
        if (syncConfirmError) {
          syncConfirmError.textContent = upgradePlan
            ? err?.message || MEMBERSHIP_CHECKOUT_ERROR_FALLBACK
            : err?.message || "Could not sync this ride.";
        }
        setSyncConfirmBusy(false);
        openSyncConfirmOverlay({
          preserveError: true,
          preserveSelection: true,
          preserveFareExtras: true,
        });
      }
    }

    if (syncTipOptions) {
      syncTipOptions.addEventListener("click", handleSyncTipOptionClick);
    }

    if (syncTipCustomInput) {
      syncTipCustomInput.addEventListener("input", handleSyncTipCustomInput);
    }

    reserveModeRadios?.forEach?.((radio) => {
      radio.addEventListener("change", () => handleReserveModeChange(radio.value));
    });
    [reserveDateInput, reserveTimeInput].forEach((input) => {
      if (!input) return;
      input.addEventListener("change", () => {
        if (syncConfirmState.reserveMode !== "schedule") return;
        updateScheduledReserveState({ showErrors: true });
      });
    });

    if (applyReferralCodeButton) {
      applyReferralCodeButton.addEventListener("click", () =>
        handleReferralCodeApply(referralCodeInput, applyReferralCodeButton)
      );
    }

    if (applyDiscountCodeButton) {
      applyDiscountCodeButton.addEventListener("click", () =>
        handleReferralCodeApply(discountCodeInput, applyDiscountCodeButton)
      );
    }

    if (referralCodeInput) {
      referralCodeInput.addEventListener("input", () =>
        handleCodeInputChange(referralCodeInput)
      );
      referralCodeInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          handleReferralCodeApply(referralCodeInput, applyReferralCodeButton);
        }
      });
    }

    if (discountCodeInput) {
      discountCodeInput.addEventListener("input", () =>
        handleCodeInputChange(discountCodeInput)
      );
      discountCodeInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          handleReferralCodeApply(discountCodeInput, applyDiscountCodeButton);
        }
      });
    }

    if (syncConfirmClose) {
      syncConfirmClose.addEventListener("click", closeSyncConfirmOverlay);
    }

    if (syncConfirmCancel) {
      syncConfirmCancel.addEventListener("click", closeSyncConfirmOverlay);
    }

    if (syncConfirmOverlay) {
      syncConfirmOverlay.addEventListener("click", (event) => {
        if (event.target === syncConfirmOverlay) {
          closeSyncConfirmOverlay();
        }
      });
    }

    if (syncConfirmButton) {
      syncConfirmButton.addEventListener("click", () => {
        handleSyncConfirmSubmit();
      });
    }

    if (syncMembershipList) {
      syncMembershipList.addEventListener("click", handleSyncMembershipCardClick);
      syncMembershipList.addEventListener("keydown", handleSyncMembershipCardKeydown);
    }

    if (syncMembershipTermsCheckbox) {
      syncMembershipTermsCheckbox.addEventListener("change", () => {
        syncMembershipTermsAccepted = !!syncMembershipTermsCheckbox.checked;
        updateSyncConfirmButtonState();
      });
    }

    function hasPendingCheckoutReturn() {
      return (
        checkoutReturnState.pendingId &&
        checkoutReturnState.sessionId &&
        checkoutReturnState.status !== "completed"
      );
    }

    function hasPendingMembershipCheckoutReturn() {
      return (
        membershipCheckoutReturnState.pendingId &&
        membershipCheckoutReturnState.sessionId &&
        membershipCheckoutReturnState.status !== "completed"
      );
    }

    function stripMembershipCheckoutParamsFromUrl() {
      const params = new URLSearchParams(window.location.search);
      let changed = false;
      [
        "membership_pending_id",
        "membershipPendingId",
        "membershipPending",
        "membership_session_id",
        "membershipSessionId",
        "membershipSession",
      ].forEach((key) => {
        if (params.has(key)) {
          params.delete(key);
          changed = true;
        }
      });
      if (!changed) {
        return;
      }
      const query = params.toString();
      const hash = window.location.hash || "";
      const newUrl =
        `${window.location.origin}${window.location.pathname}` +
        (query ? `?${query}` : "") +
        hash;
      window.history.replaceState({}, document.title, newUrl);
      membershipCheckoutReturnState.pendingId = null;
      membershipCheckoutReturnState.sessionId = null;
    }

    function stripCheckoutParamsFromUrl() {
      const params = new URLSearchParams(window.location.search);
      let changed = false;
      ["pending_id", "pendingId", "pending", "session_id", "sessionId", "session"].forEach(
        (key) => {
          if (params.has(key)) {
            params.delete(key);
            changed = true;
          }
        }
      );
      if (!changed) {
        return;
      }
      const query = params.toString();
      const hash = window.location.hash || "";
      const newUrl =
        `${window.location.origin}${window.location.pathname}` +
        (query ? `?${query}` : "") +
        hash;
      window.history.replaceState({}, document.title, newUrl);
    }

    async function finalizeMembershipCheckoutSessionIfNeeded(user) {
      if (!hasPendingMembershipCheckoutReturn()) {
        return;
      }
      if (!user) {
        openPaymentStatusOverlay(
          "Sign in to finish membership",
          "Stripe approved your payment. Log in so we can finalize your membership."
        );
        return;
      }
      if (membershipCheckoutReturnState.status === "processing") {
        return;
      }
      const rideCheckoutPendingAtMembershipFinalizeStart = hasPendingCheckoutReturn();
      membershipCheckoutReturnState.status = "processing";
      membershipCheckoutReturnState.attempts += 1;
      openPaymentStatusOverlay(
        "Finalizing your membership…",
        "Hang tight while we confirm your Stripe checkout."
      );

      try {
        const idToken = await user.getIdToken(true);
        const payload = {
          membership_pending_id: membershipCheckoutReturnState.pendingId,
          membershipPendingId: membershipCheckoutReturnState.pendingId,
          pendingId: membershipCheckoutReturnState.pendingId,
          membership_session_id: membershipCheckoutReturnState.sessionId,
          membershipSessionId: membershipCheckoutReturnState.sessionId,
          sessionId: membershipCheckoutReturnState.sessionId,
        };
        await requestMembershipCheckoutFinalization(payload, idToken);
        membershipCheckoutReturnState.status = "completed";
        stripMembershipCheckoutParamsFromUrl();
        if (user?.uid) {
          await loadUserProfile(user.uid, user.email);
        }
        openPaymentStatusOverlay(
          "Membership updated",
          "Payment succeeded and your membership is ready."
        );
        setTimeout(() => {
          if (
            !rideCheckoutPendingAtMembershipFinalizeStart &&
            !hasPendingCheckoutReturn()
          ) {
            closePaymentStatusOverlay();
          }
        }, 3500);
      } catch (err) {
        console.error(
          "[RideSync][Stripe] finalize membership checkout failed",
          err
        );
        membershipCheckoutReturnState.status = "error";
        openPaymentStatusOverlay(
          "Membership finalization pending",
          err?.message || MEMBERSHIP_FINALIZE_FALLBACK
        );
      }
    }

    async function finalizeCheckoutSessionIfNeeded(user) {
      if (!hasPendingCheckoutReturn()) {
        return;
      }
      if (!user) {
        openPaymentStatusOverlay(
          "Sign in to finish payment",
          "We received your payment. Sign in so we can finalize your ride."
        );
        return;
      }
      if (checkoutReturnState.status === "processing") {
        return;
      }
      checkoutReturnState.status = "processing";
      checkoutReturnState.attempts += 1;
      openPaymentStatusOverlay(
        "Finalizing your ride…",
        "Hang tight while we confirm your Stripe checkout."
      );

      try {
        const idToken = await user.getIdToken(true);
        const response = await fetch("/finalizeRideCheckoutSession", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${idToken}`
          },
          body: JSON.stringify({
            pendingId: checkoutReturnState.pendingId,
            pending_id: checkoutReturnState.pendingId,
            sessionId: checkoutReturnState.sessionId,
            session_id: checkoutReturnState.sessionId
          })
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          const message =
            payload?.error?.message ||
            "We received your payment but could not finalize the ride yet.";
          throw new Error(message);
        }
        checkoutReturnState.status = "completed";
        checkoutReturnState.rideId = payload?.rideId || null;
        stripCheckoutParamsFromUrl();
        openPaymentStatusOverlay(
          "Ride confirmed",
          "Payment succeeded and your ride is ready."
        );
        setTimeout(() => {
          closePaymentStatusOverlay();
        }, 4000);
      } catch (err) {
        console.error("[RideSync][Stripe] finalize checkout failed", err);
        checkoutReturnState.status = "error";
        openPaymentStatusOverlay(
          "Payment finalized later",
          err?.message ||
            "We received your payment but still need to finish processing. Contact RideSync support if this persists."
        );
      }
    }

    async function requestMembershipCheckoutFinalization(payload, idToken) {
      const headers = {
        "Content-Type": "application/json",
      };
      if (idToken) {
        headers.Authorization = `Bearer ${idToken}`;
      }
      const body = JSON.stringify(payload);
      let lastFailure = null;
      for (const endpoint of membershipFinalizeEndpoints) {
        if (!endpoint) continue;
        try {
          const response = await fetch(endpoint, {
            method: "POST",
            headers,
            body,
          });
          let data = null;
          try {
            data = await response.json();
          } catch (_) {
            data = null;
          }
          if (response.ok) {
            return data || {};
          }
          lastFailure = {
            endpoint,
            status: response.status,
            body: data,
          };
        } catch (err) {
          lastFailure = {
            endpoint,
            error: err instanceof Error ? err.message : String(err),
          };
        }
      }
      if (lastFailure) {
        console.error(
          "[RideSync][Stripe] finalizeMembershipCheckoutSession endpoint error",
          lastFailure
        );
      }
      throw new Error(MEMBERSHIP_FINALIZE_FALLBACK);
    }

    function openPaymentStatusOverlay(title, message) {
      if (!paymentStatusOverlay) return;
      if (paymentStatusTitle) {
        paymentStatusTitle.textContent = title || "";
      }
      if (paymentStatusMessage) {
        paymentStatusMessage.textContent = message || "";
      }
      toggleOverlay(paymentStatusOverlay, true, paymentStatusBackButton);
    }

    function closePaymentStatusOverlay() {
      toggleOverlay(paymentStatusOverlay, false);
    }

    function updateRideFareStatus(message, isError = false) {
      if (!rideFareStatus) return;
      rideFareStatus.textContent = message || "";
      rideFareStatus.classList.toggle("error", Boolean(message) && isError);
    }

    function renderRideFareDetails(summary = {}) {
      if (rideFareDetails) {
        const parts = [];
        if (summary.pickup) {
          parts.push(`Pickup: ${summary.pickup}`);
        }
        if (summary.dropoff) {
          parts.push(`Dropoff: ${summary.dropoff}`);
        }
        if (Number.isFinite(summary.distanceMiles)) {
          parts.push(`Distance: ${summary.distanceMiles.toFixed(2)} miles`);
        }
        if (Number.isFinite(summary.durationMinutes)) {
          parts.push(`Duration: ${Math.round(summary.durationMinutes)} min`);
        }
        rideFareDetails.textContent = parts.join(" • ");
      }

      if (
        rideFareMembershipLabel ||
        rideFareMembershipRow ||
        rideFareMembershipNote
      ) {
        const fallbackPlan = getProfilePlanKey();
        const fallbackStatus = currentUserProfile?.membershipStatus || "none";
        const membershipLabel =
          summary?.membershipLabel ||
          formatMembershipSummary(fallbackPlan, fallbackStatus);
        const membershipMessage =
          summary?.membershipMessage ||
          buildRideMembershipMessage(fallbackPlan, fallbackStatus);

        if (rideFareMembershipLabel) {
          rideFareMembershipLabel.textContent = membershipLabel || "—";
        }
        if (rideFareMembershipRow) {
          rideFareMembershipRow.style.display = membershipLabel ? "flex" : "none";
        }
        if (rideFareMembershipNote) {
          rideFareMembershipNote.textContent = membershipMessage || "";
          rideFareMembershipNote.style.display = membershipMessage ? "block" : "none";
        }
      }
    }

    function resetRideTipUi() {
      if (rideTipOptions) {
        rideTipOptions.querySelectorAll(".tip-button").forEach((btn, idx) => {
          btn.classList.toggle("active", idx === 0);
        });
      }
      if (rideTipCustomInput) {
        rideTipCustomInput.value = "";
        rideTipCustomInput.style.display = "none";
      }
      ridePaymentState.tipAmountCents = 0;
    }

    function updateRidePaymentTotalsDisplay() {
      ridePaymentState.totalAmountCents = Math.max(
        0,
        ridePaymentState.baseAmountCents + ridePaymentState.tipAmountCents
      );
      if (rideFareBaseAmount) {
        rideFareBaseAmount.textContent = formatCurrencyFromCents(
          ridePaymentState.baseAmountCents,
          "usd"
        );
      }
      if (rideFareTipAmount) {
        rideFareTipAmount.textContent = formatCurrencyFromCents(
          ridePaymentState.tipAmountCents,
          "usd"
        );
      }
      if (rideFareAmount) {
        rideFareAmount.textContent = formatCurrencyFromCents(
          ridePaymentState.totalAmountCents,
          "usd"
        );
      }
      updateRideCheckoutButtonState();
    }

    function updateRideCheckoutButtonState() {
      if (!rideCheckoutButton) return;
      if (!ridePaymentState.showing) {
        rideCheckoutButton.disabled = true;
        rideCheckoutButton.textContent = "Continue to Stripe Checkout";
        return;
      }
      if (!ridePaymentState.totalAmountCents) {
        rideCheckoutButton.disabled = true;
        rideCheckoutButton.textContent = "Stripe Checkout unavailable";
        return;
      }
      const amountLabel = formatCurrencyFromCents(
        ridePaymentState.totalAmountCents,
        "usd"
      );
      rideCheckoutButton.textContent = ridePaymentState.processing
        ? "Preparing Stripe Checkout…"
        : `Pay ${amountLabel} with Stripe`;
      rideCheckoutButton.disabled = ridePaymentState.processing;
    }

    function handleRideTipButtonClick(event) {
      if (!rideTipOptions) return;
      const button = event.target.closest(".tip-button");
      if (!button) return;
      rideTipOptions.querySelectorAll(".tip-button").forEach((btn) => {
        btn.classList.toggle("active", btn === button);
      });
      const value = button.dataset.tip;
      if (value === "custom") {
        if (rideTipCustomInput) {
          rideTipCustomInput.style.display = "block";
          rideTipCustomInput.focus();
          rideTipCustomInput.value = "";
        }
        ridePaymentState.tipAmountCents = 0;
        updateRidePaymentTotalsDisplay();
        return;
      }
      if (rideTipCustomInput) {
        rideTipCustomInput.style.display = "none";
        rideTipCustomInput.value = "";
      }
      const dollars = Number(value);
      ridePaymentState.tipAmountCents = Number.isFinite(dollars)
        ? Math.max(0, Math.round(dollars * 100))
        : 0;
      updateRidePaymentTotalsDisplay();
    }

    function handleRideTipCustomInput() {
      if (!rideTipCustomInput) return;
      const dollars = Number(rideTipCustomInput.value);
      if (!Number.isFinite(dollars) || dollars < 0) {
        ridePaymentState.tipAmountCents = 0;
      } else {
        ridePaymentState.tipAmountCents = Math.round(dollars * 100);
      }
      updateRidePaymentTotalsDisplay();
    }

    async function handleRideCheckoutSubmit() {
      if (ridePaymentState.processing) {
        return;
      }
      if (!ridePaymentState.rideId) {
        updateRideFareStatus("Ride reference missing for payment.", true);
        return;
      }
      if (!ridePaymentState.totalAmountCents) {
        updateRideFareStatus("Fare total unavailable. Contact support.", true);
        return;
      }
      ridePaymentState.processing = true;
      updateRideCheckoutButtonState();
      if (rideCheckoutMessage) {
        rideCheckoutMessage.textContent = "";
      }
      updateRideFareStatus("Redirecting to Stripe Checkout…", false);
      showPaymentRedirectOverlay("Redirecting you to Stripe Checkout…");
      try {
        const redirectBaseUrl =
          typeof window !== "undefined" && window.location?.origin
            ? window.location.origin
            : null;
        const response = await createRideFareCheckoutSessionFn({
          rideId: ridePaymentState.rideId,
          amount: Math.max(
            0,
            Math.round(ridePaymentState.totalAmountCents || 0)
          ),
          tipAmountCents: Math.max(
            0,
            Math.round(ridePaymentState.tipAmountCents || 0)
          ),
          redirectBaseUrl,
        });
        const url = response?.data?.url;
        if (typeof url !== "string" || !url) {
          throw new Error("Unable to start Stripe Checkout.");
        }
        window.location.href = url;
      } catch (err) {
        ridePaymentState.processing = false;
        hidePaymentRedirectOverlay();
        updateRideCheckoutButtonState();
        const message = err?.message || PAYMENT_ERROR_FALLBACK;
        updateRideFareStatus(message, true);
        if (rideCheckoutMessage) {
          rideCheckoutMessage.textContent = message;
        }
      }
    }

    function teardownRidePaymentResources() {
      if (ridePaymentState.paymentRequestElement) {
        ridePaymentState.paymentRequestElement.unmount();
        ridePaymentState.paymentRequestElement = null;
      }
      ridePaymentState.paymentRequest = null;
      ridePaymentState.paymentRequestElementsInstance = null;
      if (rideFarePaymentRequest) {
        rideFarePaymentRequest.innerHTML = "";
      }
      if (ridePaymentState.paymentElement) {
        ridePaymentState.paymentElement.unmount();
        ridePaymentState.paymentElement = null;
      }
      ridePaymentState.paymentElements = null;
      if (rideCardElement) {
        rideCardElement.innerHTML = "";
      }
      if (rideCardSubmit) {
        rideCardSubmit.disabled = true;
      }
      if (rideCardMessage) {
        rideCardMessage.textContent = "";
      }
      if (rideCheckoutButton) {
        rideCheckoutButton.disabled = true;
        rideCheckoutButton.textContent = "Continue to Stripe Checkout";
      }
      if (rideCheckoutMessage) {
        rideCheckoutMessage.textContent = "";
      }
    }

    function resetRidePaymentState() {
      teardownRidePaymentResources();
      ridePaymentState.rideId = null;
      ridePaymentState.baseAmountCents = 0;
      ridePaymentState.tipAmountCents = 0;
      ridePaymentState.totalAmountCents = 0;
      ridePaymentState.clientSecret = null;
      ridePaymentState.summary = null;
      ridePaymentState.processing = false;
      ridePaymentState.completed = false;
      ridePaymentState.showing = false;
      ridePaymentState.livemode = null;
      ridePaymentState.intentRequestId = 0;
      ridePaymentState.clientSecretContext = null;
      if (rideTipRefreshTimer) {
        clearTimeout(rideTipRefreshTimer);
        rideTipRefreshTimer = null;
      }
      resetRideTipUi();
      updateRidePaymentTotalsDisplay();
      if (rideFareUnavailable) {
        rideFareUnavailable.textContent = "";
      }
      updateRideFareStatus("");
      if (rideFareClose) {
        rideFareClose.disabled = true;
      }
    }

    function updatePreauthTipUi() {
      if (preauthTipOptions) {
        preauthTipOptions.querySelectorAll(".tip-button").forEach((btn) => {
          const value = Number(btn.dataset.tip);
          const cents = Number.isFinite(value) ? Math.round(value * 100) : null;
          btn.classList.toggle(
            "active",
            cents !== null && cents === ridePreauthState.selectedTipCents
          );
        });
      }
      if (preauthTipCustomInput) {
        const presetValues = new Set([0, 200, 500, 1000]);
        const useCustom = !presetValues.has(ridePreauthState.selectedTipCents);
        preauthTipCustomInput.style.display = useCustom ? "block" : "none";
        preauthTipCustomInput.value = useCustom
          ? (ridePreauthState.selectedTipCents / 100).toFixed(2)
          : "";
      }
      const selectedTipCents = Math.max(
        0,
        Math.round(ridePreauthState.selectedTipCents || 0)
      );
      if (preauthHoldAmount) {
        const holdAmountCents =
          Math.max(0, Math.round(ridePreauthState.authAmountCents || 0)) ||
          ridePreauthState.fareAmountCents + selectedTipCents;
        preauthHoldAmount.textContent = formatCurrencyFromCents(
          holdAmountCents,
          "usd"
        );
      }
      if (preauthTipMessage) {
        if (selectedTipCents > 0) {
          preauthTipMessage.textContent = `Tips are optional. Your selected tip (${formatCurrencyFromCents(
            selectedTipCents,
            "usd"
          )}) is charged now with your fare.`;
        } else {
          preauthTipMessage.textContent =
            "Tips are optional. We'll only charge your fare unless you add one.";
        }
      }
    }

    function handlePreauthTipButtonClick(event) {
      const button = event.target.closest(".tip-button");
      if (!button) return;
      const value = button.dataset.tip;
      if (value === "custom") {
        if (preauthTipCustomInput) {
          preauthTipCustomInput.style.display = "block";
          preauthTipCustomInput.focus();
          preauthTipCustomInput.value = "";
        }
        return;
      }
      const dollars = Number(value);
      if (!Number.isFinite(dollars)) {
        return;
      }
      ridePreauthState.selectedTipCents = clampTipAmount(
        Math.round(dollars * 100),
        MIN_RIDE_TIP_CENTS,
        ridePreauthState.maxTipAmountCents
      );
      updatePreauthTipUi();
    }

    function handlePreauthTipCustomInput() {
      if (!preauthTipCustomInput) return;
      const cents = dollarsToCents(preauthTipCustomInput.value);
      ridePreauthState.selectedTipCents = clampTipAmount(
        cents,
        MIN_RIDE_TIP_CENTS,
        ridePreauthState.maxTipAmountCents
      );
      updatePreauthTipUi();
    }

    function closeRideFareOverlay(force = false) {
      if (!rideFareOverlay) return;
      const hasActivePayment =
        Boolean(ridePaymentState.paymentRequest) ||
        Boolean(ridePaymentState.paymentElement);
      if (!force && !ridePaymentState.completed && hasActivePayment) {
        return;
      }
      toggleOverlay(rideFareOverlay, false);
      ridePaymentState.showing = false;
      updateRideCheckoutButtonState();
      if (force || ridePaymentState.completed) {
        resetRidePaymentState();
      }
    }

    async function handleRideFareDismiss() {
      const rideId = ridePaymentState.rideId || currentRideId;
      const normalizedStatus = (currentRideStatus || "").toLowerCase();
      const shouldCancelRide =
        rideId &&
        !ridePaymentState.completed &&
        riderCancelableStatuses.has(normalizedStatus);

      if (rideFareClose) {
        rideFareClose.disabled = true;
      }

      if (shouldCancelRide) {
        try {
          await cancelRideRequestFn({ rideId });
        } catch (err) {
          const message = err?.message || PAYMENT_ERROR_FALLBACK;
          updateRideFareStatus(message, true);
          if (cancelError) {
            cancelError.textContent = message;
          }
          if (rideFareClose) {
            rideFareClose.disabled = false;
          }
          return;
        }
      }

      returnToHomeAfterRide(
        shouldCancelRide
          ? "Ride checkout canceled. Choose your destination to request another ride."
          : "Ride checkout closed."
      );
    }

    async function openRideFareOverlay({ rideId, amountCents, summary }) {
      if (!rideFareOverlay) return;
      resetRidePaymentState();
      ridePaymentState.rideId = rideId || null;
      ridePaymentState.baseAmountCents = Math.max(0, Math.round(amountCents));
      ridePaymentState.summary = summary || null;
      ridePaymentState.completed = false;
      ridePaymentState.processing = true;
      ridePaymentState.clientSecret = null;
      ridePaymentState.showing = true;
      if (rideFareSubtitle) {
        rideFareSubtitle.textContent = summary?.dropoff
          ? `Destination: ${summary.dropoff}`
          : "Complete your fare to finish this ride.";
      }
      renderRideFareDetails(summary);
      resetRideTipUi();
      updateRidePaymentTotalsDisplay();
      updateRideFareStatus("Preparing payment options…", false);
      if (rideFareUnavailable) {
        rideFareUnavailable.textContent = "";
      }
      if (rideFareClose) {
        rideFareClose.disabled = true;
      }
      toggleOverlay(rideFareOverlay, true, rideFareClose);
      ridePaymentState.processing = false;
      if (rideFareClose) {
        rideFareClose.disabled = false;
      }
      updateRideCheckoutButtonState();
      updateRideFareStatus(
        "Tap the button below to finish in Stripe Checkout.",
        false
      );
    }

    async function createRidePaymentClientSecret({
      rideId,
      amountCents,
      tipAmountCents,
    }) {
      try {
        const normalizedAmountCents = Number.isFinite(Number(amountCents))
          ? Math.max(0, Math.round(Number(amountCents)))
          : 0;
        const normalizedTipAmountCents = Number.isFinite(Number(tipAmountCents))
          ? Math.max(0, Math.round(Number(tipAmountCents)))
          : 0;
        const normalizedFareAmountCents = Math.max(
          0,
          normalizedAmountCents - normalizedTipAmountCents
        );
        const response = await createRidePaymentIntentFn({
          amount: normalizedAmountCents,
          currency: "usd",
          rideId: rideId || null,
          tipAmountCents: normalizedTipAmountCents,
          fareAmountCents: normalizedFareAmountCents,
        });
        const clientSecret = response?.data?.clientSecret;
        if (typeof clientSecret !== "string" || !clientSecret) {
          throw new Error("Unable to start ride payment.");
        }
        return {
          clientSecret,
          livemode: response?.data?.livemode ?? null,
        };
      } catch (err) {
        throw handleCallableError(
          "createRidePaymentIntent",
          err,
          PAYMENT_ERROR_FALLBACK
        );
      }
    }

    async function refreshRidePaymentIntent() {
      if (!ridePaymentState.rideId) {
        updateRideFareStatus("Ride reference missing for payment.", true);
        return;
      }
      if (!ridePaymentState.totalAmountCents) {
        updateRideFareStatus("Fare total unavailable. Contact support.", true);
        return;
      }
      ridePaymentState.intentRequestId += 1;
      const currentRequestId = ridePaymentState.intentRequestId;
      ridePaymentState.processing = true;
      teardownRidePaymentResources();
      updateRideFareStatus("Preparing payment options…", false);
      try {
        const { clientSecret, livemode } = await createRidePaymentClientSecret({
          rideId: ridePaymentState.rideId,
          amountCents: ridePaymentState.totalAmountCents,
          tipAmountCents: ridePaymentState.tipAmountCents,
        });
        if (ridePaymentState.intentRequestId !== currentRequestId) {
          return;
        }
        ridePaymentState.clientSecret = clientSecret;
        ridePaymentState.livemode = livemode;
        ridePaymentState.clientSecretContext = {
          clientSecret,
          livemode,
          totalAmountCents: ridePaymentState.totalAmountCents,
          baseAmountCents: ridePaymentState.baseAmountCents,
          tipAmountCents: ridePaymentState.tipAmountCents,
        };
        await mountRidePaymentElement(clientSecret, livemode);
        await mountRidePaymentRequestButton(
          clientSecret,
          ridePaymentState.totalAmountCents,
          livemode
        );
        if (!ridePaymentState.paymentRequest && rideFareUnavailable) {
          rideFareUnavailable.textContent =
            "Apple Pay / Google Pay are unavailable on this device.";
        }
        updateRideFareStatus("Choose a payment method to finish.", false);
        if (rideFareClose) {
          rideFareClose.disabled = false;
        }
      } catch (err) {
        if (ridePaymentState.intentRequestId !== currentRequestId) {
          return;
        }
        updateRideFareStatus(err?.message || PAYMENT_ERROR_FALLBACK, true);
        if (rideFareUnavailable) {
          rideFareUnavailable.textContent =
            "Contact RideSync support if you need help completing this payment.";
        }
        if (rideCardMessage) {
          rideCardMessage.textContent = err?.message || "";
        }
      } finally {
        if (ridePaymentState.intentRequestId === currentRequestId) {
          ridePaymentState.processing = false;
        }
      }
    }

    async function mountRidePaymentRequestButton(clientSecret, amountCents, livemode) {
      if (!rideFarePaymentRequest) return;
      const stripe = await ensureStripeInstance(livemode);
      const paymentRequest = stripe.paymentRequest({
        country: "US",
        currency: "usd",
        total: {
          label: "RideSync Fare",
          amount: Math.round(amountCents),
        },
        requestPayerName: true,
        requestPayerEmail: true,
      });
      const canPay = await paymentRequest.canMakePayment();
      if (!canPay) {
        if (rideFareUnavailable) {
          rideFareUnavailable.textContent =
            "Apple Pay / Google Pay is not available on this device.";
        }
        if (rideFareClose) {
          rideFareClose.disabled = false;
        }
        return;
      }
      const elements = stripe.elements();
      const buttonElement = elements.create("paymentRequestButton", {
        paymentRequest,
        style: {
          paymentRequestButton: {
            theme: "dark",
            height: "48px",
          },
        },
      });
      paymentRequest.on("paymentmethod", (event) => {
        handleRidePaymentRequest(event);
      });
      rideFarePaymentRequest.innerHTML = "";
      buttonElement.mount(rideFarePaymentRequest);
      ridePaymentState.paymentRequest = paymentRequest;
      ridePaymentState.paymentRequestElement = buttonElement;
      ridePaymentState.paymentRequestElementsInstance = elements;
      if (rideFareClose) {
        rideFareClose.disabled = false;
      }
    }

    async function mountRidePaymentElement(clientSecret, livemode) {
      if (!rideCardElement || !clientSecret) {
        return;
      }
      if (ridePaymentState.paymentElement) {
        ridePaymentState.paymentElement.unmount();
        ridePaymentState.paymentElement = null;
      }
      const stripe = await ensureStripeInstance(livemode);
      const elements = stripe.elements({ clientSecret });
      const paymentElement = elements.create("payment");
      rideCardElement.innerHTML = "";
      paymentElement.mount(rideCardElement);
      ridePaymentState.paymentElements = elements;
      ridePaymentState.paymentElement = paymentElement;
      if (rideCardSubmit) {
        rideCardSubmit.disabled = false;
      }
      if (rideCardMessage) {
        rideCardMessage.textContent = "";
      }
    }

    function sanitizeDestinationLabel(value) {
      if (typeof value !== "string") {
        return "";
      }
      return value.trim().slice(0, 140);
    }

    const MEMBERSHIP_INACTIVE_STATUS_COPY = {
      expired:
        "Your membership expired and is not covering this fare. Renew to restore savings.",
      canceled:
        "Your membership was canceled and is not covering this fare. Start a new plan to unlock savings again.",
      inactive:
        "Your membership is inactive and is not covering this fare. Update billing or contact RideSync support to reactivate it.",
      none:
        "Your membership isn’t active for this fare. Start or renew a plan to apply savings.",
    };

    function buildRideMembershipMessage(planKey, status) {
      const normalizedPlan = normalizePlanKey(planKey);
      const normalizedStatus = (status || "none").toLowerCase();
      if (normalizedPlan === "basic") {
        return "Basic rides pay per trip. Contact RideSync support to change plans.";
      }
      if (normalizedStatus === "pending_verification") {
        return "We’re verifying your membership. Tips remain optional.";
      }
      if (normalizedStatus === "active") {
        return "Your membership is covering this fare. Tips remain optional.";
      }
      if (MEMBERSHIP_INACTIVE_STATUS_COPY[normalizedStatus]) {
        return MEMBERSHIP_INACTIVE_STATUS_COPY[normalizedStatus];
      }
      return "Membership savings could not be confirmed for this fare. Contact RideSync support if this seems incorrect.";
    }

    function buildRideFareSummary(ride = {}) {
      const pickupCandidate =
        ride.pickupAddress ||
        ride.fromAddress ||
        ride.pickupLabel ||
        ride.pickupDescription ||
        ride.fromLocationLabel ||
        "";
      const dropoffCandidate =
        ride.toDestination ||
        ride.dropoffAddress ||
        ride.destination ||
        ride.dropoffDescription ||
        "";
      const distanceMeters =
        ride.distanceMeters ||
        ride.metrics?.distanceMeters ||
        ride.rideMetrics?.distanceMeters;
      const durationMinutes =
        ride.durationMinutes ||
        ride.estimatedDurationMinutes ||
        ride.metrics?.durationMinutes ||
        ride.rideMetrics?.durationMinutes;
      const membershipPlanCandidate =
        ride.membershipType ||
        ride.membership ||
        ride.fare?.membershipPlan ||
        ride.fare?.plan ||
        ride.fare?.planKey ||
        getProfilePlanKey();
      const membershipPlan = normalizePlanKey(membershipPlanCandidate);
      const membershipStatus =
        ride.membershipStatus ||
        ride.fare?.membershipStatus ||
        currentUserProfile?.membershipStatus ||
        "none";
      const membershipLabel =
        ride.fare?.membershipLabel ||
        formatMembershipSummary(membershipPlan, membershipStatus);
      return {
        pickup: pickupCandidate ? sanitizeDestinationLabel(pickupCandidate) : "",
        dropoff: dropoffCandidate ? sanitizeDestinationLabel(dropoffCandidate) : "",
        distanceMiles: Number.isFinite(distanceMeters)
          ? distanceMeters * METERS_TO_MILES
          : null,
        durationMinutes: Number.isFinite(durationMinutes)
          ? durationMinutes
          : null,
        membershipLabel,
        membershipMessage: buildRideMembershipMessage(
          membershipPlan,
          membershipStatus
        ),
      };
    }

    function rideRequiresFarePayment(rideData = {}) {
      const status = (rideData.paymentStatus || "").toLowerCase();
      if (!PAYMENT_STATUSES_REQUIRING_COLLECTION.has(status)) {
        return 0;
      }
      const amountCents = resolveRideCheckoutAmountCents(rideData);
      if (!amountCents || amountCents <= 0) {
        return 0;
      }
      return amountCents;
    }

    async function handleRidePaymentRequest(event) {
      const paymentIntentContext = snapshotActivePaymentIntentContext();
      if (!paymentIntentContext) {
        event.complete("fail");
        updateRideFareStatus("Payment is still being prepared. Try again.", true);
        return;
      }
      ridePaymentState.processing = true;
      updateRideFareStatus("Processing payment…", false);
      try {
        const stripe = await ensureStripeInstance(
          paymentIntentContext.livemode ?? ridePaymentState.livemode
        );
        const { error, paymentIntent } = await stripe.confirmCardPayment(
          paymentIntentContext.clientSecret,
          {
            payment_method: event.paymentMethod.id,
          },
          { handleActions: false }
        );
        if (error) {
          event.complete("fail");
          updateRideFareStatus(error.message || PAYMENT_ERROR_FALLBACK, true);
          ridePaymentState.processing = false;
          return;
        }
        event.complete("success");
        if (paymentIntent && paymentIntent.status === "requires_action") {
          const { error: actionError } = await stripe.confirmCardPayment(
            paymentIntentContext.clientSecret
          );
          if (actionError) {
            updateRideFareStatus(actionError.message || PAYMENT_ERROR_FALLBACK, true);
            ridePaymentState.processing = false;
            return;
          }
        }
        await markRideFarePaid(paymentIntent?.id || null);
        ridePaymentState.completed = true;
        ridePaymentState.processing = false;
        updateRideFareStatus(
          "Payment complete. Thank you for riding with RideSync!",
          false
        );
        if (rideFareClose) {
          rideFareClose.disabled = false;
        }
        setTimeout(() => {
          closeRideFareOverlay();
        }, 1800);
      } catch (err) {
        event.complete("fail");
        ridePaymentState.processing = false;
        updateRideFareStatus(err?.message || PAYMENT_ERROR_FALLBACK, true);
      }
    }

    async function handleRideCardSubmit() {
      const paymentElementsInstance = ridePaymentState.paymentElements;
      if (!paymentElementsInstance) {
        if (rideCardMessage) {
          rideCardMessage.textContent =
            "Payment is still being prepared. Please try again.";
        }
        return;
      }
      const paymentIntentContext = snapshotActivePaymentIntentContext();
      if (!paymentIntentContext) {
        if (rideCardMessage) {
          rideCardMessage.textContent =
            "Payment is still being prepared. Please try again.";
        }
        return;
      }
      if (rideCardMessage) {
        rideCardMessage.textContent = "";
      }
      if (rideCardSubmit) {
        rideCardSubmit.disabled = true;
      }
      ridePaymentState.processing = true;
      updateRideFareStatus("Processing card payment…", false);
      try {
        const stripe = await ensureStripeInstance(
          paymentIntentContext.livemode ?? ridePaymentState.livemode
        );
        const result = await stripe.confirmPayment({
          elements: paymentElementsInstance,
          clientSecret: paymentIntentContext.clientSecret,
          redirect: "if_required",
        });
        if (result.error) {
          throw new Error(result.error.message || PAYMENT_ERROR_FALLBACK);
        }
        if (!result.paymentIntent || result.paymentIntent.status !== "succeeded") {
          throw new Error("Payment did not complete.");
        }
        await markRideFarePaid(result.paymentIntent.id);
        ridePaymentState.completed = true;
        updateRideFareStatus(
          "Payment complete. Thank you for riding with RideSync!",
          false
        );
        setTimeout(() => {
          closeRideFareOverlay();
        }, 1800);
      } catch (err) {
        updateRideFareStatus(err?.message || PAYMENT_ERROR_FALLBACK, true);
        if (rideCardMessage) {
          rideCardMessage.textContent = err?.message || PAYMENT_ERROR_FALLBACK;
        }
      } finally {
        ridePaymentState.processing = false;
        if (rideCardSubmit && !ridePaymentState.completed) {
          rideCardSubmit.disabled = false;
        }
      }
    }

    function snapshotActivePaymentIntentContext() {
      const context = ridePaymentState.clientSecretContext;
      if (!context || !context.clientSecret) {
        return null;
      }
      return {
        clientSecret: context.clientSecret,
        livemode: context.livemode ?? null,
        totalAmountCents: context.totalAmountCents,
        baseAmountCents: context.baseAmountCents,
        tipAmountCents: context.tipAmountCents,
      };
    }

    async function markRideFarePaid(paymentIntentId) {
      if (!ridePaymentState.rideId) {
        return;
      }
      try {
        await confirmRidePaymentIntentFn({
          rideId: ridePaymentState.rideId,
          paymentIntentId,
        });
        profileMessage.textContent = "Payment received. Thanks for riding!";
      } catch (err) {
        console.warn("Failed to update ride payment status", err);
        showErrorBanner(err.message || PAYMENT_ERROR_FALLBACK);
      }
    }

    function refreshRideTipCaptureState(rideId, rideData = {}) {
      const paymentStatus = (rideData.paymentStatus || "").toLowerCase();
      const rideStatus = (rideData.status || "").toLowerCase();
      const needsCapture =
        PAYMENT_STATUSES_REQUIRING_COLLECTION.has(paymentStatus) &&
        typeof rideData.stripePaymentIntentId === "string" &&
        ["dropoff_code_verified", "completed"].includes(rideStatus);
      if (!needsCapture) {
        resetFinalTipUi();
        return;
      }
      rideTipCaptureState.rideId = rideId;
      rideTipCaptureState.paymentIntentId = rideData.stripePaymentIntentId;
      rideTipCaptureState.baseFareAmountCents = Math.max(
        0,
        Math.round(
          rideData.fareBaseAmountCents ||
            rideData.stripeAmountCents ||
            resolveRideCheckoutAmountCents(rideData) ||
            0
        )
      );
      const paymentAuthAmountCents = Math.max(
        0,
        Math.round(rideData.paymentAuthAmountCents || 0)
      );
      const tipHoldAllowance = Math.max(
        0,
        paymentAuthAmountCents - rideTipCaptureState.baseFareAmountCents
      );
      const fallbackTipLimit = Math.max(
        MIN_RIDE_TIP_CENTS,
        Math.round(rideData.maxTipAmountCents || DEFAULT_MAX_TIP_CENTS)
      );
      const effectiveTipLimit =
        tipHoldAllowance > 0 || paymentAuthAmountCents > 0
          ? tipHoldAllowance
          : fallbackTipLimit;
      rideTipCaptureState.maxTipAmountCents = Math.max(
        MIN_RIDE_TIP_CENTS,
        Math.round(effectiveTipLimit)
      );
      rideTipCaptureState.selectedTipCents = clampTipAmount(
        Math.round(rideData.tipAmountCents || MIN_RIDE_TIP_CENTS),
        MIN_RIDE_TIP_CENTS,
        rideTipCaptureState.maxTipAmountCents
      );
      updateFinalTipUi();
    }

    function resetFinalTipUi() {
      rideTipCaptureState.rideId = null;
      rideTipCaptureState.paymentIntentId = null;
      rideTipCaptureState.baseFareAmountCents = 0;
      if (finalTipSection) {
        finalTipSection.style.display = "none";
      }
      if (finalizeTipMessage) {
        finalizeTipMessage.textContent = "";
      }
      if (finalizeTipButton) {
        finalizeTipButton.disabled = false;
      }
    }

    function updateFinalTipUi() {
      if (!finalTipSection) return;
      const shouldShow =
        rideTipCaptureState.rideId &&
        rideTipCaptureState.paymentIntentId &&
        rideTipCaptureState.baseFareAmountCents > 0;
      finalTipSection.style.display = shouldShow ? "block" : "none";
      if (!shouldShow) {
        if (finalizeTipMessage) finalizeTipMessage.textContent = "";
        return;
      }
      if (finalTipInput) {
        finalTipInput.value = (rideTipCaptureState.selectedTipCents / 100).toFixed(2);
      }
      if (finalTipHint) {
        finalTipHint.textContent = `Tips are optional. You can tip up to ${formatCurrencyFromCents(
          rideTipCaptureState.maxTipAmountCents,
          "usd"
        )}.`;
      }
      if (finalizeTipMessage) {
        finalizeTipMessage.textContent = "";
      }
      if (finalizeTipButton) {
        finalizeTipButton.disabled = false;
      }
    }

    function adjustFinalTip(deltaCents) {
      const nextValue = rideTipCaptureState.selectedTipCents + deltaCents;
      rideTipCaptureState.selectedTipCents = clampTipAmount(
        nextValue,
        MIN_RIDE_TIP_CENTS,
        rideTipCaptureState.maxTipAmountCents
      );
      updateFinalTipUi();
    }

    function handleFinalTipInputChange() {
      if (!finalTipInput) return;
      rideTipCaptureState.selectedTipCents = clampTipAmount(
        dollarsToCents(finalTipInput.value),
        MIN_RIDE_TIP_CENTS,
        rideTipCaptureState.maxTipAmountCents
      );
      updateFinalTipUi();
    }

    async function handleFinalizeTipSubmit() {
      if (rideTipCaptureState.submitting) return;
      if (!rideTipCaptureState.rideId || !rideTipCaptureState.paymentIntentId) {
        if (finalizeTipMessage) {
          finalizeTipMessage.textContent = "Payment not found.";
        }
        return;
      }
      rideTipCaptureState.submitting = true;
      if (finalizeTipButton) {
        finalizeTipButton.disabled = true;
      }
      if (finalizeTipMessage) {
        finalizeTipMessage.textContent = "Finishing payment…";
      }
      try {
        await captureRidePaymentIntentFn({
          rideId: rideTipCaptureState.rideId,
          paymentIntentId: rideTipCaptureState.paymentIntentId,
          finalTipAmount: rideTipCaptureState.selectedTipCents,
          finalFareAmount: rideTipCaptureState.baseFareAmountCents,
        });
        if (finalizeTipMessage) {
          finalizeTipMessage.textContent = "Payment complete. Thank you!";
        }
      } catch (err) {
        if (finalizeTipMessage) {
          finalizeTipMessage.textContent = err?.message || PAYMENT_ERROR_FALLBACK;
        }
        if (finalizeTipButton) {
          finalizeTipButton.disabled = false;
        }
      } finally {
        rideTipCaptureState.submitting = false;
      }
    }

    function maybePromptRideFareOverlay(rideId, rideData) {
      const amountCents = rideRequiresFarePayment(rideData);
      if (!amountCents) {
        if (ridePaymentState.showing && ridePaymentState.rideId === rideId) {
          closeRideFareOverlay(true);
        }
        return;
      }
      if (ridePaymentState.processing) {
        return;
      }
      if (ridePaymentState.showing && ridePaymentState.rideId === rideId) {
        return;
      }
      const summary = buildRideFareSummary(rideData);
      openRideFareOverlay({
        rideId,
        amountCents,
        summary,
      }).catch((err) => {
        console.error("Ride payment overlay error", err);
      });
    }

    async function showPaymentResultFromLocation() {
      // Ride fares now complete entirely inside the PWA; no redirect handling required.
    }

    // Rider memberships are now informational only; no separate checkout flow is initiated here.
    if (paymentOverlayClose) {
      paymentOverlayClose.addEventListener("click", () => {
        const context = activePaymentContext;
        hidePaymentRedirectOverlay();
        closePaymentOverlay();
        if (context?.type === "ride_preauth") {
          rejectRidePreauthFlow(new Error("Payment canceled."));
          return;
        }
        if (context?.type === "ride") {
          profileMessage.textContent = "Ride payment canceled. Ride not requested.";
        }
      });
    }

    if (paymentOverlayConfirm) {
      paymentOverlayConfirm.addEventListener("click", confirmActivePayment);
    }

    if (paymentOverlay) {
      paymentOverlay.addEventListener("click", (event) => {
        if (event.target === paymentOverlay) {
          const context = activePaymentContext;
          hidePaymentRedirectOverlay();
          closePaymentOverlay();
          if (context?.type === "ride_preauth") {
            rejectRidePreauthFlow(new Error("Payment canceled."));
            return;
          }
          if (context?.type === "ride") {
            profileMessage.textContent = "Ride payment canceled. Ride not requested.";
          }
        }
      });
    }

    if (rideFareClose) {
      rideFareClose.addEventListener("click", handleRideFareDismiss);
    }
    if (rideFareOverlay) {
      rideFareOverlay.addEventListener("click", (event) => {
        if (event.target === rideFareOverlay) {
          handleRideFareDismiss();
        }
      });
    }

    if (paymentStatusBackButton) {
      paymentStatusBackButton.addEventListener("click", () => {
        closePaymentStatusOverlay();
        window.location.href = "/";
      });
    }

    async function ensureStripeInstance(livemode = null) {
      if (!STRIPE_ENABLED) {
        throw new Error("Stripe payments are not available right now.");
      }
      const publishableKey = resolveStripePublishableKeyForMode(livemode);
      logStripeDebug("ensureStripeInstance", {
        livemode,
        publishableKeyTail: publishableKey
          ? publishableKey.slice(0, 10) + "..." + publishableKey.slice(-6)
          : null,
      });
      if (!publishableKey) {
        const modeLabel = livemode === false ? "test" : "live";
        const guidance =
          modeLabel === "test"
            ? "Set stripe.publishableKeyTest (test mode) in app-config.json."
            : "Set stripe.publishableKey or stripe.publishableKeyLive in app-config.json.";
        throw new Error(
          `Stripe ${modeLabel} publishable key is not configured. ${guidance}`
        );
      }
      await loadStripeJs();
      if (!window.Stripe) {
        throw new Error("Stripe.js is not available.");
      }
      if (!stripeInstancesByKey.has(publishableKey)) {
        stripeInstancesByKey.set(publishableKey, window.Stripe(publishableKey));
      }
      return stripeInstancesByKey.get(publishableKey);
    }

    async function mountStripePaymentElement(clientSecret, livemode = null) {
      if (!paymentElementContainer) {
        throw new Error("Payment UI is unavailable.");
      }
      logStripeDebug("mountStripePaymentElement: before ensureStripeInstance", {
        livemode,
        clientSecretTail: clientSecret
          ? clientSecret.slice(0, 10) + "..." + clientSecret.slice(-6)
          : null,
      });
      const stripe = await ensureStripeInstance(livemode);
      if (stripePaymentElement) {
        stripePaymentElement.unmount();
        stripePaymentElement = null;
      }
      const elementOptions = { clientSecret };
      if (FORCE_DISABLE_GOOGLE_PAY) {
        elementOptions.wallets = { googlePay: "never" };
      }
      logStripeDebug("mountStripePaymentElement: creating elements", {
        elementOptions,
      });
      try {
        stripeElements = stripe.elements(elementOptions);
        stripePaymentElement = stripeElements.create("payment");
        stripePaymentElement.mount(paymentElementContainer);
        logStripeDebug("mountStripePaymentElement: mounted", {});
      } catch (err) {
        console.error("Stripe PaymentElement mount failed", err);
        throw err;
      }
    }

    async function openPaymentOverlay(options = {}) {
      const useStripePaymentElement =
        options.useStripePaymentElement !== false;
      const livemode = options.livemode ?? null;
      if (useStripePaymentElement && !options.clientSecret) {
        throw new Error("Stripe client secret missing.");
      }
      const isRidePreauth = options.context?.type === "ride_preauth";
      logStripeDebug("openPaymentOverlay", {
        title: options.title,
        contextType: options.context?.type,
        livemode,
        useStripePaymentElement,
        clientSecretTail:
          options.clientSecret && useStripePaymentElement
            ? options.clientSecret.slice(0, 10) +
              "..." +
              options.clientSecret.slice(-6)
            : null,
      });
      if (useStripePaymentElement) {
        if (paymentElementContainer) {
          paymentElementContainer.style.display = "";
        }
        await mountStripePaymentElement(options.clientSecret, livemode);
        activePaymentLivemode = livemode;
      } else {
        if (paymentElementContainer) {
          paymentElementContainer.style.display = "none";
        }
        if (stripePaymentElement) {
          stripePaymentElement.unmount();
          stripePaymentElement = null;
        }
        stripeElements = null;
        activePaymentLivemode = null;
      }
      activePaymentContext = {
        ...(options.context || {}),
        useStripePaymentElement,
        checkoutAmountCents: options.checkoutAmountCents ?? null,
        checkoutDescription: options.checkoutDescription || null,
      };
      lastPaymentOverlayOptions = {
        ...options,
        livemode,
      };
      if (options.context) {
        lastPaymentOverlayOptions.context = { ...options.context };
      }
      if (paymentOverlayTitle) {
        paymentOverlayTitle.textContent = options.title || "Pay now";
      }
      if (paymentOverlaySubtitle) {
        paymentOverlaySubtitle.textContent = options.subtitle || "";
      }
      if (paymentOverlayConfirm) {
        paymentOverlayConfirm.textContent =
          options.confirmLabel || "Pay now";
        paymentOverlayConfirm.disabled = false;
      }
      if (paymentOverlayMessage) {
        paymentOverlayMessage.textContent = "";
      }
      paymentOverlay?.classList.add("active");
      paymentOverlay?.setAttribute("aria-hidden", "false");
      if (paymentFareSummary) {
        paymentFareSummary.style.display = isRidePreauth ? "" : "none";
      }
      if (preauthTipSection) {
        preauthTipSection.style.display = isRidePreauth ? "" : "none";
      }
      if (preauthHoldSummary) {
        preauthHoldSummary.style.display = isRidePreauth ? "" : "none";
      }
      if (paymentFareSummary) {
        paymentFareSummary.style.display =
          options.context?.type === "ride" ? "" : "none";
      }
    }

    function closePaymentOverlay() {
      if (stripePaymentElement) {
        stripePaymentElement.unmount();
        stripePaymentElement = null;
      }
      stripeElements = null;
      activePaymentContext = null;
      activePaymentLivemode = null;
      paymentOverlay?.classList.remove("active");
      paymentOverlay?.setAttribute("aria-hidden", "true");
      if (paymentOverlayMessage) {
        paymentOverlayMessage.textContent = "";
      }
    }

    function showPaymentRedirectOverlay(message) {
      if (!paymentRedirectOverlay) return;
      if (paymentRedirectSubtitle && message) {
        paymentRedirectSubtitle.textContent = message;
      }
      paymentRedirectOverlay.classList.add("active");
      paymentRedirectOverlay.setAttribute("aria-hidden", "false");
    }

    function hidePaymentRedirectOverlay() {
      if (!paymentRedirectOverlay) return;
      paymentRedirectOverlay.classList.remove("active");
      paymentRedirectOverlay.setAttribute("aria-hidden", "true");
    }

    function buildRideCheckoutSessionEndpoints() {
      const endpoints = [];
      const configuredUrl = normalizeCheckoutEndpoint(
        functionsConfig.createRideCheckoutSessionUrl
      );
      if (configuredUrl) {
        endpoints.push(configuredUrl);
      }
      const defaultRelative = normalizeCheckoutEndpoint(
        "/createRideCheckoutSession"
      );
      if (defaultRelative) {
        endpoints.push(defaultRelative);
      }
      if (FIREBASE_PROJECT_ID) {
        const functionUrl = normalizeCheckoutEndpoint(
          `https://us-central1-${FIREBASE_PROJECT_ID}.cloudfunctions.net/createRideCheckoutSession`
        );
        if (functionUrl) {
          endpoints.push(functionUrl);
        }
      }
      const deduped = [];
      const seen = new Set();
      for (const endpoint of endpoints) {
        if (!endpoint || seen.has(endpoint)) {
          continue;
        }
        seen.add(endpoint);
        deduped.push(endpoint);
      }
      return deduped;
    }

    function buildMembershipFinalizeEndpoints() {
      const endpoints = [];
      const configuredUrl = normalizeCheckoutEndpoint(
        functionsConfig.finalizeMembershipCheckoutSessionUrl ||
          functionsConfig.finalizeMembershipCheckoutUrl
      );
      if (configuredUrl) {
        endpoints.push(configuredUrl);
      }
      const defaultRelative = normalizeCheckoutEndpoint(
        "/finalizeMembershipCheckoutSession"
      );
      if (defaultRelative) {
        endpoints.push(defaultRelative);
      }
      if (FIREBASE_PROJECT_ID) {
        const functionUrl = normalizeCheckoutEndpoint(
          `https://us-central1-${FIREBASE_PROJECT_ID}.cloudfunctions.net/finalizeMembershipCheckoutSession`
        );
        if (functionUrl) {
          endpoints.push(functionUrl);
        }
      }
      const deduped = [];
      const seen = new Set();
      for (const endpoint of endpoints) {
        if (!endpoint || seen.has(endpoint)) {
          continue;
        }
        seen.add(endpoint);
        deduped.push(endpoint);
      }
      return deduped;
    }

    function normalizeCheckoutEndpoint(value) {
      if (typeof value !== "string") {
        return "";
      }
      const trimmed = value.trim();
      if (!trimmed) {
        return "";
      }
      if (trimmed.startsWith("http://") || trimmed.startsWith("https://")) {
        return trimmed;
      }
      if (trimmed.startsWith("/")) {
        return trimmed;
      }
      return "";
    }

    async function confirmActivePayment() {
      if (!activePaymentContext) return;
      if (paymentOverlayMessage) {
        paymentOverlayMessage.textContent = "";
      }
      if (paymentOverlayConfirm) {
        paymentOverlayConfirm.disabled = true;
      }

      try {
        const isCheckoutRedirectRide =
          activePaymentContext?.type === "ride" &&
          activePaymentContext.useStripePaymentElement === false;
        if (isCheckoutRedirectRide) {
          await startRideCheckoutRedirect(activePaymentContext);
          return;
        }

        const stripe = await ensureStripeInstance(activePaymentLivemode);
        const result = await stripe.confirmPayment({
          elements: stripeElements,
          redirect: "if_required",
        });
        if (result.error) {
          throw new Error(result.error.message || "Payment failed.");
        }
        const paymentIntent = result.paymentIntent;
        if (!paymentIntent) {
          throw new Error("Payment did not complete.");
        }
        const paymentIntentStatus = paymentIntent.status;
        const isRidePreauth = activePaymentContext?.type === "ride_preauth";
        if (isRidePreauth) {
          if (
            paymentIntentStatus !== "requires_capture" &&
            paymentIntentStatus !== "succeeded"
          ) {
            throw new Error("Payment did not complete.");
          }
          await handleRidePreauthConfirmation(
            paymentIntent,
            activePaymentContext
          );
          closePaymentOverlay();
          return;
        }
        if (paymentIntentStatus !== "succeeded") {
          throw new Error("Payment did not complete.");
        }
        await handlePaymentSuccess(paymentIntent, activePaymentContext);
        closePaymentOverlay();
      } catch (err) {
        console.error("confirmActivePayment", err);
        if (paymentOverlayMessage) {
          paymentOverlayMessage.textContent =
            err.message || "Unable to process payment.";
        }
        if (activePaymentContext?.type === "ride") {
          showErrorBanner(err.message || PAYMENT_ERROR_FALLBACK);
        }
        if (paymentOverlayConfirm) {
          paymentOverlayConfirm.disabled = false;
        }
        if (activePaymentContext?.type === "ride") {
          hidePaymentRedirectOverlay();
        }
      }
    }

    async function activateRideAfterCreation(rideId, ridePayload) {
      currentRideId = rideId;
      activeRideIsGroup = Boolean(ridePayload?.isGroupRide);
      activeRideGuestBypass = Boolean(ridePayload?.guestBypassEnabled);
      appBody?.classList?.toggle("host-guest-bypass", guestBypassEligible || activeRideGuestBypass);
      updateGuestBypassCopy();
      if (activeRideIsGroup) {
        wantsGroupRide = true;
      }
      rememberRideProtectionState(rideId, {
        ...(ridePayload || {}),
        status: ridePayload?.status || "pending",
        userId: auth?.currentUser?.uid || ridePayload?.userId || null
      });
      startRideStatusWatcher(rideId);
      updateCancelButtonVisibility();
      refreshGroupQrVisibility();
      updateSyncRidersButtonVisibility();
      if (ridePayload?.poolType === "uofa") {
        startPoolGroupWatcher(rideId);
      }
      profileMessage.textContent = "Syncing your ride.";
      profileError.textContent = "";
      const overlaySubtitle =
        ridePayload?.toDestination ||
        ridePayload?.fare?.membershipLabel ||
        "";
      setOverlayCopy("Syncing your ride", overlaySubtitle);
      setRiderOverlayState(RIDER_STATES.SEARCHING);
      showRideView();
      if (activeRideIsGroup && (syncRidersFlowActive || syncRidersAwaitingRideActivation)) {
        openSyncRidersOverlay(rideId);
      }
      syncRidersFlowActive = false;
      syncRidersAwaitingRideActivation = false;
    }

    async function fetchActiveRideById(rideId) {
      if (!rideId) {
        return null;
      }
      try {
        const rideRef = doc(db, "rideRequests", rideId);
        const snap = await getDoc(rideRef);
        if (!snap.exists()) {
          return null;
        }
        const data = snap.data() || {};
        if (!isRideResumeEligible(data)) {
          return null;
        }
        return { id: snap.id, ...data };
      } catch (err) {
        console.warn("Active ride lookup by id failed", err);
        return null;
      }
    }

    async function resumeActiveRideSession(user) {
      if (!user || currentRideId) {
        return false;
      }
      const cachedState = loadProtectedRideState();
      if (cachedState?.userId && cachedState.userId !== user.uid) {
        clearProtectedRideState();
      }
      if (
        cachedState?.rideId &&
        cachedState.userId === user.uid &&
        isRideResumeEligible(cachedState)
      ) {
        const confirmedRide = await fetchActiveRideById(cachedState.rideId);
        if (confirmedRide) {
          rememberRideProtectionState(confirmedRide.id, confirmedRide);
          await activateRideAfterCreation(confirmedRide.id, confirmedRide);
          return true;
        }
        clearProtectedRideState();
      }
      const latestRide = await lookupLatestActiveRide(user.uid);
      if (latestRide) {
        rememberRideProtectionState(latestRide.id, latestRide);
        await activateRideAfterCreation(latestRide.id, latestRide);
        return true;
      }
      clearProtectedRideState();
      return false;
    }

    async function lookupLatestActiveRide(userId) {
      if (!userId) return null;
      try {
        const ridesRef = collection(db, "rideRequests");
        const recentQuery = query(
          ridesRef,
          where("userId", "==", userId),
          orderBy("createdAt", "desc"),
          limit(5)
        );
        const snap = await getDocs(recentQuery);
        let activeRide = null;
        snap.forEach((docSnap) => {
          if (activeRide) return;
          const data = docSnap.data();
          if (isRideResumeEligible(data)) {
            activeRide = { id: docSnap.id, ...data };
          }
        });
        return activeRide;
      } catch (err) {
        console.warn("Active ride lookup failed", err);
        return null;
      }
    }

    async function handlePaymentSuccess(paymentIntent) {
      return paymentIntent;
    }

    function buildRidePaymentPayload(rawPayload = {}) {
      const payload = { ...rawPayload };
      payload.pickupLocation =
        latLngToLiteral(payload.pickupLocation) ||
        latLngToLiteral(payload.fromLocation) ||
        null;
      payload.dropoffLocation =
        latLngToLiteral(payload.dropoffLocation) ||
        latLngToLiteral(payload.toLocation) ||
        latLngToLiteral(payload.destinationLocation) ||
        null;
      if (Array.isArray(payload.extraStops)) {
        payload.extraStops = payload.extraStops
          .map((stop, index) => {
            if (!stop) return null;
            const label = typeof stop.label === "string" ? stop.label.trim() : "";
            const location = latLngToLiteral(stop.location);
            if (!label || !isLatLngLiteral(location)) {
              return null;
            }
            return {
              order: Number.isFinite(stop.order) ? stop.order : index + 1,
              label,
              location
            };
          })
          .filter(Boolean);
        if (!payload.extraStops.length) {
          delete payload.extraStops;
        }
      }
      payload.totalCents = Number(payload.totalCents);
      payload.estimatedDurationMinutes = Number(payload.estimatedDurationMinutes);
      delete payload.createdAt;
      delete payload.updatedAt;

      if (!isLatLngLiteral(payload.pickupLocation) || !isLatLngLiteral(payload.dropoffLocation)) {
        throw new Error("Pickup and dropoff locations are required. Please refresh your route.");
      }

      if (!Number.isFinite(payload.totalCents)) {
        throw new Error("Fare estimate missing. Please refresh the fare and try again.");
      }

      if (
        !Number.isFinite(payload.estimatedDurationMinutes) ||
        payload.estimatedDurationMinutes <= 0
      ) {
        throw new Error(
          "Estimated ride duration missing. Please refresh the fare and try again."
        );
      }

      payload.totalCents = Math.max(0, Math.round(payload.totalCents));
      payload.estimatedDurationMinutes =
        Math.round(payload.estimatedDurationMinutes * 10) / 10;

      return payload;
    }

    function resolveRideCheckoutAmountCents(ride = {}) {
      const centCandidates = [
        ride.totalCents,
        ride.totalFareCents,
        ride.estimatedFareCents,
        ride.stripeAmountCents,
        ride.totalFareEstimateCents,
      ];
      for (const candidate of centCandidates) {
        const value = Number(candidate);
        if (Number.isFinite(value) && value > 0) {
          return Math.round(value);
        }
      }
      const dollarCandidates = [
        ride.total,
        ride.totalFare,
        ride.quotedTotal,
        ride.fare?.total,
        ride.fare?.totalFare,
      ];
      for (const candidate of dollarCandidates) {
        const value = Number(candidate);
        if (Number.isFinite(value) && value > 0) {
          return Math.round(value * 100);
        }
      }
      return null;
    }

    async function startRideCheckoutRedirect(context = {}) {
      const amountCents = Number(context.checkoutAmountCents || 0);
      if (!Number.isFinite(amountCents) || amountCents <= 0) {
        throw new Error("Ride fare is unavailable. Please refresh and try again.");
      }
      const description =
        context.checkoutDescription ||
        context.ridePayload?.toDestination ||
        "RideSync ride fare";
      const user = auth.currentUser;
      let idToken = null;
      if (user) {
        try {
          idToken = await user.getIdToken();
        } catch (err) {
          console.warn("Failed to read auth token for checkout session", err);
        }
      }
      showPaymentRedirectOverlay("Redirecting you to Stripe Checkout…");
      const headers = {
        "Content-Type": "application/json",
      };
      if (idToken) {
        headers.Authorization = `Bearer ${idToken}`;
      }
      const redirectBaseUrl =
        typeof window !== "undefined" && window.location?.origin
          ? window.location.origin
          : null;
      const requestPayload = {
        amountCents: Math.round(amountCents),
        description,
        ridePayload: context.ridePayload || null,
        redirectBaseUrl,
      };
      const requestBody = JSON.stringify(requestPayload);
      try {
        const sessionUrl = await requestRideCheckoutSession(headers, requestBody);
        window.location.href = sessionUrl;
        return;
      } catch (httpErr) {
        logStripeDebug("createRideCheckoutSession HTTP flow failed", {
          message:
            httpErr instanceof Error ? httpErr.message : String(httpErr ?? ""),
        });
      }
      try {
        const sessionUrl = await requestRideCheckoutSessionViaCallable(
          requestPayload
        );
        window.location.href = sessionUrl;
      } catch (err) {
        hidePaymentRedirectOverlay();
        throw err instanceof Error
          ? err
          : new Error(PAYMENT_ERROR_FALLBACK);
      }
    }

    async function requestRideCheckoutSession(headers, body) {
      let lastFailure = null;
      for (const endpoint of rideCheckoutSessionEndpoints) {
        if (!endpoint) continue;
        try {
          const response = await fetch(endpoint, {
            method: "POST",
            headers,
            body,
          });
          let data = null;
          try {
            data = await response.json();
          } catch (_) {
            data = null;
          }
          if (response.ok && data?.url) {
            return data.url;
          }
          lastFailure = {
            endpoint,
            status: response.status,
            body: data,
          };
          logStripeDebug(
            "createRideCheckoutSession endpoint rejected",
            lastFailure
          );
        } catch (err) {
          lastFailure = {
            endpoint,
            error: err instanceof Error ? err.message : String(err),
          };
          logStripeDebug(
            "createRideCheckoutSession endpoint error",
            lastFailure
          );
        }
      }
      console.error(
        "[RideSync][Stripe] Failed to create checkout session",
        lastFailure
      );
      throw new Error(PAYMENT_ERROR_FALLBACK);
    }

    async function requestRideCheckoutSessionViaCallable(payload) {
      try {
        const response = await createRideCheckoutSessionCallableFn(payload);
        const url = response?.data?.url;
        if (typeof url === "string" && url) {
          return url;
        }
        logStripeDebug("createRideCheckoutSession callable missing url", {
          payloadSummary: {
            hasData: !!response,
          },
        });
        throw new Error(PAYMENT_ERROR_FALLBACK);
      } catch (err) {
        throw handleCallableError(
          "createRideCheckoutSessionCallable",
          err,
          PAYMENT_ERROR_FALLBACK
        );
      }
    }

    async function startRidePaymentFlow(ridePayload) {
      const sanitizedRidePayload = buildRidePaymentPayload(ridePayload);
      logStripeDebug("startRidePaymentFlow: payload", {
        ridePayload,
        sanitizedRidePayload,
      });
      if (!STRIPE_ENABLED) {
        throw new Error("Stripe payments are not available right now.");
      }
      const amountCents = resolveRideCheckoutAmountCents(sanitizedRidePayload);
      if (!amountCents || amountCents <= 0) {
        throw new Error(
          "Fare estimate missing. Please refresh the fare and try again."
        );
      }
      const formattedTotal = formatCurrencyFromCents(amountCents, "usd");
      const suffix = sanitizedRidePayload.fare?.membershipLabel
        ? `${sanitizedRidePayload.fare.membershipLabel}.`
        : "Ride synced.";
      profileMessage.textContent = `${suffix} Pay ${formattedTotal} now to sync your ride.`;
      profileError.textContent = "";
      logStripeDebug(
        "startRidePaymentFlow: checkout redirect disabled, fare will be charged upfront inside the app.",
        {
          amountCents,
        }
      );
      return {
        amountCents,
        ridePayload: sanitizedRidePayload,
      };
    }

    function resolveRidePreauthFlow(value) {
      if (ridePreauthState.pendingResolve) {
        ridePreauthState.pendingResolve(value);
        ridePreauthState.pendingResolve = null;
      }
      ridePreauthState.pendingReject = null;
    }

    function rejectRidePreauthFlow(error) {
      if (ridePreauthState.pendingReject) {
        ridePreauthState.pendingReject(error);
        ridePreauthState.pendingReject = null;
      }
      ridePreauthState.pendingResolve = null;
    }

    async function handleRidePreauthConfirmation(paymentIntent, context = {}) {
      if (!context.rideId || !paymentIntent?.id) {
        throw new Error("Ride reference missing for payment confirmation.");
      }
      await confirmRidePaymentIntentFn({
        rideId: context.rideId,
        paymentIntentId: paymentIntent.id,
      });
      profileMessage.textContent = "Payment received. Syncing your ride.";
      profileError.textContent = "";
      resolveRidePreauthFlow(paymentIntent);
    }

    async function runRidePreauthFlow({ rideId, fareAmountCents }) {
      if (!rideId || !fareAmountCents) {
        return;
      }
      ridePreauthState.rideId = rideId;
      ridePreauthState.fareAmountCents = fareAmountCents;
      ridePreauthState.maxTipAmountCents = DEFAULT_MAX_TIP_CENTS;
      ridePreauthState.authAmountCents = 0;
      ridePreauthState.selectedTipCents = clampTipAmount(
        ridePreauthState.selectedTipCents,
        MIN_RIDE_TIP_CENTS,
        ridePreauthState.maxTipAmountCents
      );
      updatePreauthTipUi();

      return new Promise(async (resolve, reject) => {
        ridePreauthState.pendingResolve = resolve;
        ridePreauthState.pendingReject = reject;
        try {
          const response = await createRidePaymentIntentFn({
            rideId,
            maxTipAmountCents: ridePreauthState.maxTipAmountCents,
            initialTipAmountCents: ridePreauthState.selectedTipCents,
            fareAmountCents: Math.max(0, Math.round(fareAmountCents || 0)),
          });
          const payload = response?.data || response || {};
          ridePreauthState.maxTipAmountCents = Math.max(
            MIN_RIDE_TIP_CENTS,
            Math.round(
              payload.maxTipAmountCents ??
                ridePreauthState.maxTipAmountCents
            )
          );
          ridePreauthState.selectedTipCents = clampTipAmount(
            payload.initialTipAmountCents ?? ridePreauthState.selectedTipCents,
            MIN_RIDE_TIP_CENTS,
            ridePreauthState.maxTipAmountCents
          );
          ridePreauthState.authAmountCents =
            Math.max(
              0,
              Math.round(payload.authAmountCents || 0)
            ) ||
            ridePreauthState.fareAmountCents +
              Math.max(0, ridePreauthState.selectedTipCents || 0);
          updatePreauthTipUi();
          await openPaymentOverlay({
            title: "Pay now to sync your ride",
            subtitle: "We'll charge your fare plus the tip you selected right away.",
            clientSecret: payload.clientSecret,
            livemode: payload.livemode ?? null,
            context: {
              type: "ride_preauth",
              rideId,
            },
          });
        } catch (err) {
          ridePreauthState.pendingResolve = null;
          ridePreauthState.pendingReject = null;
          reject(err);
        }
      });
    }

    async function handleNewRide() {
      const user = auth.currentUser;
      if (!user) return;
      if (!hasOnlineDrivers) {
        profileMessage.textContent =
          "Drivers look offline right now. We'll notify them as soon as you sync.";
      } else {
        profileMessage.textContent = "";
      }
      profileError.textContent = "";
      clearPoolGroupUI();
      activeRideIsGroup = false;
      refreshGroupQrVisibility();

      if (!destinationLatLng || !lastRideMetrics || !lastRideMetrics.fareBreakdown) {
        profileError.textContent = "Set destination and wait for fare estimate first.";
        updateRouteAndFare();
        return;
      }

      const plan = normalizePlanKey(
        currentUserProfile?.membershipType || currentUserProfile?.membership || "basic"
      );
      const planIsBasic = plan === "basic";
      const membershipStatus = currentUserProfile?.membershipStatus || "none";
      const isStudent = !!currentUserProfile?.isStudent;
      const uofaVerified = !!currentUserProfile?.uofaVerified;
      const poolGender = normalizePoolGender(currentUserProfile?.gender);
      const genderPoolEligible = !!poolGender;
      const numRiders = parseInt(numRidersEl.value || "1", 10);
      const inHomeZone = !!lastRideMetrics?.pickupCovered;

      const uofaPoolEligible =
        plan === "uofa_unlimited" &&
        isStudent &&
        uofaVerified &&
        genderPoolEligible &&
        inHomeZone;

      const fare = lastRideMetrics.fareBreakdown;
      const totalValue = Number.isFinite(fare.total) ? fare.total : 0;
      const totalCents = Math.max(0, Math.round(totalValue * 100));
      const reserveFeeCents = Math.max(0, Math.round(syncConfirmState.reserveFeeCents || 0));
      const reserveTimeIso = syncConfirmState.reserveTimeIso || null;
      const referralCode =
        (syncConfirmState.referral.code || "").trim() || null;
      const referralDiscountCents = Math.max(
        0,
        Math.round(syncConfirmState.referral.discountCents || 0)
      );
      const referralDescription =
        syncConfirmState.referral.description?.trim() || "";

      const cd = await checkCooldown(user.uid, plan);
      if (cd.allowed === false) {
        profileError.textContent = `You can request another ride in about ${cd.remainingMinutes} min.`;
        return;
      }

      let poolType = null;
      let status = "pending_driver";

      if (uofaPoolEligible && numRiders === 1) {
        poolType = "uofa";
        status = "pool_searching";
      }

      const destAddress =
        destinationEl.value.trim() ||
        lastDestinationPlace?.formatted_address ||
        "";

      const riderName =
        currentUserProfile?.fullName ||
        currentUserProfile?.name ||
        currentUserProfile?.displayName ||
        (currentUserProfile?.email
          ? currentUserProfile.email.split("@")[0]
          : "Rider");

      const riderPhone =
        currentUserProfile?.phone || currentUserProfile?.phoneNumber || "";
      const riderPhotoUrl =
        currentUserProfile?.profilePicUrl ||
        currentUserProfile?.photoURL ||
        null;

      const maxRiders = numRiders;
      const isGroupRide = maxRiders > 1;
      const pickupCode = generateRidePin();
      const dropoffCode = generateRidePin();
      const pickupLocationLiteral = currentLocation
        ? { lat: currentLocation.lat, lng: currentLocation.lng }
        : null;
      const dropoffLocationLiteral = latLngToLiteral(destinationLatLng);
      if (!pickupLocationLiteral || !dropoffLocationLiteral) {
        profileError.textContent = "Missing pickup or dropoff location.";
        return;
      }
      let extraStopsPayload = [];
      try {
        extraStopsPayload = collectExtraStopsForRide();
      } catch (stopErr) {
        profileError.textContent = stopErr.message;
        return;
      }

      const rideBase = {
        isGroupRide,
        maxRiders,
        guestBypassEnabled: guestBypassEligible || activeRideGuestBypass,
        poolType,
        numRiders,
        pickupLocation: pickupLocationLiteral,
        dropoffLocation: dropoffLocationLiteral,
        toDestination: destAddress || null,
        inHomeZone,
        estimatedDurationMinutes: lastRideMetrics.durationMinutes
          ? +lastRideMetrics.durationMinutes.toFixed(1)
          : null,
        distanceMeters: lastRideMetrics.distanceMeters || null,
        fare,
        totalCents,
          reserveFeeCents,
          reserveTimeIso,
          referralCode,
          referralDiscountCents,
          referralDescription: referralDescription || null,
        extraStops: extraStopsPayload,
        status
      };
      let rideCreationResult = null;
      try {
        if (syncButton) {
          syncButton.disabled = true;
          syncButton.textContent = "Syncing...";
        }
        const response = await createRideRequestFn({
          ride: {
            ...rideBase,
            fromLocation: currentLocation || pickupLocationLiteral,
            pickupCity: currentUserProfile?.city || null,
            riderContext: {
              name: riderName,
              phone: riderPhone,
              photoUrl: riderPhotoUrl
            }
          }
        });
        const result = response?.data || {};
        rideCreationResult = result;
        if (!result.rideId) {
          throw new Error(result?.message || "Ride was not created.");
        }
        const requiresPayment = Number(result.amountCents || 0) > 0;
        if (requiresPayment) {
          await runRidePreauthFlow({
            rideId: result.rideId,
            fareAmountCents: Math.max(0, Math.round(result.amountCents || 0)),
          });
        } else {
          profileMessage.textContent = "Ride synced! Your membership covers this fare.";
          profileError.textContent = "";
        }
        activateRideAfterCreation(result.rideId, result.ride || rideBase);
      } catch (err) {
        console.error("New ride error", err);
        if (rideCreationResult?.rideId) {
          try {
            await cancelRideRequestFn({ rideId: rideCreationResult.rideId });
          } catch (_) {
            // best effort
          }
        }
        profileError.textContent = err.message || "Could not start this ride.";
        profileMessage.textContent = "";
        syncRidersAwaitingRideActivation = false;
        syncRidersFlowActive = false;
      } finally {
        if (syncButton) {
          syncButton.disabled = false;
          updateSyncButtonLabel();
        }
        if (!syncRidersAwaitingRideActivation) {
          syncRidersFlowActive = false;
        }
      }
    }

    async function handleJoinRide() {
      const user = auth.currentUser;
      if (!user || !joinTargetRide) {
        profileError.textContent = "Unable to join this ride.";
        return;
      }
      if (!hasOnlineDrivers) {
        profileMessage.textContent =
          "Drivers look offline right now. We'll notify them as soon as you join.";
      } else {
        profileMessage.textContent = "";
      }
      profileError.textContent = "";
      cancelError.textContent = "";

      try {
        const plan = normalizePlanKey(
          currentUserProfile?.membershipType ||
            currentUserProfile?.membership ||
            "basic"
        );
        const requiresGenderMatch = joinTargetRide?.poolType === "uofa";
        const riderGender = normalizePoolGender(currentUserProfile?.gender);
        if (requiresGenderMatch && !riderGender) {
          profileError.textContent =
            "Set your profile gender to Male or Female to join pooling rides.";
          return;
        }
        const targetGender = normalizePoolGender(joinTargetRide?.gender);
        if (
          requiresGenderMatch &&
          (!targetGender || targetGender !== riderGender)
        ) {
          profileError.textContent =
            "You can only join riders who share your gender.";
          return;
        }

        const cooldown = await checkCooldown(user.uid, plan);
        if (cooldown.allowed === false) {
          profileError.textContent = `You can request another ride in about ${cooldown.remainingMinutes} min.`;
          return;
        }

        if (syncButton) {
          syncButton.disabled = true;
          syncButton.textContent = "Joining…";
        }

        const response = await joinRideGroupFn({ hostRideId: joinTargetRide.id });
        const rideId = response?.data?.rideId;
        if (!rideId) {
          throw new Error("This group ride is no longer available.");
        }

        const joinDestination =
          joinTargetRide?.toDestination ||
          joinTargetRide?.toAddress ||
          "";
        currentRideId = rideId;
        rememberRideProtectionState(rideId, {
          status: "pool_searching",
          toDestination: joinDestination,
          isGroupRide:
            joinTargetRide?.isGroupRide === true ||
            Number(joinTargetRide?.maxRiders || 1) > 1,
          poolType: joinTargetRide?.poolType || null,
          userId: user.uid
        });
        joinMode = false;
        joinTargetRide = null;
        startRideStatusWatcher(rideId);
        updateCancelButtonVisibility();
        activeRideIsGroup = false;
        refreshGroupQrVisibility();
        setOverlayCopy("Syncing your ride", joinDestination);
        setRiderOverlayState(RIDER_STATES.SEARCHING);
        showRideView();
      } catch (err) {
        console.error("Join ride error", err);
        profileError.textContent = err.message || "Could not join group ride.";
      } finally {
        if (syncButton) {
          syncButton.disabled = false;
          updateSyncButtonLabel();
        }
      }
    }

    async function ensureDestinationReadyAndOpenSyncConfirm(options = {}) {
      const {
        triggerButton = null,
        loadingLabel = "Checking…",
        afterReset = null
      } = options;
      if (joinMode && joinTargetRide) {
        await handleJoinRide();
        return false;
      }
      const resetButton = setButtonBusy(triggerButton, loadingLabel);
      const ready = await ensureDestinationReadyForSync();
      if (typeof resetButton === "function") {
        resetButton();
      }
      if (typeof afterReset === "function") {
        afterReset();
      }
      if (!ready) {
        return false;
      }
      openSyncConfirmOverlay();
      return true;
    }

    syncButton.addEventListener("click", async () => {
      await ensureDestinationReadyAndOpenSyncConfirm({
        triggerButton: syncButton,
        loadingLabel: "Checking…",
        afterReset: updateSyncButtonLabel
      });
    });

    if (syncRidersButton) {
      syncRidersButton.addEventListener("click", () => {
        if (!wantsGroupRide) {
          profileError.textContent = "Select at least 2 riders to sync.";
          return;
        }
        if (!currentRideId) {
          profileError.textContent =
            "Sync your destination first to generate the group QR.";
          return;
        }
        if (!activeRideIsGroup) {
          profileError.textContent = "Sync this ride with 2–4 riders to share the QR.";
          return;
        }
        openSyncRidersOverlay(currentRideId);
      });
    }

    if (syncRidersOverlayClose) {
      syncRidersOverlayClose.addEventListener("click", closeSyncRidersOverlay);
    }

    if (syncRidersOverlay) {
      syncRidersOverlay.addEventListener("click", (event) => {
        if (event.target === syncRidersOverlay) {
          closeSyncRidersOverlay();
        }
      });
    }

    if (syncRidersCopyLink) {
      syncRidersCopyLink.addEventListener("click", async () => {
        if (!syncRidersJoinUrl) {
          if (syncRidersCopyFeedback) {
            syncRidersCopyFeedback.textContent = "Generate your ride QR first.";
          }
          return;
        }
        try {
          await navigator.clipboard.writeText(syncRidersJoinUrl);
          if (syncRidersCopyFeedback) {
            syncRidersCopyFeedback.textContent = "Link copied to clipboard.";
          }
        } catch (err) {
          if (syncRidersCopyFeedback) {
            syncRidersCopyFeedback.textContent = syncRidersJoinUrl;
          }
        }
      });
    }

    showPaymentResultFromLocation();

    async function enterJoinMode(rideId) {
      try {
        const hostRef = doc(db, "rideRequests", rideId);
        const snap = await getDoc(hostRef);
        if (!snap.exists()) {
          console.warn("Join ride not found");
          return;
        }
        const host = snap.data();
        joinMode = true;
        joinTargetRide = { id: snap.id, ...host };
        applyGuestBypassFromHost(joinTargetRide);

        joinBanner.style.display = "block";
        const cur = host.currentRiderCount || 1;
        const max = host.maxRiders || 1;
        joinBannerText.textContent = `Joining group ride to "${host.toDestination || "destination"}". Group: ${cur} of ${max} riders. You will join as 1 rider. If you need an extra stop, tell your driver when picked up.`;

        ridersSection.style.display = "none";
        numRidersEl.value = "1";
        numRidersEl.disabled = true;
        updateGroupRideIntentFromSelect();

        if (host.toDestination) {
          destinationEl.value = host.toDestination;
          updateSyncRidersButtonVisibility();
        }
        updateSyncButtonLabel();
      } catch (err) {
        console.error("Failed to enter join mode", err);
      }
    }

      function ensureBackgroundMapReady() {
        if (googleMapsLoadFailed) return;
        if (map) return;
        if (window.google && google.maps) {
          initMapOnce();
          return;
        }
        setTimeout(ensureBackgroundMapReady, 600);
      }

      function trySetupAutocompleteEarly() {
        if (googleMapsLoadFailed) return;
        if (!window.google || !google.maps || !google.maps.places) {
          setTimeout(trySetupAutocompleteEarly, 800);
          return;
        }
        setupDestinationAutocomplete();
        extraStopsState.forEach((stop) => setupExtraStopAutocomplete(stop));
      }

    let deferredPwaPrompt = null;
    let pwaOverlayTimeoutId = null;

    window.addEventListener("beforeinstallprompt", (event) => {
      event.preventDefault();
      deferredPwaPrompt = event;
      const btn = document.getElementById("pwaInstallButton");
      if (btn) {
        btn.disabled = false;
      }
    });

    window.addEventListener("appinstalled", () => {
      try {
        localStorage.setItem("ridesync_pwa_installed", "1");
      } catch (_) {
        // ignore storage errors
      }
      hidePwaOverlay();
    });

    function isStandalone() {
      return (
        window.matchMedia("(display-mode: standalone)").matches ||
        window.navigator.standalone === true
      );
    }

    function shouldShowPwaOverlay() {
      try {
        if (localStorage.getItem("ridesync_pwa_installed") === "1") {
          return false;
        }
        if (localStorage.getItem("ridesync_pwa_dismissed") === "1") {
          return false;
        }
      } catch (_) {
        // localStorage access failed; fall through to overlay heuristics
      }
      if (isStandalone()) {
        return false;
      }
      return true;
    }

    function hidePwaOverlay(options = {}) {
      if (pwaOverlayTimeoutId) {
        clearTimeout(pwaOverlayTimeoutId);
        pwaOverlayTimeoutId = null;
      }
      const overlay = document.getElementById("pwaInstallOverlay");
      if (!overlay) {
        return;
      }
      overlay.classList.add("hidden");
      overlay.setAttribute("aria-hidden", "true");
      if (options.rememberDismiss) {
        try {
          localStorage.setItem("ridesync_pwa_dismissed", "1");
        } catch (_) {
          // ignore storage errors
        }
      }
    }

    function showPwaOverlayForPlatform() {
      if (!shouldShowPwaOverlay()) {
        return;
      }
      const overlay = document.getElementById("pwaInstallOverlay");
      if (!overlay) {
        return;
      }
      const iosBox = document.getElementById("pwaIosInstructions");
      const androidBox = document.getElementById("pwaAndroidInstructions");
      const message = document.getElementById("pwaInstallMessage");
      const installButton = document.getElementById("pwaInstallButton");

      overlay.classList.remove("hidden");
      overlay.setAttribute("aria-hidden", "false");

      const ua = window.navigator.userAgent || "";
      const isIOS = /iPhone|iPad|iPod/.test(ua) && !window.MSStream;

      if (isIOS) {
        if (iosBox) iosBox.classList.remove("hidden");
        if (androidBox) androidBox.classList.add("hidden");
        if (message) {
          message.textContent =
            "On iPhone, install RideSync on your home screen for faster access.";
        }
        if (installButton) {
          installButton.style.display = "none";
        }
      } else {
        if (androidBox) androidBox.classList.remove("hidden");
        if (iosBox) iosBox.classList.add("hidden");
        if (message) {
          message.textContent =
            "Install RideSync for a faster, full-screen experience.";
        }
        if (installButton) {
          installButton.style.display = "inline-block";
          installButton.disabled = !deferredPwaPrompt;
          installButton.onclick = async () => {
            if (!deferredPwaPrompt) {
              return;
            }
            installButton.disabled = true;
            try {
              deferredPwaPrompt.prompt();
              const choice = await deferredPwaPrompt.userChoice;
              const outcome = choice?.outcome;
              deferredPwaPrompt = null;
              if (outcome === "accepted") {
                try {
                  localStorage.setItem("ridesync_pwa_installed", "1");
                } catch (_) {
                  // ignore storage errors
                }
                hidePwaOverlay();
                return;
              }
              if (outcome === "dismissed") {
                // Remember the dismissal so we do not trap the user on a dead overlay.
                hidePwaOverlay({ rememberDismiss: true });
                return;
              }
            } finally {
              // If the browser refuses to show another prompt, keep the button disabled
              // until a new beforeinstallprompt event fires.
              installButton.disabled = !deferredPwaPrompt;
            }
          };
        }
      }

      if (pwaOverlayTimeoutId) {
        clearTimeout(pwaOverlayTimeoutId);
      }
      pwaOverlayTimeoutId = window.setTimeout(() => {
        if (!isStandalone()) {
          hidePwaOverlay({ rememberDismiss: true });
        }
      }, 15000);
    }

    function initPwaOverlay() {
      const overlay = document.getElementById("pwaInstallOverlay");
      if (!overlay || !shouldShowPwaOverlay()) {
        return;
      }
      const dismissBtn = document.getElementById("pwaInstallDismiss");
      if (dismissBtn) {
        dismissBtn.addEventListener("click", () => {
          hidePwaOverlay({ rememberDismiss: true });
        });
      }
      setTimeout(showPwaOverlayForPlatform, 1500);
    }

    function schedulePwaOverlayInit() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initPwaOverlay, {
          once: true,
        });
        return;
      }
      initPwaOverlay();
    }

    schedulePwaOverlayInit();

    window.addEventListener("beforeunload", () => {
      if (driverAvailabilityUnsub) {
        driverAvailabilityUnsub();
        driverAvailabilityUnsub = null;
      }
    });

      ensureBackgroundMapReady();
      trySetupAutocompleteEarly();
  </script>
</body>
</html>