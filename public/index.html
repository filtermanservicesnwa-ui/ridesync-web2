<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RideSync – NWA & U of A</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#020617" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="/manifest.json" />
  <link rel="icon" type="image/png" sizes="192x192" href="/icons/icon-192.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-180.png" />

  <!-- Stripe placeholder (real payments wired later) -->
  <script src="https://js.stripe.com/v3"></script>

  <!-- QR code library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1d4ed8, #020617 55%);
      color: #f9fafb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 10px;
    }
    @supports (height: 100dvh) {
      body {
        min-height: 100dvh;
      }
    }
    .card {
      background: rgba(2,6,23,0.92);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.45);
      box-shadow: 0 24px 60px rgba(0,0,0,0.6);
      width: 100%;
      max-width: 520px;
      max-height: 96vh;
      padding: 22px 18px 18px;
      overflow-y: auto;
      position: relative;
      z-index: 2;
      backdrop-filter: blur(12px);
    }
    h1, h2 { margin: 0 0 8px; text-align: center; }
    h1 { font-size: 1.6rem; }
    h2 { font-size: 1.1rem; }
    .subtitle {
      margin: 0 0 18px;
      text-align: center;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    label {
      font-size: 0.8rem;
      display: block;
      margin-bottom: 4px;
      color: #e5e7eb;
    }
    input, select {
      width: 100%;
      padding: 9px 11px;
      border-radius: 10px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #f9fafb;
      font-size: 0.9rem;
      margin-bottom: 10px;
    }
    input:focus, select:focus {
      outline: 2px solid #2563eb;
      outline-offset: 1px;
    }
    button {
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      margin-top: 4px;
      transition: background 0.2s ease, color 0.2s ease, opacity 0.2s ease;
    }
    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .btn-primary { background: #22c55e; color: #022c22; }
    .btn-danger { background: #dc2626; color: #fee2e2; }
    .btn-success { background: #16a34a; color: #022c22; }
    .btn-secondary {
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #4b5563;
      margin-top: 8px;
    }
    .btn-small {
      width: auto;
      padding: 6px 10px;
      font-size: 0.8rem;
      border-radius: 999px;
    }
    .rider-action-box {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 14px;
    }
    .rider-action-header {
      font-size: 0.85rem;
      color: #cbd5f5;
      font-weight: 600;
    }
    .rider-action-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .rider-action-buttons button {
      width: auto;
      flex: 1 1 0%;
      margin-top: 0;
    }
    @media (min-width: 520px) {
      .rider-action-buttons {
        flex-direction: row;
      }
    }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .row > div { flex: 1 1 120px; }
    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin: 14px 0 6px;
      border-top: 1px solid rgba(148,163,184,0.4);
      padding-top: 8px;
    }
    .toggle-auth {
      display: flex;
      justify-content: center;
      gap: 6px;
      font-size: 0.8rem;
      margin-bottom: 10px;
      color: #9ca3af;
    }
    .toggle-auth span { text-decoration: underline; cursor: pointer; }

    .error { color: #fecaca; font-size: 0.8rem; min-height: 18px; margin-bottom: 6px; }
    .success { color: #bbf7d0; font-size: 0.8rem; min-height: 18px; margin-bottom: 6px; }
    .small { font-size: 0.75rem; color: #9ca3af; margin-top: 4px; }

    #authView, #rideView, #loadingView { display: none; }
    #authView.active, #rideView.active, #loadingView.active { display: block; }

    #map {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    .fare-box {
      background: rgba(15,23,42,0.9);
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.5);
      padding: 9px 11px;
      font-size: 0.8rem;
      margin-bottom: 10px;
    }
    .trip-builder-card {
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding: 14px;
    }
    .trip-builder-fields {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .trip-field {
      display: flex;
      flex-direction: column;
    }
    .destination-input-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .destination-input-row input {
      flex: 1;
    }
    .add-stop-button {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(34,197,94,0.6);
      background: rgba(34,197,94,0.1);
      color: #bbf7d0;
      font-size: 1.2rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .add-stop-button:focus-visible {
      outline: 2px solid rgba(34,197,94,0.8);
      outline-offset: 2px;
    }
    .add-stop-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .extra-stops {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }
    .extra-stops:empty {
      margin-top: 0;
    }
    .extra-stop-field {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(15,23,42,0.8);
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.35);
      padding: 6px 8px;
    }
    .extra-stop-field input {
      flex: 1;
      background: transparent;
      border: none;
      color: #f8fafc;
    }
    .extra-stop-field input:focus {
      outline: none;
    }
    .remove-stop-btn {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 1px solid rgba(248,113,113,0.4);
      background: rgba(2,6,23,0.85);
      color: #fecaca;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .remove-stop-btn:focus-visible {
      outline: 2px solid rgba(248,113,113,0.5);
      outline-offset: 2px;
    }
    .extra-stop-hint {
      margin-top: 6px;
      color: #94a3b8;
    }
    .trip-map-preview {
      position: relative;
      min-height: 180px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.3);
      background: #020617;
      overflow: hidden;
    }
    .trip-map-canvas {
      position: absolute;
      inset: 0;
    }
    .map-empty-state {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 14px;
      text-align: center;
      font-size: 0.8rem;
      color: #94a3b8;
      background: linear-gradient(135deg, rgba(15,23,42,0.92), rgba(2,6,23,0.92));
      transition: opacity 0.25s ease;
    }
    .trip-map-preview.has-destination .map-empty-state {
      opacity: 0;
      pointer-events: none;
    }
    @media (min-width: 640px) {
      .trip-builder-card {
        flex-direction: row;
        align-items: stretch;
      }
      .trip-builder-fields,
      .trip-map-preview {
        flex: 1 1 0%;
      }
    }
    @media (max-width: 430px) {
      body {
        align-items: stretch;
        justify-content: flex-start;
        gap: 6px;
        padding: calc(var(--safe-top) + 8px) clamp(10px, 4vw, 18px) calc(var(--safe-bottom) + 12px);
      }
      .card {
        width: 100%;
        max-width: none;
        max-height: none;
        min-height: calc(100vh - var(--safe-top) - var(--safe-bottom));
        border-radius: 0;
        padding: 18px clamp(14px, 4.8vw, 26px) calc(24px + var(--safe-bottom));
        box-shadow: 0 18px 50px rgba(0,0,0,0.5);
      }
      @supports (height: 100dvh) {
        .card {
          min-height: calc(100dvh - var(--safe-top) - var(--safe-bottom));
        }
      }
      h1 { font-size: 1.35rem; }
      h2 { font-size: 1rem; }
      .subtitle { font-size: 0.82rem; }
      .section-title { font-size: 0.72rem; letter-spacing: 0.06em; }
      .rider-action-box,
      .rider-info-card,
      .membership-card,
      .trip-builder-card {
        padding: 12px;
      }
      .rider-action-buttons {
        flex-direction: column;
        gap: 6px;
      }
      .trip-map-preview {
        min-height: 150px;
      }
      .rider-info-grid,
      .membership-plan-grid {
        grid-template-columns: 1fr;
      }
      .membership-plan {
        gap: 6px;
      }
    }
    @media (max-width: 360px) {
      body {
        padding-left: clamp(8px, 6vw, 16px);
        padding-right: clamp(8px, 6vw, 16px);
      }
      h1 { font-size: 1.18rem; }
      .rider-info-value { font-size: 0.85rem; }
      button { font-size: 0.85rem; }
    }
    .fare-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
    }
    .fare-label { color: #9ca3af; }
    .fare-value { color: #e5e7eb; }
    .fare-total { color: #bbf7d0; font-weight: 600; }
    .ride-fare-details {
      margin-top: 6px;
      font-size: 0.85rem;
      color: #9ca3af;
      line-height: 1.45;
    }
    .ride-payment-button {
      margin: 16px 0 10px;
    }
    .ride-card-element {
      margin-top: 8px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(15,23,42,0.6);
    }
    #rideCardSubmit {
      width: 100%;
      margin-top: 12px;
    }
    .ride-payment-status {
      font-size: 0.85rem;
      color: #22c55e;
      margin-top: 4px;
    }
    .ride-payment-status.error {
      color: #fecaca;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid #4b5563;
      background: rgba(15,23,42,0.9);
      margin-top: 3px;
    }
    .badge-basic { border-color:#3b82f6; color:#bfdbfe; }
    .badge-uofa { border-color:#22c55e; color:#bbf7d0; }
    .badge-nwa { border-color:#f97316; color:#fed7aa; }
    .badge-tag { font-size: 0.68rem; color:#e5e7eb; opacity:0.8; }

    .rider-header {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .rider-avatar {
      width: 60px;
      height: 60px;
      border-radius: 999px;
      border: 2px solid rgba(148,163,184,0.8);
      object-fit: cover;
      background: #020617;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #9ca3af;
      font-size: 1.1rem;
      overflow: hidden;
    }
    .rider-header-text { flex: 1 1 auto; min-width: 0; }
    .rider-name { font-size: 1rem; font-weight: 600; }
    .rider-contact { font-size: 0.8rem; color: #9ca3af; }

    .rider-info-card {
      background: rgba(15,23,42,0.92);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.5);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 12px;
    }
    .rider-info-main {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .rider-info-text {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1 1 auto;
    }
    .rider-info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
    }
    .rider-info-field {
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(2,6,23,0.85);
      padding: 10px 12px;
    }
    .rider-info-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #94a3b8;
      margin-bottom: 2px;
    }
    .rider-info-value {
      font-size: 0.9rem;
      color: #f9fafb;
      word-break: break-word;
    }
    .rider-info-actions {
      display: flex;
      justify-content: flex-end;
    }

    .membership-card {
      background: rgba(15,23,42,0.92);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.45);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 16px;
    }
    .membership-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .membership-subtitle {
      margin: 2px 0 0;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .membership-status-badge {
      font-size: 0.75rem;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .membership-status-badge.active {
      border-color: #22c55e;
      color: #bbf7d0;
    }
    .membership-status-badge.inactive {
      border-color: #f97316;
      color: #fed7aa;
    }
    .membership-status-badge.pending {
      border-color: #facc15;
      color: #fef3c7;
    }
    .membership-plan-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
    }
    .membership-plan {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(2,6,23,0.85);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 0;
    }
    .membership-plan.active {
      border-color: #22c55e;
      background: rgba(34,197,94,0.08);
    }
    .membership-plan-title {
      font-weight: 600;
    }
    .membership-plan-price {
      font-size: 1rem;
      color: #f9fafb;
    }
    .membership-plan-desc {
      font-size: 0.78rem;
      color: #9ca3af;
      margin: 0;
    }
    .membership-plan button {
      margin-top: auto;
    }
    .membership-plan-card {
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
      text-align: left;
    }
    .membership-plan-card:hover {
      border-color: #22c55e;
      background: rgba(34,197,94,0.12);
    }
    .membership-plan-card:focus-visible {
      outline: 2px solid #22c55e;
      outline-offset: 3px;
    }
    .membership-terms-content {
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(2,6,23,0.9);
      padding: 14px;
      max-height: min(60vh, 420px);
      overflow-y: auto;
      margin: 12px 0;
      scroll-behavior: smooth;
    }
    .membership-terms-footer {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 6px;
    }
    .membership-terms-footer label {
      margin: 0;
    }

    .payment-overlay {
      position: fixed;
      inset: 0;
      background: rgba(2,6,23,0.88);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 80;
    }
    .payment-overlay.active {
      display: flex;
    }
    .payment-panel {
      width: min(480px, 100%);
      background: rgba(15,23,42,0.95);
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.4);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.6);
      max-height: min(90vh, 640px);
      overflow-y: auto;
      overscroll-behavior: contain;
    }
    .payment-panel.compact {
      max-width: 420px;
      text-align: center;
      gap: 12px;
    }
    .payment-redirect-icon {
      font-size: 2rem;
    }
    .payment-redirect-subtitle {
      color: #cbd5f5;
      font-size: 0.95rem;
      margin: 0;
    }
    .payment-redirect-spinner {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 3px solid rgba(148,163,184,0.35);
      border-top-color: #22c55e;
      margin: 12px auto 0;
      animation: paymentRedirectSpin 1s linear infinite;
    }
    @keyframes paymentRedirectSpin {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }
    .payment-status-overlay .payment-result-card {
      width: min(420px, 100%);
      background: rgba(15,23,42,0.95);
      border-radius: 20px;
      border: 1px solid rgba(148,163,184,0.4);
      padding: 24px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.6);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    @supports (height: 100dvh) {
      .payment-panel {
        max-height: min(90dvh, 640px);
      }
    }
    @media (max-width: 520px) {
      .overlay {
        align-items: flex-start;
      }
      .payment-panel {
        width: 100%;
        border-radius: 16px;
      }
    }
    .payment-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
    }
    .payment-panel-title {
      margin: 0;
      font-size: 1.2rem;
    }
    .payment-panel-subtitle {
      margin: 4px 0 0;
      font-size: 0.9rem;
      color: #9ca3af;
    }
    .payment-fare-summary {
      border-top: 1px solid rgba(148,163,184,0.25);
      padding-top: 8px;
      margin-top: -4px;
    }
    .fare-extra-stops {
      margin-top: 6px;
    }

    .top-right {
      position: fixed;
      right: 10px;
      top: 8px;
      font-size: 0.7rem;
      color: #cbd5f5;
      z-index: 3;
    }

    .loading-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 240px;
      text-align: center;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 4px solid rgba(148,163,184,0.4);
      border-top-color: #22c55e;
      animation: spin 1s linear infinite;
      margin-bottom: 14px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(2,6,23,0.9);
      backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: clamp(12px, 4vw, 24px);
      z-index: 50;
      overflow-y: auto;
    }
    .overlay.active { display: flex; }
    .cooldown-panel {
      width: min(420px, 100%);
      background: rgba(15,23,42,0.96);
      border-radius: 20px;
      border: 1px solid rgba(148,163,184,0.45);
      padding: clamp(18px, 4vw, 28px);
      display: flex;
      flex-direction: column;
      gap: 12px;
      text-align: center;
      box-shadow: 0 28px 70px rgba(0,0,0,0.65);
    }
    .cooldown-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #cbd5f5;
    }
    .cooldown-timer {
      font-size: clamp(2.2rem, 9vw, 3rem);
      font-weight: 600;
      letter-spacing: 0.08em;
      color: #bfdbfe;
    }
    .cooldown-hint {
      font-size: 0.9rem;
      color: #94a3b8;
      line-height: 1.4;
    }
    .cooldown-overlay .btn-primary {
      margin-top: 6px;
    }
    .rider-overlay-shell {
      width: min(520px, 100%);
      max-height: 100%;
      overflow-y: auto;
      background: rgba(2,6,23,0.95);
      border: 1px solid rgba(148,163,184,0.45);
      border-radius: 20px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.65);
    }
    .overlay-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 12px;
    }
    .overlay-title { font-size:1.2rem; font-weight:600; }
    .overlay-subtitle { font-size:0.85rem; color:#9ca3af; margin-top:2px; }
    .overlay-close {
      border-radius:999px;
      border:1px solid #4b5563;
      background:#020617;
      color:#e5e7eb;
      padding:6px 12px;
      cursor:pointer;
      font-size:0.82rem;
      flex-shrink: 0;
    }
    .rider-state {
      display: none;
      flex-direction: column;
      gap: 12px;
    }
    .rider-state.active { display: flex; }
    .state-text {
      font-size: 1rem;
      font-weight: 600;
    }
    .state-subtext {
      font-size: 0.9rem;
      color: #9ca3af;
    }
    .waitlist-panel {
      display: none;
      flex-direction: column;
      gap: 10px;
      margin-top: 8px;
      padding: 16px;
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.35);
      background: rgba(15,23,42,0.85);
    }
    .waitlist-panel.active {
      display: flex;
    }
    .waitlist-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      color: #f97316;
    }
    .waitlist-indicator-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #fb923c;
      box-shadow: 0 0 10px rgba(251,146,60,0.8);
      animation: waitlistPulse 1.8s ease-in-out infinite;
    }
    .waitlist-status {
      font-size: 0.9rem;
      color: #cbd5f5;
    }
    .waitlist-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .waitlist-pill {
      font-size: 0.78rem;
      padding: 4px 12px;
      border-radius: 999px;
      border: 1px solid rgba(94,234,212,0.4);
      background: rgba(13,148,136,0.15);
      color: #5eead4;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .waitlist-pill:empty {
      display: none;
    }
    .waitlist-timer-block {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    .waitlist-timer-label {
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #94a3b8;
    }
    .waitlist-timer-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: #fef3c7;
    }
    @keyframes waitlistPulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.4); opacity: 0.6; }
      100% { transform: scale(1); opacity: 1; }
    }
    .pin-card {
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.9);
      padding: 16px;
      text-align: center;
    }
    .pin-label {
      font-size: 0.9rem;
      color: #cbd5f5;
      margin-bottom: 6px;
    }
    .pin-value {
      font-size: 2.5rem;
      letter-spacing: 0.4rem;
      font-weight: 700;
      color: #f9fafb;
    }
    .pin-hint {
      font-size: 0.85rem;
      color: #9ca3af;
      margin-top: 6px;
    }
    .driver-info-slot {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .driver-info-stack {
      display: flex;
      flex-direction: column;
      gap: 14px;
      border: 1px solid rgba(148,163,184,0.5);
      border-radius: 18px;
      padding: 16px;
      background: rgba(2,6,23,0.95);
    }
    .driver-info-stack > :not(:first-child) {
      border-top: 1px solid rgba(148,163,184,0.25);
      padding-top: 14px;
    }
    .driver-identity-card,
    .driver-vehicle-card,
    .driver-license-card {
      border: none;
      border-radius: 0;
      padding: 0;
      background: transparent;
    }
    .support-panel {
      border: none;
      border-radius: 0;
      padding: 0;
      background: transparent;
    }
    .driver-identity-card {
      margin-top: 0;
    }
    .driver-identity-header {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .driver-identity-avatar {
      width: 64px;
      height: 64px;
      border-radius: 18px;
      border: 1px solid rgba(148,163,184,0.7);
      overflow: hidden;
      background: #0f172a;
      position: relative;
      flex-shrink: 0;
    }
    .driver-identity-avatar img,
    .driver-vehicle-photo img,
    .driver-license-photo img,
    .eta-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }
    .avatar-fallback {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #94a3b8;
      font-size: 0.9rem;
    }
    .driver-identity-meta { flex: 1 1 auto; min-width: 0; }
    .driver-identity-name-row {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }
    .driver-identity-name {
      font-size: 1rem;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .driver-rating-pill {
      font-size: 0.76rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(251,191,36,0.6);
      color: #fcd34d;
      background: rgba(120,53,15,0.25);
      display: none;
      white-space: nowrap;
    }
    .driver-identity-status {
      font-size: 0.78rem;
      color: #9ca3af;
      margin-top: 2px;
    }
    .driver-identity-phone {
      font-size: 0.82rem;
      color: #e5e7eb;
      margin-top: 4px;
    }
    .driver-identity-badges {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .driver-badge-pill {
      font-size: 0.7rem;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(94,234,212,0.5);
      color: #99f6e4;
      background: rgba(13,148,136,0.2);
    }
    .driver-vehicle-card,
    .driver-license-card {
      display: none;
    }
    .driver-vehicle-body,
    .driver-license-body {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .driver-vehicle-photo,
    .driver-license-photo {
      width: 96px;
      height: 72px;
      border-radius: 12px;
      border: 1px solid rgba(148,163,184,0.5);
      overflow: hidden;
      background: #0f172a;
      position: relative;
      flex-shrink: 0;
    }
    .driver-vehicle-details,
    .driver-license-details {
      font-size: 0.82rem;
      color: #e5e7eb;
    }
    .driver-vehicle-name {
      font-weight: 600;
      margin-bottom: 2px;
    }
    .driver-license-card .driver-license-summary {
      font-weight: 600;
      margin-bottom: 2px;
    }
    .driver-license-meta {
      font-size: 0.75rem;
      color: #94a3b8;
    }
    .driver-identity-eta {
      font-size: 0.85rem;
      color: #cbd5f5;
      margin-top: 10px;
    }
    .driver-mini-map-shell {
      position: relative;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.35);
      margin-top: 12px;
      overflow: hidden;
      min-height: 180px;
      background: rgba(15,23,42,0.9);
      display: none;
    }
    .driver-mini-map {
      width: 100%;
      height: 200px;
    }
    .driver-mini-map-status {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      color: #cbd5f5;
      background: rgba(2,6,23,0.9);
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
    }
    .driver-mini-map-shell.show-status .driver-mini-map-status {
      opacity: 1;
    }
    .support-panel {
      display: none;
      scroll-margin-top: 16px;
    }
    .support-panel.active {
      display: block;
    }
    .support-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }
    .support-panel-text {
      font-size: 0.82rem;
      color: #cbd5f5;
      margin-bottom: 10px;
    }
    .support-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .support-actions a {
      flex: 1 1 140px;
      text-align: center;
      text-decoration: none;
    }
    textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #4b5563;
      background: #020617;
      color: #f9fafb;
      font-size: 0.9rem;
      resize: vertical;
      min-height: 80px;
    }
    .rating-stars {
      display: flex;
      gap: 6px;
    }
    .rating-stars button {
      flex: 1 1 auto;
      border: 1px solid rgba(248,250,252,0.3);
      background: rgba(15,23,42,0.9);
      color: #fcd34d;
      font-size: 1.2rem;
      border-radius: 10px;
      padding: 8px 0;
      cursor: pointer;
    }
    .rating-stars button.active {
      background: #fcd34d;
      color: #1f2937;
    }
    .tip-options {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .tip-button {
      flex: 1 1 80px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.9);
      color: #e5e7eb;
      padding: 8px 0;
      cursor: pointer;
    }
    .tip-button.active {
      background: #22c55e;
      color: #022c22;
      border-color: #22c55e;
    }
    #tipCustomInput,
    #rideTipCustomInput {
      margin-top: 6px;
      display: none;
    }
    .hidden {
      display: none !important;
    }
    .ride-view-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    .ride-view-tab {
      flex: 1 1 120px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.85);
      color: #e2e8f0;
      padding: 8px 12px;
      font-size: 0.9rem;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s ease;
    }
    .ride-view-tab:hover:not(.active) {
      border-color: rgba(248,250,252,0.6);
      color: #f8fafc;
    }
    .ride-view-tab.active {
      background: #f97316;
      border-color: #f97316;
      color: #0f172a;
      font-weight: 600;
      box-shadow: 0 4px 16px rgba(249,115,22,0.35);
    }
    .ride-view-panel {
      display: none;
    }
    .ride-view-panel.active {
      display: block;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="top-right" id="loginStatus"></div>

  <div class="card">
    <!-- AUTH VIEW -->
    <div id="authView" class="active">
      <h1>RideSync</h1>
      <p class="subtitle">NWA • U of A • Private rides made simple</p>

      <div class="toggle-auth">
        <span id="toggleLink">New here? Create account</span>
      </div>

      <div id="authError" class="error"></div>

      <label for="email">Email</label>
      <input id="email" type="email" placeholder="you@example.com" autocomplete="email" />

      <label for="password">Password</label>
      <input id="password" type="password" placeholder="••••••••" autocomplete="current-password" />

      <!-- SIGNUP FIELDS -->
      <div id="signupFields" style="display:none;">
        <div class="section-title">Rider info</div>
        <label for="fullName">Full name</label>
        <input id="fullName" type="text" placeholder="Your legal name" />

        <div class="row">
          <div>
            <label for="gender">Gender</label>
            <select id="gender">
              <option value="">Select…</option>
              <option value="male">Male</option>
              <option value="female">Female</option>
              <option value="other">Other / Prefer not</option>
            </select>
          </div>
          <div>
            <label for="phoneNumber">Phone</label>
            <input id="phoneNumber" type="tel" placeholder="555-123-4567" />
          </div>
        </div>

        <div class="section-title">Address</div>
        <label for="streetAddress">Street</label>
        <input id="streetAddress" type="text" placeholder="123 Main St" />

        <div class="row">
          <div>
            <label for="city">City</label>
            <input id="city" type="text" placeholder="Fayetteville" />
          </div>
          <div>
            <label for="state">State</label>
            <input id="state" type="text" placeholder="AR" />
          </div>
          <div>
            <label for="zip">ZIP</label>
            <input id="zip" type="text" placeholder="72701" />
          </div>
        </div>

        <div class="section-title">Student & membership</div>
        <div class="row">
          <div>
            <label for="isStudent">U of A student?</label>
            <select id="isStudent">
              <option value="false">No</option>
              <option value="true">Yes</option>
            </select>
          </div>
          <div>
            <label for="membership">Membership</label>
            <select id="membership">
              <option value="basic">Basic (pay per ride)</option>
              <option value="uofa_unlimited">U of A Unlimited ($80/mo)</option>
              <option value="nwa_unlimited">NWA Unlimited ($120/mo)</option>
            </select>
          </div>
        </div>

        <div class="section-title">Photos (never public)</div>
        <label>Profile picture</label>
        <input id="profilePicInput" type="file" accept="image/*" />
        <label>Driver license</label>
        <input id="licensePicInput" type="file" accept="image/*" />
        <label>Student ID</label>
        <input id="studentIdPicInput" type="file" accept="image/*" />
      </div>

      <button id="authButton" class="btn-primary">Log in</button>
      <p class="small">When creating an account, all info on this screen saves at once.</p>
    </div>

    <!-- RIDE VIEW -->
    <div id="rideView">
      <div class="ride-view-tabs" role="tablist" aria-label="Rider sections">
        <button
          type="button"
          id="rideViewTabDestination"
          class="ride-view-tab active"
          data-view-tab="destination"
          aria-controls="rideViewPanelDestination"
          aria-selected="true"
          tabindex="0"
        >
          Destination
        </button>
        <button
          type="button"
          id="rideViewTabMembership"
          class="ride-view-tab"
          data-view-tab="membership"
          aria-controls="rideViewPanelMembership"
          aria-selected="false"
          tabindex="-1"
        >
          Membership
        </button>
        <button
          type="button"
          id="rideViewTabInfo"
          class="ride-view-tab"
          data-view-tab="info"
          aria-controls="rideViewPanelInfo"
          aria-selected="false"
          tabindex="-1"
        >
          Rider info
        </button>
      </div>

      <div id="profileMessage" class="success"></div>
      <div id="profileError" class="error"></div>

      <div
        class="ride-view-panel active"
        id="rideViewPanelDestination"
        data-view-panel="destination"
        role="tabpanel"
        aria-labelledby="rideViewTabDestination"
        aria-hidden="false"
      >
      <!-- Join banner for QR joiners -->
      <div id="joinBanner" class="fare-box" style="display:none;">
        <div class="small" id="joinBannerText"></div>
      </div>

      <div class="section-title">Trip setup</div>
      <div class="small" style="margin: -4px 0 12px; color: #94a3b8;">
        Check out our memberships to save on frequent rides.
      </div>
      <div class="fare-box trip-builder-card">
        <div class="trip-builder-fields">
          <div class="trip-field">
            <label for="destination">Where are you going?</label>
            <div class="destination-input-row">
              <input id="destination" type="text" placeholder="Enter destination address" />
              <button
                id="addStopButton"
                type="button"
                class="add-stop-button"
                aria-label="Add an extra stop"
                title="Add an extra stop"
              >
                +
              </button>
            </div>
            <div class="small extra-stop-hint">
              Need multiple stops? Tap + to add them before syncing your destination.
            </div>
            <div id="extraStopsContainer" class="extra-stops"></div>
          </div>
          <div id="ridersSection" class="trip-field">
            <label for="numRiders">Number of riders</label>
            <select id="numRiders">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
            <div class="small">
              For U of A pooling, choose 1 rider. For private group rides with friends, choose 2–4 and use the QR.
            </div>
          </div>
        </div>
        <div id="tripMapPreview" class="trip-map-preview" aria-hidden="true">
          <div id="destinationPreviewMap" class="trip-map-canvas"></div>
          <div id="destinationPreviewEmpty" class="map-empty-state">
            Add a destination to preview your pickup &amp; dropoff pins.
          </div>
        </div>
      </div>

      <div class="section-title" id="poolGroupTitle" style="display:none;">
        U of A pool group
      </div>
      <div id="poolGroupBox" class="fare-box" style="display:none;">
        <div class="small" id="poolGroupStatus">
          Searching for other U of A riders…
        </div>
        <div id="poolGroupList"></div>
      </div>

      <div class="fare-box rider-action-box">
        <div class="rider-action-header">Account &amp; ride actions</div>
        <div class="rider-action-buttons">
          <button id="syncButton" class="btn-primary">Sync destination</button>
          <button id="logoutButton" class="btn-secondary">Log out</button>
        </div>
        <div id="driverAvailabilityNotice" class="small"></div>
      </div>
      </div>

      <div
        class="ride-view-panel"
        id="rideViewPanelMembership"
        data-view-panel="membership"
        role="tabpanel"
        aria-labelledby="rideViewTabMembership"
        aria-hidden="true"
      >
        <div id="membershipCard" class="membership-card">
          <div class="membership-card-header">
            <div>
              <div
                class="section-title"
                style="margin-top:0;border-top:none;padding-top:0;"
              >
                Membership
              </div>
              <p id="membershipStatusText" class="membership-subtitle">
                Loading membership…
              </p>
            </div>
            <span id="membershipStatusBadge" class="membership-status-badge">—</span>
          </div>
          <!-- === RIDE SYNC STRIPE: START membership summary === -->
          <div class="membership-card-summary">
            <p id="membershipCurrentLabel" class="membership-subtitle">
              Checking membership...
            </p>
            <div class="rider-info-actions" style="margin-top:8px;">
              <button
                id="membershipChangeButton"
                type="button"
                class="btn-secondary btn-small"
              >
                Change membership
              </button>
            </div>
          </div>
          <!-- === RIDE SYNC STRIPE: END membership summary === -->
          <div class="membership-plan-grid" style="display:none;">
            <div class="membership-plan" data-plan="uofa_unlimited">
              <div class="membership-plan-title">U of A Unlimited</div>
              <div
                class="membership-plan-price"
                data-plan-price="uofa_unlimited"
              >
                $80 / month
              </div>
              <p class="membership-plan-desc">
                Unlimited Fayetteville rides. Out-of-zone trips bill per minute.
              </p>
              <button
                class="btn-primary btn-small"
                type="button"
                data-plan-action="uofa_unlimited"
              >
                Upgrade to U of A Unlimited
              </button>
            </div>
            <div class="membership-plan" data-plan="nwa_unlimited">
              <div class="membership-plan-title">NWA Unlimited</div>
              <div
                class="membership-plan-price"
                data-plan-price="nwa_unlimited"
              >
                $120 / month
              </div>
              <p class="membership-plan-desc">
                Unlimited rides inside the 30-mile NWA radius.
              </p>
              <button
                class="btn-primary btn-small"
                type="button"
                data-plan-action="nwa_unlimited"
              >
                Upgrade to NWA Unlimited
              </button>
            </div>
          </div>
          <div id="membershipCardMessage" class="small"></div>
        </div>
      </div>

      <div
        class="ride-view-panel"
        id="rideViewPanelInfo"
        data-view-panel="info"
        role="tabpanel"
        aria-labelledby="rideViewTabInfo"
        aria-hidden="true"
      >
      <div id="riderInfoCard" class="rider-info-card">
        <div class="rider-info-main">
          <div id="avatar" class="rider-avatar">RS</div>
          <div class="rider-info-text">
            <div class="rider-name" id="riderName">Rider</div>
            <div id="membershipBadge" class="badge badge-basic">
              <span id="membershipBadgeLabel">Basic</span>
              <span class="badge-tag" id="membershipBadgeTag"></span>
            </div>
          </div>
        </div>

        <div class="rider-info-grid">
          <div class="rider-info-field">
            <div class="rider-info-label">Email</div>
            <div class="rider-info-value" id="riderEmailDetail">you@example.com</div>
          </div>
          <div class="rider-info-field">
            <div class="rider-info-label">Phone</div>
            <div class="rider-info-value" id="riderPhoneDetail"></div>
          </div>
          <div class="rider-info-field">
            <div class="rider-info-label">Address</div>
            <div class="rider-info-value" id="riderAddressDetail"></div>
          </div>
          <div class="rider-info-field">
            <div class="rider-info-label">Membership</div>
            <div class="rider-info-value" id="riderMembershipDetail"></div>
          </div>
        </div>

        <div class="rider-info-actions">
          <button
            id="editProfileButton"
            type="button"
            class="btn-secondary btn-small"
          >
            Edit profile
          </button>
        </div>
      </div>

      <!-- Inline edit form -->
      <div id="editProfileSection"
           class="fare-box"
           style="display:none; margin-top:6px;">
        <div class="row">
          <div>
            <label for="editFullName">Name</label>
            <input id="editFullName" type="text" />
          </div>
          <div>
            <label for="editPhone">Phone</label>
            <input id="editPhone" type="tel" />
          </div>
          <div>
            <label for="editGender">Gender</label>
            <select id="editGender">
              <option value="">Select…</option>
              <option value="male">Male</option>
              <option value="female">Female</option>
              <option value="other">Other / Prefer not</option>
            </select>
          </div>
        </div>

        <label for="editStreet">Street</label>
        <input id="editStreet" type="text" />

        <div class="row">
          <div>
            <label for="editCity">City</label>
            <input id="editCity" type="text" />
          </div>
          <div>
            <label for="editState">State</label>
            <input id="editState" type="text" />
          </div>
          <div>
            <label for="editZip">ZIP</label>
            <input id="editZip" type="text" />
          </div>
        </div>

        <div class="section-title">Photos</div>
        <label>Profile picture</label>
        <input id="editProfilePicInput" type="file" accept="image/*" />
        <label>Driver license</label>
        <input id="editLicensePicInput" type="file" accept="image/*" />
        <label>Student ID</label>
        <input id="editStudentIdPicInput" type="file" accept="image/*" />

        <button id="saveProfileButton" type="button"
                class="btn-primary btn-small"
                style="margin-top:8px;">
          Save changes
        </button>
      </div>

      </div>
    </div>

    <!-- LOADING VIEW -->
      <div id="loadingView">
        <h2>RideSync</h2>
        <div class="loading-center">
          <div class="loading-spinner"></div>
          <div>Syncing your ride…</div>
          <div class="small">Pre-authorizing payment and matching your driver.</div>
        </div>
      </div>

      <!-- RIDE SUMMARY (after ride completes) -->
      <div id="rideSummary" style="display:none; color:#e5e7eb; padding:16px 4px; text-align:center;">
        <h2 style="margin-bottom:8px;">Ride complete</h2>
        <div id="rideSummaryText" style="font-size:0.85rem; line-height:1.4;"></div>
      </div>

      <!-- RIDER ACTIVE RIDE OVERLAY -->
      <div id="riderOverlay" class="overlay">
        <div class="rider-overlay-shell">
          <div class="overlay-header">
            <div>
              <div id="riderOverlayTitle" class="overlay-title">RideSync</div>
              <div id="riderOverlaySubtitle" class="overlay-subtitle"></div>
            </div>
          </div>

          <div id="riderStateSearching" class="rider-state">
            <div class="loading-spinner"></div>
            <div class="state-text">Looking for a driver…</div>
            <div class="state-subtext">We’re syncing you with a nearby verified driver.</div>
            <div
              id="riderWaitlistPanel"
              class="waitlist-panel"
              aria-live="polite"
              aria-hidden="true"
            >
              <div class="waitlist-title">
                <span class="waitlist-indicator-dot" aria-hidden="true"></span>
                Holding your place in line
              </div>
              <div id="riderWaitlistStatus" class="waitlist-status">
                All drivers are currently finishing trips nearby.
              </div>
              <div class="waitlist-meta">
                <div id="riderWaitlistBadge" class="waitlist-pill"></div>
                <div class="waitlist-timer-block">
                  <div class="waitlist-timer-label">Time waiting</div>
                  <div id="riderWaitlistTimer" class="waitlist-timer-value">00:00</div>
                </div>
              </div>
            </div>
          </div>

          <div id="riderStateDriverEta" class="rider-state">
            <div class="state-text">Driver accepted</div>
            <div class="state-subtext">Track their ETA and vehicle details below.</div>
            <div class="driver-info-slot" data-slot="driver"></div>
          </div>

          <div id="riderStatePickupPin" class="rider-state">
            <div class="state-text">Share your pickup code</div>
            <div class="pin-card">
              <div class="pin-label">Tell your driver this code when they arrive</div>
              <div id="riderPickupPinValue" class="pin-value">----</div>
              <div class="pin-hint">We use codes so only verified rides start.</div>
            </div>
          </div>

          <div id="riderStateInTrip" class="rider-state">
            <div class="state-text">On the way</div>
            <div id="riderTripEtaText" class="state-subtext"></div>
            <div class="driver-info-slot" data-slot="driver"></div>
          </div>

          <div id="riderStateDropoffPin" class="rider-state">
            <div class="state-text">Almost there</div>
            <div class="pin-card">
              <div class="pin-label">Share this code at dropoff</div>
              <div id="riderDropoffPinValue" class="pin-value">----</div>
              <div class="pin-hint">Your driver enters this to finish the ride.</div>
            </div>
          </div>

          <div id="riderStateRateTip" class="rider-state">
            <div class="state-text">Rate your ride</div>
            <div id="ratingStars" class="rating-stars">
              <button type="button" data-rating="1">★</button>
              <button type="button" data-rating="2">★</button>
              <button type="button" data-rating="3">★</button>
              <button type="button" data-rating="4">★</button>
              <button type="button" data-rating="5">★</button>
            </div>
            <textarea id="riderFeedbackInput" placeholder="Anything we should know?"></textarea>
            <button id="submitRatingButton" class="btn-primary" type="button">Submit</button>
            <div id="ratingError" class="error"></div>
          </div>

          <div id="riderStateThanks" class="rider-state">
            <div class="state-text">Thank you for riding with RideSync!</div>
            <div class="state-subtext">You’re all set. Request another ride anytime.</div>
          </div>

          <div id="driverInfoStack" class="driver-info-stack">
            <div id="driverIdentityCard" class="driver-identity-card">
              <div class="driver-identity-header">
                <div class="driver-identity-avatar">
                  <img id="driverIdentityAvatarImg" alt="Driver avatar" />
                  <div id="driverIdentityAvatarFallback" class="avatar-fallback">RS</div>
                </div>
                <div class="driver-identity-meta">
                  <div class="driver-identity-name-row">
                    <div id="driverIdentityName" class="driver-identity-name">RideSync driver</div>
                    <div id="driverIdentityRating" class="driver-rating-pill"></div>
                  </div>
                  <div id="driverIdentityStatus" class="driver-identity-status"></div>
                  <div id="driverIdentityPhoneRow" class="driver-identity-phone">
                    <span id="driverIdentityPhone"></span>
                  </div>
                </div>
              </div>
              <div id="driverIdentityBadges" class="driver-identity-badges"></div>
              <div id="driverIdentityEta" class="driver-identity-eta"></div>
              <div id="driverMiniMapShell" class="driver-mini-map-shell">
                <div id="driverMiniMap" class="driver-mini-map"></div>
                <div id="driverMiniMapStatus" class="driver-mini-map-status">
                  Waiting for driver location…
                </div>
              </div>
            </div>

            <div id="driverVehicleSection" class="driver-vehicle-card">
              <div class="section-title" style="margin-top:0;">Vehicle</div>
              <div class="driver-vehicle-body">
                <div class="driver-vehicle-photo">
                  <img id="driverVehiclePhoto" alt="Driver vehicle" />
                  <div id="driverVehicleFallback" class="avatar-fallback">RS</div>
                </div>
                <div class="driver-vehicle-details">
                  <div id="driverVehicleName" class="driver-vehicle-name"></div>
                  <div id="driverVehiclePlate"></div>
                  <div id="driverVehicleNote" class="driver-license-meta"></div>
                </div>
              </div>
            </div>

            <div id="driverLicenseSection" class="driver-license-card">
              <div class="section-title" style="margin-top:0;">License &amp; verification</div>
              <div class="driver-license-body">
                <div class="driver-license-photo">
                  <img id="driverLicensePhoto" alt="Driver license" />
                  <div id="driverLicenseFallback" class="avatar-fallback">ID</div>
                </div>
                <div class="driver-license-details">
                  <div id="driverLicenseSummary" class="driver-license-summary"></div>
                  <div id="driverLicenseMeta" class="driver-license-meta"></div>
                </div>
              </div>
            </div>

            <button id="contactDriverBtn" type="button" class="btn-secondary" style="margin-top:8px;">
              Support
            </button>

            <div id="supportPanel" class="support-panel">
              <div class="support-panel-header">
                <div style="font-weight:600;">RideSync support</div>
                <button id="supportBackButton" type="button" class="btn-small btn-secondary">Back</button>
              </div>
              <div class="support-panel-text">
                Choose how you'd like to contact RideSync support.
              </div>
              <div class="support-actions">
                <a id="supportCallButton" class="btn-primary" href="#" role="button">Call support</a>
                <a id="supportTextButton" class="btn-secondary" href="#" role="button">Text support</a>
              </div>
            </div>
          </div>

          <div id="riderOverlayError" class="error"></div>
        </div>
      </div>

        <!-- QR section for private group rides -->
        <div id="groupQrSection" style="display:none; margin-top:14px;">
          <div class="small">
            Riding with friends? Ask each of them to scan this QR and sign in to join this ride.
          </div>
          <canvas id="groupQrCanvas"
                  width="140"
                  height="140"
                  style="margin-top:8px;"></canvas>
          <div id="groupOccupancyLabel" class="small" style="margin-top:6px;"></div>
        </div>

        <button id="cancelRideButton" class="btn-secondary" style="margin-top:16px;" hidden>
          Cancel ride
        </button>
        <div id="cancelError" class="error"></div>
      </div>
    </div>
  </div>

  <div id="paymentOverlay" class="payment-overlay" aria-hidden="true">
    <div class="payment-panel">
      <div class="payment-panel-header">
        <div>
          <h3 id="paymentOverlayTitle" class="payment-panel-title">
            Complete payment
          </h3>
          <p id="paymentOverlaySubtitle" class="payment-panel-subtitle"></p>
        </div>
        <button
          id="paymentOverlayClose"
          type="button"
          class="btn-secondary btn-small"
        >
          Cancel
        </button>
      </div>
      <div id="paymentFareSummary" class="payment-fare-summary" aria-live="polite">
        <div class="section-title" style="margin-bottom:4px;">Fare summary</div>
        <div class="fare-box" style="margin-bottom:0;">
          <div id="fareNotReady" class="small">
            Choose your destination first to calculate time, distance, and total.
          </div>
          <div id="fareReady" style="display:none;">
            <div class="fare-row">
              <div class="fare-label">Time</div>
              <div class="fare-value" id="fareTime"></div>
            </div>
            <div class="fare-row">
              <div class="fare-label">Distance</div>
              <div class="fare-value" id="fareDistance"></div>
            </div>
            <div class="fare-row">
              <div class="fare-label">Plan</div>
              <div class="fare-value" id="fareMembership"></div>
            </div>
            <div class="fare-row">
              <div class="fare-label">Total (incl. fees)</div>
              <div class="fare-total" id="fareTotal"></div>
            </div>
            <div id="fareExtraStops" class="fare-extra-stops"></div>
          </div>
        </div>
      </div>
      <div id="paymentElement"></div>
      <button
        id="paymentOverlayConfirm"
        type="button"
        class="btn-primary"
      >
        Pay now
      </button>
      <div id="paymentOverlayMessage" class="error"></div>
    </div>
  </div>

  <div id="paymentRedirectOverlay" class="payment-overlay" aria-hidden="true">
    <div class="payment-panel compact" role="dialog" aria-live="assertive">
      <div class="payment-redirect-icon" aria-hidden="true">🔒</div>
      <h3 class="payment-panel-title">Secure payment</h3>
      <p id="paymentRedirectSubtitle" class="payment-redirect-subtitle">
        Redirecting you to Stripe Checkout…
      </p>
      <div class="payment-redirect-spinner" aria-hidden="true"></div>
    </div>
  </div>

  <div
    id="paymentStatusOverlay"
    class="overlay payment-status-overlay"
    aria-hidden="true"
  >
    <div
      class="payment-result-card"
      role="dialog"
      aria-modal="true"
      aria-live="polite"
    >
      <div id="paymentStatusTitle" class="overlay-title"></div>
      <div id="paymentStatusMessage" class="overlay-subtitle"></div>
      <button id="paymentStatusBackButton" type="button" class="btn-primary">
        Back to RideSync
      </button>
    </div>
  </div>

  <div
    id="rideFareOverlay"
    class="payment-overlay"
    aria-hidden="true"
    inert
  >
    <div class="payment-panel" role="dialog" aria-modal="true">
      <div class="payment-panel-header">
        <div>
          <h3 class="payment-panel-title">Ride payment required</h3>
          <p id="rideFareSubtitle" class="payment-panel-subtitle">
            Complete your fare to finish this ride.
          </p>
        </div>
        <button
          id="rideFareClose"
          type="button"
          class="btn-secondary btn-small"
          data-default-focus="true"
          disabled
        >
          Close
        </button>
      </div>
      <div class="fare-box" style="margin-bottom:0;">
        <div class="fare-row">
          <div class="fare-label">Base fare</div>
          <div class="fare-value" id="rideFareBaseAmount">$0.00</div>
        </div>
        <div class="fare-row">
          <div class="fare-label">Tip</div>
          <div class="fare-value" id="rideFareTipAmount">$0.00</div>
        </div>
        <div class="fare-row">
          <div class="fare-label">Total due</div>
          <div class="fare-total" id="rideFareAmount">$0.00</div>
        </div>
        <div id="rideFareDetails" class="ride-fare-details"></div>
      </div>
      <div class="section-title" style="margin-top:16px;">Add a tip (optional)</div>
      <div id="rideTipOptions" class="tip-options">
        <button type="button" class="tip-button active" data-tip="0">$0</button>
        <button type="button" class="tip-button" data-tip="2">$2</button>
        <button type="button" class="tip-button" data-tip="5">$5</button>
        <button type="button" class="tip-button" data-tip="10">$10</button>
        <button type="button" class="tip-button tip-custom" data-tip="custom">Custom</button>
      </div>
      <input
        id="rideTipCustomInput"
        type="number"
        min="0"
        step="1"
        placeholder="Custom tip"
        style="display:none;"
      />
      <div class="section-title" style="margin-top:18px;">Pay with Apple Pay or Google Pay</div>
      <div id="rideFarePaymentRequest" class="ride-payment-button"></div>
      <p id="rideFareUnavailable" class="small"></p>
      <div class="section-title" style="margin-top:18px;">Pay with card</div>
      <div id="rideCardElement" class="ride-card-element"></div>
      <button
        id="rideCardSubmit"
        type="button"
        class="btn-primary"
        disabled
      >
        Pay with card
      </button>
      <div id="rideCardMessage" class="error"></div>
      <div id="rideFareStatus" class="ride-payment-status"></div>
    </div>
  </div>

  <div
    id="cooldownOverlay"
    class="overlay cooldown-overlay"
    aria-hidden="true"
  >
    <div
      class="cooldown-panel"
      role="dialog"
      aria-modal="true"
      aria-labelledby="cooldownTitle"
      aria-describedby="cooldownHintText"
    >
      <div id="cooldownLabel" class="cooldown-label">Unlimited cooldown</div>
      <div id="cooldownTitle" class="overlay-title">Next ride unlocks soon</div>
      <div id="cooldownSubtitle" class="overlay-subtitle">
        Hang tight while we reset drivers nearby.
      </div>
      <div id="cooldownTimerValue" class="cooldown-timer">00:00</div>
      <div id="cooldownHintText" class="cooldown-hint">
        Unlimited riders take a short break between trips to keep rides fair.
      </div>
      <button id="cooldownDismissButton" type="button" class="btn-primary">
        Okay, got it
      </button>
    </div>
  </div>

  <!-- === RIDE SYNC STRIPE: START membership selection overlay === -->
  <div
    id="membershipSelectionOverlay"
    class="overlay"
    aria-hidden="true"
    inert
  >
    <div class="payment-panel">
      <div class="payment-panel-header">
        <h3>Select membership</h3>
        <button
          id="membershipSelectionClose"
          type="button"
          class="btn-secondary btn-small"
          data-default-focus="true"
        >
          Close
        </button>
      </div>
      <p class="membership-subtitle">
        Choose the unlimited plan that matches your coverage zone.
      </p>
      <div class="membership-plan-grid" style="margin-top:12px;">
        <button
          class="membership-plan membership-plan-card"
          type="button"
          data-membership-option="nwa_unlimited"
        >
          <div class="membership-plan-title">NWA Unlimited</div>
          <div class="membership-plan-price" data-plan-price="nwa_unlimited">
            $120 / month
          </div>
          <p class="membership-plan-desc">
            Unlimited rides inside the 30-mile NWA service radius.
          </p>
        </button>
        <button
          class="membership-plan membership-plan-card"
          type="button"
          data-membership-option="uofa_unlimited"
        >
          <div class="membership-plan-title">U of A Unlimited</div>
          <div class="membership-plan-price" data-plan-price="uofa_unlimited">
            $80 / month
          </div>
          <p class="membership-plan-desc">
            Unlimited Fayetteville rides with out-of-zone surcharges.
          </p>
        </button>
      </div>
      <div id="membershipSelectionError" class="error"></div>
      <button
        id="membershipTermsButton"
        type="button"
        class="btn-danger"
        style="margin-top:18px;"
        disabled
      >
        Terms of Agreement
      </button>
      <div id="membershipTermsError" class="error"></div>
    </div>
  </div>
  <!-- === RIDE SYNC STRIPE: END membership selection overlay === -->

  <!-- === RIDE SYNC STRIPE: START membership terms overlay === -->
  <div id="membershipTermsOverlay" class="overlay" aria-hidden="true" inert>
    <div class="payment-panel">
      <div class="payment-panel-header">
        <h3>Membership terms</h3>
        <button
          id="membershipTermsClose"
          type="button"
          class="btn-secondary btn-small"
          data-default-focus="true"
        >
          Close
        </button>
      </div>
      <div
        id="membershipTermsContent"
        class="membership-terms-content"
        tabindex="0"
        aria-label="Membership terms"
      >
        <h4 style="margin-top:0;">Unlimited Membership Terms</h4>
        <p>
          Unlimited plans provide predictable monthly billing and zone-based
          ride coverage. Please review these terms in full before accepting.
        </p>
        <p>
          Charges begin immediately when you activate a membership. Each
          billing cycle renews on the same date monthly. Memberships can be
          canceled at any time from the app; cancellation stops future billing
          but does not refund the current cycle.
        </p>
        <p>
          Unlimited coverage applies to the service zone for the plan you
          select. Trips outside that zone incur the published per-minute
          overage rate. Abuse, sharing rides with non-members, or fraudulent
          disputes may lead to membership suspension.
        </p>
        <p>
          By accepting you authorize Stripe to process the payment method
          supplied. Data is handled under our Privacy Policy. Contact support
          if you need accommodation before activation.
        </p>
        <p>
          Scroll to the bottom of this panel to enable the acceptance checkbox.
        </p>
      </div>
      <div class="membership-terms-footer">
        <label style="display:flex;align-items:center;gap:8px;">
          <input id="membershipTermsCheckbox" type="checkbox" disabled />
          <span>I have read and agree to the Membership Terms.</span>
        </label>
        <p class="membership-subtitle" style="margin:0;">
          The checkbox unlocks after you view the entire agreement.
        </p>
      </div>
    </div>
  </div>
  <!-- === RIDE SYNC STRIPE: END membership terms overlay === -->

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
    import {
      getAuth,
      onAuthStateChanged,
      signInWithEmailAndPassword,
      createUserWithEmailAndPassword,
      signOut
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";
    import {
      getFirestore,
      doc,
      getDoc,
      collection,
      onSnapshot,
      query,
      where,
      getDocs,
      orderBy,
      limit
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";
    import {
      getStorage,
      ref,
      uploadBytes,
      getDownloadURL
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-storage.js";
    import {
      getFunctions,
      httpsCallable
    } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-functions.js";

    async function loadAppConfig() {
      if (window.__rideSyncConfigPromise) {
        return window.__rideSyncConfigPromise;
      }

      window.__rideSyncConfigPromise = fetch("/app-config.json", {
        cache: "no-store"
      })
        .then((res) => {
          if (!res.ok) {
            throw new Error(`Failed to load app config: ${res.status}`);
          }
          return res.json();
        })
        .catch((err) => {
          console.error("App config load failed", err);
          throw err;
        });

      return window.__rideSyncConfigPromise;
    }

    function loadGoogleMapsSdk({ apiKey, libraries = [] } = {}) {
      if (window.__rideSyncMapsPromise) {
        return window.__rideSyncMapsPromise;
      }

      window.__rideSyncMapsPromise = new Promise((resolve, reject) => {
        if (window.google && window.google.maps) {
          resolve(window.google.maps);
          return;
        }

        if (!apiKey) {
          reject(new Error("Missing Google Maps API key"));
          return;
        }

        const params = new URLSearchParams({ key: apiKey });
        if (libraries.length) {
          params.set("libraries", libraries.join(","));
        }

        const script = document.createElement("script");
        script.src = `https://maps.googleapis.com/maps/api/js?${params.toString()}`;
        script.async = true;
        script.defer = true;
        script.onload = () => {
          if (window.google && window.google.maps) {
            resolve(window.google.maps);
          } else {
            reject(new Error("Google Maps SDK loaded without maps namespace."));
          }
        };
        script.onerror = () => reject(new Error("Google Maps SDK failed to load."));
        document.head.appendChild(script);
      }).catch((err) => {
        window.__rideSyncMapsPromise = null;
        throw err;
      });

      return window.__rideSyncMapsPromise;
    }

    function loadStripeJs() {
      if (!STRIPE_ENABLED) {
        return Promise.reject(
          new Error("Stripe payments are not available right now.")
        );
      }
      if (window.Stripe) {
        return Promise.resolve(window.Stripe);
      }
      if (!stripeJsPromise) {
        stripeJsPromise = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = STRIPE_JS_URL;
          script.async = true;
          script.onload = () => {
            if (window.Stripe) {
              resolve(window.Stripe);
            } else {
              reject(
                new Error("Stripe.js loaded but Stripe was unavailable.")
              );
            }
          };
          script.onerror = () =>
            reject(new Error("Stripe.js failed to load."));
          document.head.appendChild(script);
        }).catch((err) => {
          stripeJsPromise = null;
          throw err;
        });
      }
      return stripeJsPromise;
    }

    const APP_CONFIG = await loadAppConfig();
    const firebaseConfig = APP_CONFIG.firebaseConfig || {};
    const supportConfig = APP_CONFIG.support || {};
    const geoConfig = APP_CONFIG.geo || {};
    const ridePolicyConfig = APP_CONFIG.ridePolicy || {};
    const placeholderConfig = APP_CONFIG.placeholders || {};
    const functionsConfig = APP_CONFIG.functions || {};
    const mapsConfig = APP_CONFIG.maps || APP_CONFIG.googleMaps || {};
    const DEFAULT_MAPS_API_KEY = "AIzaSyDlYSl5rfovahECuBSbkELw2uyC6-Ucmr0";
    const mapsApiKey = mapsConfig.apiKey || DEFAULT_MAPS_API_KEY;
    const mapsLibraries =
      Array.isArray(mapsConfig.libraries) && mapsConfig.libraries.length
        ? mapsConfig.libraries
        : ["places"];
    let googleMapsLoadFailed = false;

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);
    const FUNCTIONS_REGION = "us-central1";
    const functionsClient = getFunctions(app, FUNCTIONS_REGION);

    const stripeConfig = APP_CONFIG.stripe || {};
    const fareConfig = APP_CONFIG.fares || {};
    // --- FIXED STRIPE CONFIG BLOCK ---
    // Cursor broke Stripe flow because publishableKey was empty.
    // This safely restores Stripe without affecting the rest of the file.
    const STRIPE_PUBLISHABLE_KEY_FALLBACK =
      "pk_live_51SKjO4CbEdF7xUZ5y1Uceore88zrCE8Q9ASNO6bVxGVkj9YGPazDPvx9VZwjfriUnzslstmBVa5WEzukGjMkgVz000w5bDBHhi"; // <-- insert your actual publishable key

    function normalizeStripeKeyForMode(key, mode) {
      const trimmed = typeof key === "string" ? key.trim() : "";
      if (!trimmed) {
        return "";
      }
      if (mode === "live" && trimmed.startsWith("pk_live_")) {
        return trimmed;
      }
      if (mode === "test" && trimmed.startsWith("pk_test_")) {
        return trimmed;
      }
      return "";
    }

    function selectStripeKeyForMode(mode) {
      const candidates =
        mode === "live"
          ? [
              stripeConfig.publishableKeyLive,
              stripeConfig.livePublishableKey,
              stripeConfig.publishableKey,
              STRIPE_PUBLISHABLE_KEY_FALLBACK,
            ]
          : [
              stripeConfig.publishableKeyTest,
              stripeConfig.testPublishableKey,
              stripeConfig.publishableKeySandbox,
              stripeConfig.publishableKey,
            ];
      for (const candidate of candidates) {
        const normalized = normalizeStripeKeyForMode(candidate, mode);
        if (normalized) {
          return normalized;
        }
      }
      return "";
    }

    const STRIPE_KEYS_BY_MODE = {
      live: selectStripeKeyForMode("live"),
      test: selectStripeKeyForMode("test"),
    };

    const isLocalDevHost =
      typeof window !== "undefined" &&
      ["localhost", "127.0.0.1", "0.0.0.0"].includes(window.location.hostname);
    if (isLocalDevHost && !STRIPE_KEYS_BY_MODE.live) {
      console.warn(
        "[RideSync][Stripe] Missing live publishable key. Update stripe.publishableKey or stripe.publishableKeyLive in app-config.json."
      );
    }
    if (isLocalDevHost && !STRIPE_KEYS_BY_MODE.test) {
      console.warn(
        "[RideSync][Stripe] Missing test publishable key. Update stripe.publishableKeyTest or stripe.testPublishableKey in app-config.json."
      );
    }

    const STRIPE_DEFAULT_PUBLISHABLE_KEY =
      STRIPE_KEYS_BY_MODE.live ||
      STRIPE_KEYS_BY_MODE.test ||
      normalizeStripeKeyForMode(STRIPE_PUBLISHABLE_KEY_FALLBACK, "live") ||
      normalizeStripeKeyForMode(STRIPE_PUBLISHABLE_KEY_FALLBACK, "test") ||
      "";
    const stripeMembershipConfig = stripeConfig.membershipPlans || {};
    // Enable Stripe when at least one key exists (fallback prevents false negatives)
    const STRIPE_ENABLED = STRIPE_DEFAULT_PUBLISHABLE_KEY.length > 0;
    const STRIPE_JS_URL = "https://js.stripe.com/v3/";
    const FORCE_DISABLE_GOOGLE_PAY = window.location.protocol !== "https:";
    const PAYMENT_ERROR_FALLBACK =
      "Payments are temporarily unavailable. Please try again.";
    const rideCheckoutSessionEndpoints = buildRideCheckoutSessionEndpoints();

    function isFirebaseHttpsError(err) {
      return typeof err?.code === "string" && err.code.startsWith("functions/");
    }

    function handleCallableError(source, err, fallbackMessage = PAYMENT_ERROR_FALLBACK) {
      if (isFirebaseHttpsError(err)) {
        console.error(`${source} failed`, {
          code: err.code,
          message: err.message,
          details: err.details ?? null,
        });
        return new Error(fallbackMessage);
      }
      console.error(`${source} failed`, err);
      return err instanceof Error ? err : new Error(fallbackMessage);
    }

    function resolveStripePublishableKeyForMode(livemode) {
      if (livemode === true) {
        return STRIPE_KEYS_BY_MODE.live || null;
      }
      if (livemode === false) {
        return STRIPE_KEYS_BY_MODE.test || null;
      }
      return STRIPE_DEFAULT_PUBLISHABLE_KEY || null;
    }

    // === RIDE SYNC STRIPE: DEBUG HELPERS ===
    function logStripeDebug(label, payload) {
      try {
        console.log("[RideSync][Stripe]", label, payload);
      } catch (_) {
        // no-op: logging should never break the app
      }
    }
    function resolveClientSecret(payload = {}) {
      return payload?.clientSecret || payload?.client_secret || null;
    }
    const createMembershipPaymentIntentFn = httpsCallable(
      functionsClient,
      "createMembershipPaymentIntent"
    );
    const applyMembershipPlanFn = httpsCallable(
      functionsClient,
      "applyMembershipPlan"
    );
    const createMembershipSubscriptionIntentFn = httpsCallable(
      functionsClient,
      "createMembershipSubscriptionIntent"
    );
    const finalizeMembershipSubscriptionFn = httpsCallable(
      functionsClient,
      "finalizeMembershipSubscription"
    );
    const getDriverAvailabilityStatsFn = httpsCallable(
      functionsClient,
      "getDriverAvailabilityStats"
    );
    const createRideCheckoutSessionCallableFn = httpsCallable(
      functionsClient,
      "createRideCheckoutSessionCallable"
    );
    const saveUserProfileFn = httpsCallable(functionsClient, "saveUserProfile");
    const createRideRequestFn = httpsCallable(functionsClient, "createRideRequest");
    const joinRideGroupFn = httpsCallable(functionsClient, "joinRideGroup");
    const cancelRideRequestFn = httpsCallable(functionsClient, "cancelRideRequest");
    const submitRideRatingFn = httpsCallable(functionsClient, "submitRideRating");
    const confirmRidePaymentIntentFn = httpsCallable(
      functionsClient,
      "confirmRidePaymentIntent"
    );
    const createRidePaymentIntentFn = httpsCallable(
      functionsClient,
      "createRidePaymentIntent"
    );

    const NWA_CENTER = geoConfig.nwaCenter || { lat: 36.334, lng: -94.118 };
    const NWA_RADIUS_MILES = geoConfig.nwaRadiusMiles ?? 30;
    const UNLIMITED_COOLDOWN_MINUTES =
      ridePolicyConfig.unlimitedCooldownMinutes ?? 30;
    const SURGE_MODE = ridePolicyConfig.surgeMode ?? false;
    const SURGE_COOLDOWN_MINUTES =
      ridePolicyConfig.surgeCooldownMinutes ?? 60;
    const DRIVER_PLACEHOLDER_AVATAR = placeholderConfig.driverAvatar || "";
    const VEHICLE_PLACEHOLDER_IMG = placeholderConfig.vehicleImage || "";
    const LICENSE_PLACEHOLDER_IMG = placeholderConfig.licenseImage || "";
    const SUPPORT_PHONE_NUMBER = supportConfig.phoneNumber || "";
    const SUPPORT_TEL_LINK = SUPPORT_PHONE_NUMBER
      ? `tel:${SUPPORT_PHONE_NUMBER}`
      : "#";
    const SUPPORT_SMS_LINK = SUPPORT_PHONE_NUMBER
      ? `sms:${SUPPORT_PHONE_NUMBER}`
      : "#";
    const MEMBERSHIP_PLAN_COPY = {
      basic: {
        label: "Basic",
        price: "$0 / ride",
        description: "Pay per ride with Stripe.",
      },
      uofa_unlimited: {
        label: "U of A Unlimited",
        price: "$80 / month",
        description: "Unlimited Fayetteville rides.",
      },
      nwa_unlimited: {
        label: "NWA Unlimited",
        price: "$120 / month",
        description: "Unlimited rides inside the 30-mile NWA radius.",
      },
    };
    const MEMBERSHIP_PLAN_KEY_ALIASES = {
      basic: new Set(["basic", "basic (pay per ride)", "basic plan", "plan: basic"]),
    };
    const MEMBERSHIP_PLAN_DEFAULT_MODES = {
      basic: "none",
      uofa_unlimited: "subscription",
      nwa_unlimited: "subscription"
    };
    const MEMBERSHIP_PLAN_VALID_MODES = new Set(["subscription", "payment", "none"]);

    const DEFAULT_FARE_SETTINGS = {
      BASIC_RATE_PER_MIN: 0.6,
      BASIC_PLATFORM_FEE: 0.5,
      BASIC_PROCESSING_FEE_RATE: 0.03,
      UNLIMITED_OUT_RATE: 0.35,
      UNLIMITED_PROCESSING_FEE_RATE: 0.04
    };

    function coerceFareNumber(value, fallback) {
      if (value === null || value === undefined) {
        return fallback;
      }
      if (typeof value === "string" && value.trim() === "") {
        return fallback;
      }
      const num = Number(value);
      return Number.isFinite(num) && num >= 0 ? num : fallback;
    }

    const FARE_SETTINGS = {
      BASIC_RATE_PER_MIN: coerceFareNumber(
        fareConfig.basicRatePerMin,
        DEFAULT_FARE_SETTINGS.BASIC_RATE_PER_MIN
      ),
      BASIC_PLATFORM_FEE: coerceFareNumber(
        fareConfig.basicPlatformFee,
        DEFAULT_FARE_SETTINGS.BASIC_PLATFORM_FEE
      ),
      BASIC_PROCESSING_FEE_RATE: coerceFareNumber(
        fareConfig.basicProcessingFeeRate,
        DEFAULT_FARE_SETTINGS.BASIC_PROCESSING_FEE_RATE
      ),
      UNLIMITED_OUT_RATE: coerceFareNumber(
        fareConfig.unlimitedOutRate,
        DEFAULT_FARE_SETTINGS.UNLIMITED_OUT_RATE
      ),
      UNLIMITED_PROCESSING_FEE_RATE: coerceFareNumber(
        fareConfig.unlimitedProcessingFeeRate,
        DEFAULT_FARE_SETTINGS.UNLIMITED_PROCESSING_FEE_RATE
      )
    };

    const urlParams = new URLSearchParams(window.location.search);
    const joinRideIdFromUrl = urlParams.get("join");
    let joinMode = false;
    let joinTargetRide = null;

    const PIN_CHARSET = "0123456789";
    const POOL_GENDER_ALLOWLIST = new Set(["male", "female"]);
    const METERS_TO_MILES = 0.000621371;

    function normalizePoolGender(value) {
      if (typeof value !== "string") {
        return null;
      }
      const normalized = value.trim().toLowerCase();
      return POOL_GENDER_ALLOWLIST.has(normalized) ? normalized : null;
    }

    function generateRidePin(length = 4) {
      let code = "";
      for (let i = 0; i < length; i += 1) {
        const idx = Math.floor(Math.random() * PIN_CHARSET.length);
        code += PIN_CHARSET.charAt(idx);
      }
      return code;
    }

    let lastDestinationPlace = null;
    let lastDestinationIsFayetteville = false;

    function isFayettevilleFromPlace(place) {
      if (!place || !place.address_components) return false;
      return place.address_components.some(
        (comp) =>
          comp.types.includes("locality") && comp.long_name === "Fayetteville"
      );
    }

    const authView = document.getElementById("authView");
    const rideView = document.getElementById("rideView");
    const loadingView = document.getElementById("loadingView");
    const loginStatusEl = document.getElementById("loginStatus");
    const toggleLink = document.getElementById("toggleLink");
    const authError = document.getElementById("authError");
    const authButton = document.getElementById("authButton");
    const emailEl = document.getElementById("email");
    const passwordEl = document.getElementById("password");
    const signupFields = document.getElementById("signupFields");
    const fullNameEl = document.getElementById("fullName");
    const genderEl = document.getElementById("gender");
    const phoneEl = document.getElementById("phoneNumber");
    const streetEl = document.getElementById("streetAddress");
    const cityEl = document.getElementById("city");
    const stateEl = document.getElementById("state");
    const zipEl = document.getElementById("zip");
    const isStudentEl = document.getElementById("isStudent");
    const membershipEl = document.getElementById("membership");
    const profilePicInput = document.getElementById("profilePicInput");
    const licensePicInput = document.getElementById("licensePicInput");
    const studentIdPicInput = document.getElementById("studentIdPicInput");

    const avatarEl = document.getElementById("avatar");
    const riderNameEl = document.getElementById("riderName");
    const membershipBadgeEl = document.getElementById("membershipBadge");
    const membershipBadgeLabelEl = document.getElementById("membershipBadgeLabel");
    const membershipBadgeTagEl = document.getElementById("membershipBadgeTag");
    const membershipCard = document.getElementById("membershipCard");
    const membershipStatusText = document.getElementById("membershipStatusText");
    const membershipStatusBadge = document.getElementById("membershipStatusBadge");
    const membershipCardMessage = document.getElementById("membershipCardMessage");
    const membershipCurrentLabel = document.getElementById("membershipCurrentLabel");
    const membershipChangeButton = document.getElementById("membershipChangeButton");
    const membershipPriceEls = document.querySelectorAll("[data-plan-price]");
    const membershipSelectionOverlay = document.getElementById("membershipSelectionOverlay");
    const membershipSelectionClose = document.getElementById("membershipSelectionClose");
    const membershipSelectionOptions = document.querySelectorAll(
      "[data-membership-option]"
    );
    const membershipSelectionError = document.getElementById("membershipSelectionError");
    const membershipTermsButton = document.getElementById("membershipTermsButton");
    const membershipTermsOverlay = document.getElementById("membershipTermsOverlay");
    const membershipTermsClose = document.getElementById("membershipTermsClose");
    const membershipTermsContent = document.getElementById("membershipTermsContent");
    const membershipTermsCheckbox = document.getElementById("membershipTermsCheckbox");
    const membershipTermsError = document.getElementById("membershipTermsError");

    const riderEmailDetailEl = document.getElementById("riderEmailDetail");
    const riderPhoneDetailEl = document.getElementById("riderPhoneDetail");
    const riderAddressDetailEl = document.getElementById("riderAddressDetail");
    const riderMembershipDetailEl = document.getElementById("riderMembershipDetail");
    const editProfileButton = document.getElementById("editProfileButton");
    const editProfileSection = document.getElementById("editProfileSection");
    const editFullNameEl = document.getElementById("editFullName");
    const editPhoneEl = document.getElementById("editPhone");
    const editStreetEl = document.getElementById("editStreet");
    const editCityEl = document.getElementById("editCity");
    const editStateEl = document.getElementById("editState");
    const editZipEl = document.getElementById("editZip");
    const editProfilePicInput = document.getElementById("editProfilePicInput");
    const editLicensePicInput = document.getElementById("editLicensePicInput");
    const editStudentIdPicInput = document.getElementById("editStudentIdPicInput");
    const editGenderEl = document.getElementById("editGender");
    const saveProfileButton = document.getElementById("saveProfileButton");

    const joinBanner = document.getElementById("joinBanner");
    const joinBannerText = document.getElementById("joinBannerText");

    const poolGroupTitle = document.getElementById("poolGroupTitle");
    const poolGroupBox = document.getElementById("poolGroupBox");
    const poolGroupStatus = document.getElementById("poolGroupStatus");
    const poolGroupList = document.getElementById("poolGroupList");

    const profileMessage = document.getElementById("profileMessage");
    const profileError = document.getElementById("profileError");
    const driverAvailabilityNotice = document.getElementById("driverAvailabilityNotice");

    function showErrorBanner(message) {
      if (profileError) {
        profileError.textContent =
          message || "Payments are temporarily unavailable. Please try again.";
      } else {
        console.error(message);
      }
    }

    const mapEl = document.getElementById("map");
    const destinationEl = document.getElementById("destination");
    const addStopButton = document.getElementById("addStopButton");
    const extraStopsContainer = document.getElementById("extraStopsContainer");
    const numRidersEl = document.getElementById("numRiders");
    const ridersSection = document.getElementById("ridersSection");
    const tripMapPreviewEl = document.getElementById("tripMapPreview");
    const destinationPreviewMapEl = document.getElementById("destinationPreviewMap");
    const destinationPreviewEmptyEl = document.getElementById("destinationPreviewEmpty");
    const paymentFareSummary = document.getElementById("paymentFareSummary");
    const fareNotReady = document.getElementById("fareNotReady");
    const fareReady = document.getElementById("fareReady");
    const fareTime = document.getElementById("fareTime");
    const fareDistance = document.getElementById("fareDistance");
    const fareMembership = document.getElementById("fareMembership");
    const fareTotal = document.getElementById("fareTotal");
    const fareExtraStops = document.getElementById("fareExtraStops");
    const syncButton = document.getElementById("syncButton");
    const logoutButton = document.getElementById("logoutButton");

    const cancelRideButton = document.getElementById("cancelRideButton");
    const cancelError = document.getElementById("cancelError");

    const groupQrSection = document.getElementById("groupQrSection");
    const groupQrCanvas = document.getElementById("groupQrCanvas");
    const groupOccupancyLabel = document.getElementById("groupOccupancyLabel");
    let groupQr = null;

    try {
      await loadGoogleMapsSdk({ apiKey: mapsApiKey, libraries: mapsLibraries });
    } catch (err) {
      googleMapsLoadFailed = true;
      console.error("Google Maps SDK failed to load", err);
      if (profileError) {
        profileError.textContent =
          "Unable to load maps right now. Please refresh or verify the Maps API key.";
      }
    }

    // Rider active-ride overlay + mini bar + summary
    const riderOverlay = document.getElementById("riderOverlay");
    const riderOverlayTitle = document.getElementById("riderOverlayTitle");
    const riderOverlaySubtitle = document.getElementById("riderOverlaySubtitle");
    const riderOverlayError = document.getElementById("riderOverlayError");
    const riderStateElements = {
      searching: document.getElementById("riderStateSearching"),
      driverEta: document.getElementById("riderStateDriverEta"),
      pickupPin: document.getElementById("riderStatePickupPin"),
      inTrip: document.getElementById("riderStateInTrip"),
      dropoffPin: document.getElementById("riderStateDropoffPin"),
      rateTip: document.getElementById("riderStateRateTip"),
      thanks: document.getElementById("riderStateThanks")
    };
    const driverInfoSlotPickup = riderStateElements.driverEta?.querySelector(".driver-info-slot") || null;
    const driverInfoSlotTrip = riderStateElements.inTrip?.querySelector(".driver-info-slot") || null;
    const riderPickupPinValue = document.getElementById("riderPickupPinValue");
    const riderDropoffPinValue = document.getElementById("riderDropoffPinValue");
    const riderTripEtaText = document.getElementById("riderTripEtaText");
    const riderWaitlistPanel = document.getElementById("riderWaitlistPanel");
    const riderWaitlistStatusEl = document.getElementById("riderWaitlistStatus");
    const riderWaitlistTimerEl = document.getElementById("riderWaitlistTimer");
    const riderWaitlistBadgeEl = document.getElementById("riderWaitlistBadge");
    const driverInfoStack = document.getElementById("driverInfoStack");
    const ratingStarsContainer = document.getElementById("ratingStars");
    const ratingError = document.getElementById("ratingError");
    const rideTipOptions = document.getElementById("rideTipOptions");
    const rideTipCustomInput = document.getElementById("rideTipCustomInput");
    const submitRatingButton = document.getElementById("submitRatingButton");
    const riderFeedbackInput = document.getElementById("riderFeedbackInput");
    const cooldownOverlay = document.getElementById("cooldownOverlay");
    const cooldownLabelEl = document.getElementById("cooldownLabel");
    const cooldownTitleEl = document.getElementById("cooldownTitle");
    const cooldownSubtitleEl = document.getElementById("cooldownSubtitle");
    const cooldownTimerValue = document.getElementById("cooldownTimerValue");
    const cooldownHintText = document.getElementById("cooldownHintText");
    const cooldownDismissButton = document.getElementById("cooldownDismissButton");

    const driverIdentityCardEl = document.getElementById("driverIdentityCard");
    const driverIdentityNameEl = document.getElementById("driverIdentityName");
    const driverIdentityStatusEl = document.getElementById("driverIdentityStatus");
    const driverIdentityRatingEl = document.getElementById("driverIdentityRating");
    const driverIdentityAvatarImg = document.getElementById("driverIdentityAvatarImg");
    const driverIdentityAvatarFallback = document.getElementById("driverIdentityAvatarFallback");
    const driverIdentityPhoneRow = document.getElementById("driverIdentityPhoneRow");
    const driverIdentityPhoneEl = document.getElementById("driverIdentityPhone");
    const driverIdentityBadgesEl = document.getElementById("driverIdentityBadges");
    const driverIdentityEtaEl = document.getElementById("driverIdentityEta");
    const driverMiniMapShell = document.getElementById("driverMiniMapShell");
    const driverMiniMapEl = document.getElementById("driverMiniMap");
    const driverMiniMapStatusEl = document.getElementById("driverMiniMapStatus");

    const driverVehicleSection = document.getElementById("driverVehicleSection");
    const driverVehiclePhotoImg = document.getElementById("driverVehiclePhoto");
    const driverVehicleFallbackEl = document.getElementById("driverVehicleFallback");
    const driverVehicleNameEl = document.getElementById("driverVehicleName");
    const driverVehiclePlateEl = document.getElementById("driverVehiclePlate");
    const driverVehicleNoteEl = document.getElementById("driverVehicleNote");

    const driverLicenseSection = document.getElementById("driverLicenseSection");
    const driverLicensePhotoImg = document.getElementById("driverLicensePhoto");
    const driverLicenseFallbackEl = document.getElementById("driverLicenseFallback");
    const driverLicenseSummaryEl = document.getElementById("driverLicenseSummary");
    const driverLicenseMetaEl = document.getElementById("driverLicenseMeta");

    const supportPanel = document.getElementById("supportPanel");
    const supportBackButton = document.getElementById("supportBackButton");
    const supportCallButton = document.getElementById("supportCallButton");
    const supportTextButton = document.getElementById("supportTextButton");

    const rideSummary = document.getElementById("rideSummary");
    const rideSummaryText = document.getElementById("rideSummaryText");

    const contactDriverBtn = document.getElementById("contactDriverBtn");
    const rideViewTabs = document.querySelectorAll("[data-view-tab]");
    const rideViewPanels = document.querySelectorAll("[data-view-panel]");

    const paymentOverlay = document.getElementById("paymentOverlay");
    const paymentOverlayTitle = document.getElementById("paymentOverlayTitle");
    const paymentOverlaySubtitle = document.getElementById("paymentOverlaySubtitle");
    const paymentOverlayClose = document.getElementById("paymentOverlayClose");
    const paymentOverlayConfirm = document.getElementById("paymentOverlayConfirm");
    const paymentOverlayMessage = document.getElementById("paymentOverlayMessage");
    const paymentElementContainer = document.getElementById("paymentElement");
    const paymentRedirectOverlay = document.getElementById("paymentRedirectOverlay");
    const paymentRedirectSubtitle = document.getElementById("paymentRedirectSubtitle");
    const paymentStatusOverlay = document.getElementById("paymentStatusOverlay");
    const paymentStatusTitle = document.getElementById("paymentStatusTitle");
    const paymentStatusMessage = document.getElementById("paymentStatusMessage");
    const paymentStatusBackButton = document.getElementById("paymentStatusBackButton");
    const rideFareOverlay = document.getElementById("rideFareOverlay");
    const rideFareSubtitle = document.getElementById("rideFareSubtitle");
    const rideFareAmount = document.getElementById("rideFareAmount");
    const rideFareDetails = document.getElementById("rideFareDetails");
    const rideFarePaymentRequest =
      document.getElementById("rideFarePaymentRequest");
    const rideFareUnavailable = document.getElementById("rideFareUnavailable");
    const rideFareStatus = document.getElementById("rideFareStatus");
    const rideFareClose = document.getElementById("rideFareClose");
    const rideFareBaseAmount = document.getElementById("rideFareBaseAmount");
    const rideFareTipAmount = document.getElementById("rideFareTipAmount");
    const rideCardElement = document.getElementById("rideCardElement");
    const rideCardSubmit = document.getElementById("rideCardSubmit");
    const rideCardMessage = document.getElementById("rideCardMessage");

    let latestRideForOverlay = null;
    const stripeInstancesByKey = new Map();
    let stripeElements = null;
    let stripePaymentElement = null;
    let activePaymentContext = null;
    let activePaymentLivemode = null;
    let stripeJsPromise = null;
    const ridePaymentState = {
      rideId: null,
      baseAmountCents: 0,
      tipAmountCents: 0,
      totalAmountCents: 0,
      clientSecret: null,
      summary: null,
      paymentRequest: null,
      paymentRequestElement: null,
      paymentRequestElementsInstance: null,
      paymentElements: null,
      paymentElement: null,
      processing: false,
      completed: false,
      showing: false,
      livemode: null,
      intentRequestId: 0,
      clientSecretContext: null,
    };

    const RIDER_STATES = {
      HIDDEN: "hidden",
      SEARCHING: "searching",
      DRIVER_TO_PICKUP: "driver_to_pickup",
      PICKUP_PIN: "pickup_pin",
      IN_TRIP: "in_trip",
      DROPOFF_PIN: "dropoff_pin",
      RATE_TIP: "rate_tip",
      THANKS: "thanks"
    };

    let riderOverlayState = RIDER_STATES.HIDDEN;
    let selectedRating = 0;
    let ratingSubmitting = false;
    let rideTipRefreshTimer = null;

    let isSignupMode = false;
    let currentUserProfile = null;
    let pendingMembershipPlanId = null;
    let membershipTermsProcessing = false;
    let membershipTermsAcknowledged = false;
    let membershipTermsScrollComplete = false;

    let map;
    let directionsService;
    let directionsRenderer;
    let pickupMarker;
    let destMarker;
    let destinationPreviewMap;
    let destinationPreviewPickupMarker;
    let destinationPreviewDestMarker;
    let driverMiniMap;
    let driverMiniMapDriverMarker;
    let driverMiniMapPickupMarker;
    let driverMiniMapDropoffMarker;
    let lastDriverMiniMapData = null;
    let currentLocation = null;
    let destinationLatLng = null;
    let destAutocomplete = null;
    let lastRideMetrics = null;
    let activeRideViewSection = "destination";
    let hasOnlineDrivers = false;
    let driverAvailabilityUnsub = null;
    let driverAvailabilityPollTimer = null;
    const DRIVER_AVAILABILITY_POLL_INTERVAL_MS = 20000;

    let activeRideUnsub = null;
    let activeGroupUnsub = null;
    let groupOccupancyUnsub = null;
    const WAITLIST_RIDE_STATUSES = new Set([
      "pending_driver",
      "pending",
      "pool_searching",
      "pooled_pending_driver"
    ]);
    const MAX_EXTRA_STOPS = 3;
    let extraStopIdCounter = 0;
    const extraStopsState = [];
    const DRIVER_BUSY_STATUSES = [
      "driver_assigned",
      "arrived_at_pickup",
      "pickup_code_verified",
      "arrived_at_dropoff"
    ];
    let driverOnlineUnsub = null;
    let driverBusyUnsub = null;
    const driverAvailability = {
      onlineCount: 0,
      onlineIds: new Set(),
      busyDriverIds: new Set()
    };
    const waitlistState = {
      active: false,
      startedAt: null,
      timerId: null
    };

    let currentRideId = null;
    let currentRideStatus = null;
    let currentRideWatcher = null;
    let lastRideCompletionContext = null;
    let cooldownOverlayUnlockAt = null;
    let cooldownOverlayTimerId = null;

    const riderCancelableStatuses = new Set([
      "pending_driver",
      "pooled_pending_driver",
      "pool_searching",
      "driver_assigned",
      "driver_arrived",
      "pending"
    ]);
    const COOLDOWN_ELIGIBLE_PLANS = new Set(["uofa_unlimited", "nwa_unlimited"]);

    function updateCancelButtonVisibility() {
      if (!cancelRideButton) return;
      const hasRide = !!currentRideId;
      const cancelable =
        !currentRideStatus || riderCancelableStatuses.has(currentRideStatus);
      const shouldShow = hasRide && cancelable;
      cancelRideButton.hidden = !shouldShow;
      if (!shouldShow && cancelError) {
        cancelError.textContent = "";
      }
    }

    function setRideViewPanel(targetKey) {
      if (!targetKey || !rideViewPanels.length) return;
      activeRideViewSection = targetKey;
      rideViewTabs.forEach((tab) => {
        if (!tab?.dataset?.viewTab) return;
        const isActive = tab.dataset.viewTab === targetKey;
        tab.classList.toggle("active", isActive);
        tab.setAttribute("aria-selected", isActive ? "true" : "false");
        tab.setAttribute("tabindex", isActive ? "0" : "-1");
      });
      rideViewPanels.forEach((panel) => {
        if (!panel?.dataset?.viewPanel) return;
        const isActive = panel.dataset.viewPanel === targetKey;
        panel.classList.toggle("active", isActive);
        panel.setAttribute("aria-hidden", isActive ? "false" : "true");
      });
      if (targetKey === "destination") {
        setTimeout(() => {
          if (destinationPreviewMap && window.google?.maps) {
            google.maps.event.trigger(destinationPreviewMap, "resize");
          }
          updateTripPreviewMap();
        }, 80);
      }
    }

    if (rideViewTabs.length && rideViewPanels.length) {
      rideViewTabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          const key = tab.dataset?.viewTab;
          if (key && key !== activeRideViewSection) {
            setRideViewPanel(key);
          }
        });
      });
    }

    updateCancelButtonVisibility();

    function clearCurrentRideState() {
        currentRideId = null;
        currentRideStatus = null;
        if (currentRideWatcher) {
          currentRideWatcher();
          currentRideWatcher = null;
        }
        if (activeRideUnsub) {
          activeRideUnsub();
          activeRideUnsub = null;
        }
        if (activeGroupUnsub) {
          activeGroupUnsub();
          activeGroupUnsub = null;
        }
        deactivateWaitlistPanel();
        hideGroupQr();
        updateCancelButtonVisibility();
        closeRideFareOverlay(true);
      }

      function resetJoinModeUi() {
        joinMode = false;
        joinTargetRide = null;
        if (joinBanner) joinBanner.style.display = "none";
        if (ridersSection) ridersSection.style.display = "block";
        if (numRidersEl) {
          numRidersEl.disabled = false;
        }
        updateSyncButtonLabel();
      }

      function returnToHomeAfterRide(message = "", isError = false) {
        clearCurrentRideState();
        setRiderOverlayState(RIDER_STATES.HIDDEN);
        supportPanel?.classList.remove("active");
        if (rideSummary) rideSummary.style.display = "none";
        showRideView();
        clearPoolGroupUI();
        resetJoinModeUi();
        hideGroupQr();
        resetTripPlanner();
        resetRatingForm();
        if (cancelError) cancelError.textContent = "";

        if (isError) {
          profileError.textContent = message || "";
          profileMessage.textContent = "";
        } else {
          profileMessage.textContent = message || "";
          profileError.textContent = "";
        }
      maybeShowPostRideCooldown();
    }

    function extractRideCompletionTime(data) {
      if (!data) return new Date();
      const candidates = [
        data.completedAt,
        data.dropoffCompletedAt,
        data.dropoffCodeVerifiedAt,
        data.updatedAt
      ];
      for (const candidate of candidates) {
        if (!candidate) continue;
        if (typeof candidate.toDate === "function") {
          return candidate.toDate();
        }
        if (candidate instanceof Date) {
          return candidate;
        }
        if (typeof candidate === "number") {
          return new Date(candidate);
        }
      }
      return new Date();
    }

    function rememberRideCompletionContext(status, data) {
      if (status !== "dropoff_code_verified" && status !== "completed") {
        lastRideCompletionContext = null;
        return;
      }
      const plan = normalizePlanKey(
        data?.membershipType ||
          currentUserProfile?.membershipType ||
          currentUserProfile?.membership ||
          "basic"
      );
      if (!COOLDOWN_ELIGIBLE_PLANS.has(plan)) {
        lastRideCompletionContext = null;
        return;
      }
      lastRideCompletionContext = {
        plan,
        completedAt: extractRideCompletionTime(data)
      };
    }

    function stopCooldownOverlayTimer() {
      if (cooldownOverlayTimerId) {
        clearInterval(cooldownOverlayTimerId);
        cooldownOverlayTimerId = null;
      }
    }

    function hideCooldownOverlay() {
      stopCooldownOverlayTimer();
      cooldownOverlayUnlockAt = null;
      if (cooldownOverlay) {
        cooldownOverlay.classList.remove("active");
        cooldownOverlay.setAttribute("aria-hidden", "true");
      }
    }

    function formatCooldownRemaining(ms) {
      const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
      const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
      const seconds = String(totalSeconds % 60).padStart(2, "0");
      return `${minutes}:${seconds}`;
    }

    function tickCooldownOverlay() {
      if (!cooldownOverlayUnlockAt || !cooldownTimerValue) return;
      const remainingMs = cooldownOverlayUnlockAt - Date.now();
      if (remainingMs <= 0) {
        cooldownTimerValue.textContent = "00:00";
        hideCooldownOverlay();
        return;
      }
      cooldownTimerValue.textContent = formatCooldownRemaining(remainingMs);
    }

    function showCooldownOverlay(options) {
      if (!cooldownOverlay) return;
      const { planLabel, unlockAt, coolMinutes } = options;
      cooldownOverlayUnlockAt = unlockAt;
      if (cooldownLabelEl) {
        cooldownLabelEl.textContent = `${planLabel} cooldown`;
      }
      if (cooldownTitleEl) {
        cooldownTitleEl.textContent = "Next ride unlocks in";
      }
      if (cooldownSubtitleEl) {
        const minuteLabel = coolMinutes === 1 ? "minute" : "minutes";
        cooldownSubtitleEl.textContent = `Hang tight for about ${coolMinutes} ${minuteLabel}.`;
      }
      if (cooldownHintText) {
        cooldownHintText.textContent = `${planLabel} riders take a short break between trips so everyone gets a driver.`;
      }
      cooldownOverlay.classList.add("active");
      cooldownOverlay.setAttribute("aria-hidden", "false");
      tickCooldownOverlay();
      if (!cooldownOverlayTimerId) {
        cooldownOverlayTimerId = window.setInterval(tickCooldownOverlay, 1000);
      }
    }

    function maybeShowPostRideCooldown() {
      if (!lastRideCompletionContext) return;
      const context = lastRideCompletionContext;
      lastRideCompletionContext = null;
      const coolMinutes = SURGE_MODE ? SURGE_COOLDOWN_MINUTES : UNLIMITED_COOLDOWN_MINUTES;
      if (!coolMinutes || coolMinutes <= 0) {
        hideCooldownOverlay();
        return;
      }
      if (!COOLDOWN_ELIGIBLE_PLANS.has(context.plan)) {
        hideCooldownOverlay();
        return;
      }
      const unlockAt = context.completedAt.getTime() + coolMinutes * 60000;
      const remainingMs = unlockAt - Date.now();
      if (remainingMs <= 0) {
        hideCooldownOverlay();
        return;
      }
      const planLabel = formatMembershipPlanLabel(context.plan);
      showCooldownOverlay({ planLabel, unlockAt, coolMinutes });
    }

    function safeImageUrl(url) {
      if (!url && url !== 0) return null;
      const value = String(url).trim();
      if (!value || value === "null" || value === "undefined") return null;
      return value;
    }

    function applyImage(imgEl, fallbackEl, url, placeholder) {
      if (!imgEl) return;
      const finalUrl = safeImageUrl(url);
      const hasRealImage = !!finalUrl;
      const source = hasRealImage ? finalUrl : (placeholder || null);
      if (source) {
        imgEl.src = source;
        imgEl.style.display = "block";
        imgEl.onerror = () => {
          imgEl.onerror = null;
          if (placeholder) {
            imgEl.src = placeholder;
          }
        };
        if (fallbackEl) {
          fallbackEl.style.display = hasRealImage ? "none" : "flex";
        }
      } else {
        imgEl.removeAttribute("src");
        imgEl.style.display = "none";
        if (fallbackEl) {
          fallbackEl.style.display = "flex";
        }
      }
    }

    function parseLatLngCandidate(value) {
      if (!value) return null;
      if (typeof value.lat === "number" && typeof value.lng === "number") {
        return { lat: value.lat, lng: value.lng };
      }
      if (typeof value.latitude === "number" && typeof value.longitude === "number") {
        return { lat: value.latitude, lng: value.longitude };
      }
      return null;
    }

    function extractLatLngFromPairs(target, pairs) {
      for (const [latKey, lngKey] of pairs) {
        const lat = target?.[latKey];
        const lng = target?.[lngKey];
        if (typeof lat === "number" && typeof lng === "number") {
          return { lat, lng };
        }
      }
      return null;
    }

    function extractPickupLocationFromRide(data) {
      if (!data) return null;
      const candidates = [
        data.pickupLocation,
        data.fromLocation,
        data.originLocation,
        data.pickupGeo,
        data.pickupCoordinates,
        data.fromCoordinates
      ];
      for (const candidate of candidates) {
        const parsed = parseLatLngCandidate(candidate);
        if (parsed) return parsed;
      }
      return extractLatLngFromPairs(data, [
        ["pickupLat", "pickupLng"],
        ["fromLat", "fromLng"],
        ["originLat", "originLng"]
      ]);
    }

    function extractDropoffLocationFromRide(data) {
      if (!data) return null;
      const candidates = [
        data.dropoffLocation,
        data.toLocation,
        data.destinationLocation,
        data.destLocation,
        data.dropoffGeo,
        data.toCoordinates,
        data.destCoordinates
      ];
      for (const candidate of candidates) {
        const parsed = parseLatLngCandidate(candidate);
        if (parsed) return parsed;
      }
      return extractLatLngFromPairs(data, [
        ["dropoffLat", "dropoffLng"],
        ["destLat", "destLng"],
        ["toLat", "toLng"],
        ["destinationLat", "destinationLng"]
      ]);
    }

    function extractDriverLocation(data) {
      if (!data) return null;
      const candidates = [
        data.driverLocation,
        data.driverCurrentLocation,
        data.currentDriverLocation
      ];
      for (const candidate of candidates) {
        const parsed = parseLatLngCandidate(candidate);
        if (parsed) return parsed;
      }
      return extractLatLngFromPairs(data, [
        ["driverLat", "driverLng"],
        ["driverLatitude", "driverLongitude"],
        ["driverCurrentLat", "driverCurrentLng"]
      ]);
    }

    function formatPhoneDisplay(phone) {
      if (!phone) return "";
      const digits = phone.replace(/\D/g, "");
      if (!digits) return "";
      let clean = digits;
      if (clean.length === 11 && clean.startsWith("1")) {
        clean = clean.slice(1);
      }
      if (clean.length === 10) {
        return `(${clean.slice(0, 3)}) ${clean.slice(3, 6)}-${clean.slice(6)}`;
      }
      return phone;
    }

    function renderDriverBadges(data) {
      if (!driverIdentityBadgesEl) return;
      const badges = [];
      if (data?.driverVerifiedId) badges.push("Verified ID");
      if (data?.driverDrugTestCleared) badges.push("Drug Test Cleared");
      if (data?.driverBackgroundCheckCleared) badges.push("Background Check Cleared");
      if (badges.length) {
        driverIdentityBadgesEl.innerHTML = badges
          .map((label) => `<span class="driver-badge-pill">${label}</span>`)
          .join("");
        driverIdentityBadgesEl.style.display = "flex";
      } else {
        driverIdentityBadgesEl.innerHTML = "";
        driverIdentityBadgesEl.style.display = "none";
      }
    }

    function renderDriverIdentity(data) {
      if (!driverIdentityCardEl) return;
      const name = data?.driverName || "RideSync driver";
      driverIdentityNameEl.textContent = name;

      const avatarUrl =
        safeImageUrl(data?.driverAvatarUrl) ||
        safeImageUrl(data?.driverPhotoUrl) ||
        safeImageUrl(data?.driverProfilePicUrl);
      applyImage(driverIdentityAvatarImg, driverIdentityAvatarFallback, avatarUrl, DRIVER_PLACEHOLDER_AVATAR);
      if (driverIdentityAvatarFallback) {
        const initials = name
          .split(" ")
          .filter(Boolean)
          .map((part) => part[0])
          .join("")
          .slice(0, 2)
          .toUpperCase() || "RS";
        driverIdentityAvatarFallback.textContent = initials;
      }

      const ratingValue = Number(data?.driverRating);
      const hasRating = !Number.isNaN(ratingValue) && ratingValue > 0;
      if (hasRating) {
        driverIdentityRatingEl.textContent = `★ ${ratingValue.toFixed(1)}`;
        driverIdentityRatingEl.style.display = "inline-flex";
        const rideCount = Number(data?.driverRatingCount);
        driverIdentityStatusEl.textContent = rideCount
          ? `${rideCount}+ RideSync trips`
          : "RideSync trusted";
      } else {
        driverIdentityRatingEl.style.display = "none";
        driverIdentityStatusEl.textContent = "New RideSync driver";
      }

      const rawPhone = data?.driverPhone || data?.driverPhoneNumber;
      const formattedPhone = formatPhoneDisplay(rawPhone || "");
      if (formattedPhone) {
        driverIdentityPhoneEl.textContent = `Call or text ${formattedPhone}`;
        driverIdentityPhoneRow?.classList.remove("hidden");
      } else if (data?.driverContactViaRideSync) {
        driverIdentityPhoneEl.textContent = "Contact RideSync support";
        driverIdentityPhoneRow?.classList.remove("hidden");
      } else {
        driverIdentityPhoneEl.textContent = "";
        driverIdentityPhoneRow?.classList.add("hidden");
      }

      if (driverIdentityEtaEl) {
        const statusCopy = friendlyDriverStatus(data);
        const etaCopy = formatDriverEtaText(data);
        const combined = [statusCopy, etaCopy].filter(Boolean).join(" • ");
        if (combined) {
          driverIdentityEtaEl.textContent = combined;
          driverIdentityEtaEl.style.display = "block";
        } else {
          driverIdentityEtaEl.textContent = "";
          driverIdentityEtaEl.style.display = "none";
        }
      }

      renderDriverBadges(data);
    }

    function buildVehicleName(data) {
      if (data?.driverVehicleName) return data.driverVehicleName;
      if (data?.driverVehicleDisplayName) return data.driverVehicleDisplayName;
      const parts = [
        data?.driverVehicleYear,
        data?.driverVehicleColor,
        data?.driverVehicleMake,
        data?.driverVehicleModel
      ].filter(Boolean);
      return parts.join(" ").replace(/\s+/g, " ").trim();
    }

    function renderVehicleSection(data) {
      if (!driverVehicleSection) return;
      const vehicleName = buildVehicleName(data);
      const plate = data?.driverVehiclePlate || data?.driverLicensePlate;
      const photoUrl = data?.driverVehiclePhotoUrl || data?.driverVehiclePhoto;
      const hasAny =
        vehicleName ||
        plate ||
        safeImageUrl(photoUrl);
      if (!hasAny) {
        driverVehicleSection.style.display = "none";
        return;
      }
      driverVehicleSection.style.display = "block";
      applyImage(driverVehiclePhotoImg, driverVehicleFallbackEl, photoUrl, VEHICLE_PLACEHOLDER_IMG);
      driverVehicleNameEl.textContent = vehicleName || "Vehicle verified with RideSync";
      driverVehiclePlateEl.textContent = plate ? `Plate: ${plate}` : "";
      driverVehiclePlateEl.style.display = plate ? "block" : "none";
      driverVehicleNoteEl.textContent = !vehicleName && !plate ? "Vehicle verified with RideSync" : "";
      driverVehicleNoteEl.style.display = driverVehicleNoteEl.textContent ? "block" : "none";
    }

    function renderLicenseSection(data) {
      if (!driverLicenseSection) return;
      const licenseSummary =
        data?.driverLicenseSummary ||
        data?.driverLicenseStatus ||
        (data?.driverLicenseVerified ? "License verified with RideSync" : "");
      const licenseMeta = data?.driverLicenseMeta || (data?.driverLicenseLast4 ? `Ending in ${data.driverLicenseLast4}` : "");
      const photoUrl = data?.driverLicenseImageUrl || data?.driverLicensePhotoUrl;
      const hasAny = licenseSummary || licenseMeta || safeImageUrl(photoUrl);
      if (!hasAny) {
        driverLicenseSection.style.display = "none";
        return;
      }
      driverLicenseSection.style.display = "block";
      applyImage(driverLicensePhotoImg, driverLicenseFallbackEl, photoUrl, LICENSE_PLACEHOLDER_IMG);
      driverLicenseSummaryEl.textContent = licenseSummary || "License verified with RideSync";
      driverLicenseMetaEl.textContent = licenseMeta || "";
      driverLicenseMetaEl.style.display = licenseMeta ? "block" : "none";
    }

    function ensureDriverMiniMap() {
      if (googleMapsLoadFailed) return false;
      if (!driverMiniMapEl) return false;
      if (!window.google || !google.maps) return false;
      if (!driverMiniMap) {
        driverMiniMap = new google.maps.Map(driverMiniMapEl, {
          center: { lat: 36.0626, lng: -94.1574 },
          zoom: 13,
          disableDefaultUI: true,
          gestureHandling: "none",
          clickableIcons: false
        });
        driverMiniMapDriverMarker = new google.maps.Marker({
          map: driverMiniMap,
          visible: false,
          zIndex: 3,
          icon: {
            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
            scale: 5,
            fillColor: "#f97316",
            fillOpacity: 1,
            strokeColor: "#fed7aa",
            strokeWeight: 1
          }
        });
        driverMiniMapPickupMarker = new google.maps.Marker({
          map: driverMiniMap,
          visible: false,
          zIndex: 2,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 6,
            fillColor: "#22c55e",
            fillOpacity: 1,
            strokeColor: "#022c22",
            strokeWeight: 2
          }
        });
        driverMiniMapDropoffMarker = new google.maps.Marker({
          map: driverMiniMap,
          visible: false,
          zIndex: 1,
          icon: "https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png"
        });
      }
      return true;
    }

    function setDriverMiniMapStatus(message) {
      if (!driverMiniMapShell || !driverMiniMapStatusEl) return;
      if (message) {
        driverMiniMapShell.classList.add("show-status");
        driverMiniMapStatusEl.textContent = message;
      } else {
        driverMiniMapShell.classList.remove("show-status");
        driverMiniMapStatusEl.textContent = "";
      }
    }

    function updateDriverMiniMap(data) {
      if (data) {
        lastDriverMiniMapData = data;
      } else if (lastDriverMiniMapData) {
        data = lastDriverMiniMapData;
      } else {
        return;
      }
      if (!driverMiniMapShell) return;

      const status = (data?.status || "").toLowerCase();
      const shouldShow =
        status === "driver_assigned" ||
        status === "driver_arrived" ||
        status === "pickup_code_verified" ||
        status === "in_progress";

      if (!shouldShow) {
        driverMiniMapShell.style.display = "none";
        setDriverMiniMapStatus("");
        return;
      }

      driverMiniMapShell.style.display = "block";

      if (!ensureDriverMiniMap()) {
        setDriverMiniMapStatus(googleMapsLoadFailed ? "Maps unavailable." : "Loading map…");
        return;
      }

      const driverLoc = extractDriverLocation(data);
      const pickupLoc = extractPickupLocationFromRide(data);
      const dropoffLoc = extractDropoffLocationFromRide(data);

      if (!driverLoc) {
        setDriverMiniMapStatus("Waiting for driver location…");
      } else {
        setDriverMiniMapStatus("");
      }

      if (driverMiniMapDriverMarker) {
        driverMiniMapDriverMarker.setVisible(!!driverLoc);
        if (driverLoc) {
          driverMiniMapDriverMarker.setPosition(driverLoc);
          const heading =
            typeof data?.driverHeading === "number"
              ? data.driverHeading
              : typeof data?.driverHeadingDeg === "number"
              ? data.driverHeadingDeg
              : null;
          if (heading != null && driverMiniMapDriverMarker.getIcon()) {
            const icon = { ...driverMiniMapDriverMarker.getIcon(), rotation: heading };
            driverMiniMapDriverMarker.setIcon(icon);
          }
        }
      }

      if (driverMiniMapPickupMarker) {
        driverMiniMapPickupMarker.setVisible(!!pickupLoc);
        if (pickupLoc) {
          driverMiniMapPickupMarker.setPosition(pickupLoc);
        }
      }

      if (driverMiniMapDropoffMarker) {
        driverMiniMapDropoffMarker.setVisible(!!dropoffLoc);
        if (dropoffLoc) {
          driverMiniMapDropoffMarker.setPosition(dropoffLoc);
        }
      }

      const bounds = new google.maps.LatLngBounds();
      let hasBounds = false;
      [driverLoc, pickupLoc, dropoffLoc].forEach((loc) => {
        if (loc) {
          bounds.extend(loc);
          hasBounds = true;
        }
      });

      if (hasBounds) {
        driverMiniMap.fitBounds(bounds, 30);
      } else {
        driverMiniMap.setCenter({ lat: 36.0626, lng: -94.1574 });
        driverMiniMap.setZoom(12);
      }
    }

    function refreshDriverMiniMap() {
      if (!driverMiniMap || !driverMiniMapShell || driverMiniMapShell.style.display === "none") {
        return;
      }
      google.maps.event.trigger(driverMiniMap, "resize");
      updateDriverMiniMap();
    }

    function friendlyDriverStatus(data) {
      if (!data?.status) return "";
      if (data.status === "driver_arrived") return "Driver has arrived";
      if (data.status === "driver_assigned") return "Driver en route to pickup";
      if (data.status === "in_progress") return "Ride in progress";
      if (data.status === "completed") return "Ride completed";
      return data.status.replaceAll("_", " ");
    }

    function formatDriverEtaText(data) {
      if (!data) return "";
      if (typeof data.driverEtaMinutes === "number") {
        const eta = Math.max(0, data.driverEtaMinutes);
        return eta < 1 ? "Less than a minute away" : `Approx. ${Math.round(eta)} min away`;
      }
      if (typeof data.remainingEtaMinutes === "number") {
        const remaining = Math.max(0, data.remainingEtaMinutes);
        return remaining < 1 ? "Almost there" : `About ${Math.round(remaining)} min remaining`;
      }
      return formatTripEstimate(data) || "";
    }

    function showAuthView() {
      authView.classList.add("active");
      rideView.classList.remove("active");
      loadingView.classList.remove("active");
    }
    function showRideView() {
      authView.classList.remove("active");
      rideView.classList.add("active");
      loadingView.classList.remove("active");
    }
    function showLoadingView() {
      authView.classList.remove("active");
      rideView.classList.remove("active");
      loadingView.classList.add("active");
    }

    function setMembershipBadge(profile) {
      const plan = normalizePlanKey(profile?.membershipType || profile?.membership);
      const isStudent = !!profile?.isStudent;
      const uofaVerified = !!profile?.uofaVerified;

      membershipBadgeEl.className = "badge";
      membershipBadgeLabelEl.textContent = "";
      membershipBadgeTagEl.textContent = "";

      if (plan === "uofa_unlimited") {
        membershipBadgeEl.classList.add("badge-uofa");
        membershipBadgeLabelEl.textContent = "U of A Unlimited";
        membershipBadgeTagEl.textContent = uofaVerified
          ? "Verified student"
          : profile?.membershipStatus === "pending_verification"
          ? "Pending approval"
          : (isStudent ? "Student (pending ID)" : "");
      } else if (plan === "nwa_unlimited") {
        membershipBadgeEl.classList.add("badge-nwa");
        membershipBadgeLabelEl.textContent = "NWA Unlimited";
        membershipBadgeTagEl.textContent = "30-mi NWA zone";
      } else {
        membershipBadgeEl.classList.add("badge-basic");
        membershipBadgeLabelEl.textContent = "Basic";
        membershipBadgeTagEl.textContent = "Pay per ride";
      }
    }

    function formatCurrencyFromCents(amountCents = 0, currency = "usd") {
      const value = Number(amountCents || 0) / 100;
      try {
        return new Intl.NumberFormat("en-US", {
          style: "currency",
          currency: (currency || "usd").toUpperCase(),
        }).format(value);
      } catch (err) {
        return `$${value.toFixed(2)}`;
      }
    }

    function formatPlanPriceLabel(planKey) {
      const key = normalizePlanKey(planKey);
      return (
        stripeMembershipConfig?.[key]?.priceDisplay ||
        MEMBERSHIP_PLAN_COPY[key]?.price ||
        MEMBERSHIP_PLAN_COPY.basic.price
      );
    }

    function updateMembershipPrices() {
      if (!membershipPriceEls || typeof membershipPriceEls.forEach !== "function") {
        return;
      }
      membershipPriceEls.forEach((node) => {
        const planKey = node?.dataset?.planPrice;
        if (!planKey) return;
        node.textContent = formatPlanPriceLabel(planKey);
      });
    }

    updateMembershipPrices();

    function normalizePlanKey(plan) {
      const raw = (plan ?? "").toString().trim().toLowerCase();
      if (!raw) {
        return "basic";
      }
      for (const [planKey, aliases] of Object.entries(MEMBERSHIP_PLAN_KEY_ALIASES)) {
        if (aliases.has(raw) || raw === planKey) {
          return planKey;
        }
      }
      return raw;
    }

    function getMembershipPlanMode(planKey) {
      const normalized = normalizePlanKey(planKey);
      const configMode =
        stripeMembershipConfig?.[normalized]?.mode ||
        stripeMembershipConfig?.[normalized]?.billingMode ||
        stripeMembershipConfig?.[normalized]?.type;
      if (
        typeof configMode === "string" &&
        MEMBERSHIP_PLAN_VALID_MODES.has(configMode.toLowerCase())
      ) {
        return configMode.toLowerCase();
      }
      if (MEMBERSHIP_PLAN_DEFAULT_MODES[normalized]) {
        return MEMBERSHIP_PLAN_DEFAULT_MODES[normalized];
      }
      return "payment";
    }

    function formatMembershipPlanLabel(planKey) {
      const normalized = normalizePlanKey(planKey);
      return (
        MEMBERSHIP_PLAN_COPY[normalized]?.label ||
        MEMBERSHIP_PLAN_COPY.basic.label
      );
    }

    function formatMembershipStatusLabel(status) {
      const normalized = (status || "active").toString().toLowerCase();
      if (normalized === "pending_verification") return "Pending approval";
      if (normalized === "none") return "Not active";
      if (normalized === "inactive") return "Inactive";
      if (normalized === "canceled") return "Canceled";
      return "Active";
    }

    // === RIDE SYNC STRIPE: START membership summary helper ===
    function formatMembershipSummary(planKey, status) {
      const plan = normalizePlanKey(planKey);
      const normalizedStatus = (status || "none").toLowerCase();
      if (plan === "uofa_unlimited") {
        if (normalizedStatus === "pending_verification") {
          return "U of A Unlimited (Pending verification)";
        }
        if (normalizedStatus === "active") {
          return "U of A Unlimited (Active)";
        }
        return "U of A Unlimited";
      }
      if (plan === "nwa_unlimited") {
        if (normalizedStatus === "pending_verification") {
          return "NWA Unlimited (Pending verification)";
        }
        if (normalizedStatus === "active") {
          return "NWA Unlimited (Active)";
        }
        return "NWA Unlimited";
      }
      return "Basic (pay per ride)";
    }
    function isUnlimitedMembershipActive(planKey, status) {
      const plan = normalizePlanKey(planKey);
      const normalizedStatus = (status || "none").toLowerCase();
      if (normalizedStatus !== "active") return false;
      return plan === "uofa_unlimited" || plan === "nwa_unlimited";
    }
    // === RIDE SYNC STRIPE: END membership summary helper ===

    function planRequiresApproval(planKey) {
      return normalizePlanKey(planKey) === "uofa_unlimited";
    }

    function renderMembershipCard(profile) {
      if (!membershipCard) return;
      const plan = normalizePlanKey(profile?.membershipType || profile?.membership || "basic");
      const planCopy = MEMBERSHIP_PLAN_COPY[plan] || MEMBERSHIP_PLAN_COPY.basic;
      const statusLabel = formatMembershipStatusLabel(profile?.membershipStatus);
      const summaryLabel = formatMembershipSummary(plan, profile?.membershipStatus);

      if (membershipStatusText) {
        membershipStatusText.textContent = `Plan: ${planCopy.label}`;
      }
      if (membershipCurrentLabel) {
        membershipCurrentLabel.textContent = summaryLabel;
      }

      if (membershipStatusBadge) {
        const normalizedStatus = (profile?.membershipStatus || "none").toLowerCase();
        const isActive = normalizedStatus === "active";
        const isPending = normalizedStatus === "pending_verification";
        membershipStatusBadge.textContent = statusLabel;
        membershipStatusBadge.classList.toggle("active", isActive);
        membershipStatusBadge.classList.toggle("pending", isPending);
        membershipStatusBadge.classList.toggle(
          "inactive",
          !isActive && !isPending
        );
      }
    }

    async function callApplyMembershipPlan(payload = {}) {
      const user = auth.currentUser;
      if (!user) {
        throw new Error("Log in to manage your membership.");
      }
      try {
        const response = await applyMembershipPlanFn(payload || {});
        return response?.data || { status: "updated" };
      } catch (err) {
        throw handleCallableError(
          "applyMembershipPlan",
          err,
          "Unable to update membership right now. Try again."
        );
      }
    }

    function updateSyncButtonLabel() {
      if (!syncButton) return;
      syncButton.disabled = false;
      if (!hasOnlineDrivers) {
        syncButton.textContent = joinMode
          ? "Join Ride (notify drivers)"
          : "Sync destination (notify drivers)";
        return;
      }
      if (joinMode) {
        syncButton.textContent = "Join Ride";
        return;
      }
      syncButton.textContent = "Sync destination";
    }

    function setDriverAvailabilityState(hasDriversOnline) {
      hasOnlineDrivers = !!hasDriversOnline;
      if (driverAvailabilityNotice) {
        driverAvailabilityNotice.textContent = hasOnlineDrivers
          ? "Drivers are online. Tap Sync destination to request a ride."
          : "No drivers are online right now. Tap Sync destination to notify them and we'll queue your ride.";
      }
      updateSyncButtonLabel();
    }

    function isPermissionDeniedError(err) {
      if (!err) return false;
      if (err.code === "permission-denied") {
        return true;
      }
      const message = (err.message || "").toLowerCase();
      return (
        message.includes("missing or insufficient permissions") ||
        message.includes("permission-denied")
      );
    }

    function applyDriverAvailabilityPayload(payload = {}) {
      const onlineIds = Array.isArray(payload.onlineDriverIds)
        ? payload.onlineDriverIds
        : [];
      const busyIds = Array.isArray(payload.busyDriverIds)
        ? payload.busyDriverIds
        : [];
      driverAvailability.onlineIds = new Set(onlineIds);
      driverAvailability.busyDriverIds = new Set(busyIds);
      const onlineCount =
        typeof payload.onlineCount === "number"
          ? payload.onlineCount
          : onlineIds.length;
      driverAvailability.onlineCount = onlineCount;
      const hasDrivers =
        typeof payload.hasOnlineDrivers === "boolean"
          ? payload.hasOnlineDrivers
          : onlineCount > 0;
      setDriverAvailabilityState(hasDrivers);
      updateWaitlistCopy();
      maybeToggleWaitlistPanel();
    }

    async function fetchDriverAvailabilityStatsOnce() {
      if (!getDriverAvailabilityStatsFn) {
        return;
      }
      try {
        const result = await getDriverAvailabilityStatsFn();
        const payload = result?.data || {};
        applyDriverAvailabilityPayload(payload);
      } catch (err) {
        console.warn("driver availability stats fetch error", err);
      }
    }

    function startDriverAvailabilityPolling(immediate = false) {
      if (driverAvailabilityPollTimer) {
        return;
      }
      if (immediate) {
        fetchDriverAvailabilityStatsOnce();
      }
      driverAvailabilityPollTimer = window.setInterval(
        fetchDriverAvailabilityStatsOnce,
        DRIVER_AVAILABILITY_POLL_INTERVAL_MS
      );
    }

    function stopDriverAvailabilityPolling() {
      if (!driverAvailabilityPollTimer) {
        return;
      }
      clearInterval(driverAvailabilityPollTimer);
      driverAvailabilityPollTimer = null;
    }

    function handleDriverAvailabilityPermissionError(err) {
      if (!isPermissionDeniedError(err)) {
        return false;
      }
      startDriverAvailabilityPolling(true);
      return true;
    }

    function subscribeToDriverAvailability() {
      if (driverAvailabilityUnsub) {
        driverAvailabilityUnsub();
        driverAvailabilityUnsub = null;
      }
      try {
        const availabilityQuery = query(
          collection(db, "drivers"),
          where("isOnline", "==", true),
          limit(1)
        );
        driverAvailabilityUnsub = onSnapshot(
          availabilityQuery,
          (snap) => {
            stopDriverAvailabilityPolling();
            setDriverAvailabilityState(!snap.empty);
          },
          (err) => {
            console.error("driver availability watcher error", err);
            driverAvailabilityUnsub = null;
            setDriverAvailabilityState(false);
            const handled = handleDriverAvailabilityPermissionError(err);
            if (!handled && driverAvailabilityNotice) {
              driverAvailabilityNotice.textContent =
                "Can't confirm driver availability right now.";
            }
          }
        );
      } catch (err) {
        console.error("driver availability subscribe error", err);
        setDriverAvailabilityState(false);
        handleDriverAvailabilityPermissionError(err);
      }
    }

    toggleLink.addEventListener("click", () => {
      isSignupMode = !isSignupMode;
      if (isSignupMode) {
        signupFields.style.display = "block";
        authButton.textContent = "Create account";
        toggleLink.textContent = "Already have an account? Log in";
      } else {
        signupFields.style.display = "none";
        authButton.textContent = "Log in";
        toggleLink.textContent = "New here? Create account";
      }
      authError.textContent = "";
    });
      authButton.addEventListener("click", async () => {
        authError.textContent = "";
        const email = emailEl.value.trim();
        const password = passwordEl.value.trim();
        if (!email || !password) {
          authError.textContent = "Email and password required.";
          return;
        }

        try {
          if (isSignupMode) {
            const cred = await createUserWithEmailAndPassword(auth, email, password);
            await saveUserProfile(email);
          } else {
            await signInWithEmailAndPassword(auth, email, password);
          }
        } catch (err) {
          console.error(err);
          authError.textContent = err.message || "Authentication error.";
        }
      });

    logoutButton.addEventListener("click", async () => {
      stopDriverAvailabilityWatchers();
      await signOut(auth);
      currentRideId = null;
      currentRideStatus = null;
      joinMode = false;
      joinTargetRide = null;
      if (currentRideWatcher) {
        currentRideWatcher();
        currentRideWatcher = null;
      }
      if (groupOccupancyUnsub) {
        groupOccupancyUnsub();
        groupOccupancyUnsub = null;
      }
      hideGroupQr();
      clearPoolGroupUI();
      resetTripPlanner();
      joinBanner.style.display = "none";
      ridersSection.style.display = "block";
      showAuthView();
      updateCancelButtonVisibility();
    });

    updateAddStopAvailability();
    renderFareExtraStops();

    if (addStopButton) {
      addStopButton.addEventListener("click", () => {
        addExtraStopField();
      });
    }

    if (destinationEl) {
      destinationEl.addEventListener("input", () => {
        const currentValue = destinationEl.value.trim();
        const lastValue = (lastDestinationPlace?.formatted_address || "").trim();
        if (!currentValue || currentValue !== lastValue) {
          clearDestinationSelection();
        }
      });
    }

    async function uploadFileIfAny(fileInput, path) {
      const file = fileInput.files[0];
      if (!file) return null;
      const storageRef = ref(storage, path);
      await uploadBytes(storageRef, file);
      return await getDownloadURL(storageRef);
    }

    async function tryUploadFileWithGrace(fileInput, path, label) {
      if (!fileInput || !fileInput.files || !fileInput.files.length) {
        return { url: null, error: null, label };
      }
      try {
        const url = await uploadFileIfAny(fileInput, path);
        return { url, error: null, label };
      } catch (err) {
        console.warn(`Upload failed for ${label}`, err);
        return { url: null, error: err, label };
      }
    }

    async function saveUserProfile(email) {
      const activeUser = auth.currentUser;
      if (!activeUser) {
        throw new Error("Log in to update your profile.");
      }
      const profilePayload = {
        fullName: fullNameEl.value.trim(),
        gender: (genderEl.value || "").trim().toLowerCase(),
        phone: phoneEl.value.trim(),
        street: streetEl.value.trim(),
        city: cityEl.value.trim(),
        state: stateEl.value.trim(),
        zip: zipEl.value.trim(),
        isStudent: isStudentEl.value === "true",
        email: email || auth.currentUser?.email || null,
      };

      try {
        profilePayload.profilePicUrl = await uploadFileIfAny(
          profilePicInput,
          `users/${activeUser.uid}/profile.jpg`
        );
        profilePayload.licensePicUrl = await uploadFileIfAny(
          licensePicInput,
          `users/${activeUser.uid}/license.jpg`
        );
        profilePayload.studentIdPicUrl = await uploadFileIfAny(
          studentIdPicInput,
          `users/${activeUser.uid}/studentId.jpg`
        );
      } catch (err) {
        console.warn("Upload error", err);
      }

      await saveUserProfileFn(profilePayload);
    }

    async function loadUserProfile(uid, email) {
      const refDoc = doc(db, "users", uid);
      let snap = await getDoc(refDoc);
      if (!snap.exists()) {
        try {
          await saveUserProfileFn({ email: email || auth.currentUser?.email || null });
          snap = await getDoc(refDoc);
        } catch (err) {
          console.warn("Failed to bootstrap profile", err);
        }
      }
      if (snap.exists()) {
        currentUserProfile = { uid, email, ...snap.data() };
      } else {
        currentUserProfile = {
          uid,
          email,
          membershipType: "basic",
          membershipStatus: "none"
        };
      }

      renderProfile();
    }

    function renderProfile() {
      if (!currentUserProfile) return;
      const p = currentUserProfile;

      const name =
        p.fullName ||
        p.name ||
        p.displayName ||
        (p.email ? p.email.split("@")[0] : "Rider");
      const phone = p.phone || p.phoneNumber || "";

      riderNameEl.textContent = name;
      if (riderEmailDetailEl) {
        riderEmailDetailEl.textContent = p.email || "Not set";
      }

      riderPhoneDetailEl.textContent = phone || "Not set";
      const addressParts = [
        p.street || "",
        [p.city, p.state].filter(Boolean).join(", "),
        p.zip || ""
      ].filter(Boolean);
      riderAddressDetailEl.textContent = addressParts.join(" • ") || "Not set";

      const planKey = normalizePlanKey(p.membershipType || p.membership || "basic");
      const membershipSummary = formatMembershipSummary(planKey, p.membershipStatus);
      riderMembershipDetailEl.textContent = membershipSummary;

      editFullNameEl.value = p.fullName || "";
      editPhoneEl.value = phone || "";
      editStreetEl.value = p.street || "";
      editCityEl.value = p.city || "";
      editStateEl.value = p.state || "";
      editZipEl.value = p.zip || "";
      if (editGenderEl) {
        const g = (p.gender || "").toLowerCase();
        if (g === "male" || g === "female" || g === "other") {
          editGenderEl.value = g;
        } else {
          editGenderEl.value = "";
        }
      }

      const photoUrl = p.profilePicUrl || p.photoURL || null;
      if (photoUrl) {
        avatarEl.style.backgroundImage = `url(${photoUrl})`;
        avatarEl.style.backgroundSize = "cover";
        avatarEl.style.backgroundPosition = "center";
        avatarEl.textContent = "";
      } else {
        avatarEl.style.backgroundImage = "";
        const initials = (name || "RS")
          .split(" ")
          .map((s) => s[0])
          .join("")
          .slice(0, 2)
          .toUpperCase();
        avatarEl.textContent = initials || "RS";
      }

      setMembershipBadge(p);
      renderMembershipCard(p);
      updateSyncButtonLabel();
    }

    editProfileButton.addEventListener("click", () => {
      if (!currentUserProfile) return;
      const isHidden =
        editProfileSection.style.display === "none" ||
        !editProfileSection.style.display;
      editProfileSection.style.display = isHidden ? "block" : "none";
    });

    saveProfileButton.addEventListener("click", async () => {
      profileError.textContent = "";
      profileMessage.textContent = "";
      const user = auth.currentUser;
      if (!user) return;

      const updates = {
        fullName: editFullNameEl.value.trim(),
        phone: editPhoneEl.value.trim(),
        street: editStreetEl.value.trim(),
        city: editCityEl.value.trim(),
        state: editStateEl.value.trim(),
        zip: editZipEl.value.trim(),
        gender: (editGenderEl.value || "").trim().toLowerCase(),
      };
      const uploadDescriptors = [
        {
          input: editProfilePicInput,
          path: `users/${user.uid}/profile.jpg`,
          key: "profilePicUrl",
          label: "profile photo"
        },
        {
          input: editLicensePicInput,
          path: `users/${user.uid}/license.jpg`,
          key: "licensePicUrl",
          label: "driver license"
        },
        {
          input: editStudentIdPicInput,
          path: `users/${user.uid}/studentId.jpg`,
          key: "studentIdPicUrl",
          label: "student ID"
        }
      ];

      const uploadResults = [];
      for (const descriptor of uploadDescriptors) {
        const result = await tryUploadFileWithGrace(
          descriptor.input,
          descriptor.path,
          descriptor.label
        );
        uploadResults.push({ ...result, key: descriptor.key });
        if (result.url) {
          updates[descriptor.key] = result.url;
        }
      }

      const isStudent = !!currentUserProfile?.isStudent;
      if (updates.studentIdPicUrl && isStudent) {
        updates.isStudent = true;
      }

      try {
        await saveUserProfileFn(updates);
        await loadUserProfile(user.uid, user.email);
        editProfileSection.style.display = "none";

        editProfilePicInput.value = "";
        editLicensePicInput.value = "";
        editStudentIdPicInput.value = "";

        const failedUploads = uploadResults
          .filter((item) => item.error)
          .map((item) => item.label);
        if (failedUploads.length) {
          profileMessage.textContent = "Profile updated, but some files could not upload.";
          profileError.textContent = `Skipped: ${failedUploads.join(", ")}`;
        } else {
          profileMessage.textContent = "Profile updated.";
          profileError.textContent = "";
        }
      } catch (err) {
        console.error(err);
        profileError.textContent = "Could not update profile.";
      }
    });

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        stopDriverAvailabilityWatchers();
        currentUserProfile = null;
        loginStatusEl.textContent = "";
        showAuthView();
        return;
      }
      loginStatusEl.textContent = "Logged in";
      await loadUserProfile(user.uid, user.email);
      showRideView();
      subscribeToDriverAvailability();
      initMapOnce();
      startDriverAvailabilityWatchers();

      if (joinRideIdFromUrl && !joinMode) {
        await enterJoinMode(joinRideIdFromUrl);
      }
    });

    function haversineDistanceMiles(lat1, lon1, lat2, lon2) {
      const R = 3958.8;
      const toRad = (v) => (v * Math.PI) / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) *
          Math.cos(toRad(lat2)) *
          Math.sin(dLon / 2) *
          Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function initMapOnce() {
      if (googleMapsLoadFailed) return;
      if (!window.google || !google.maps) return;
      if (map) return;
      map = new google.maps.Map(mapEl, {
        center: { lat: 36.06, lng: -94.16 },
        zoom: 12,
        disableDefaultUI: true
      });
      directionsService = new google.maps.DirectionsService();
      directionsRenderer = new google.maps.DirectionsRenderer({
        map,
        suppressMarkers: true,
        preserveViewport: false
      });

      pickupMarker = new google.maps.Marker({
        map,
        title: "Pickup",
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 7,
          fillColor: "#22c55e",
          fillOpacity: 1,
          strokeColor: "#022c22",
          strokeWeight: 2
        }
      });

      destMarker = new google.maps.Marker({
        map,
        title: "Destination",
        icon: "https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png"
      });

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            currentLocation = {
              lat: pos.coords.latitude,
              lng: pos.coords.longitude
            };
            pickupMarker.setPosition(currentLocation);
            map.setCenter(currentLocation);
            if (destinationLatLng) {
              updateTripPreviewMap();
              updateRouteAndFare();
            }
          },
          (err) => {
            console.warn("Geolocation error", err);
          }
        );
      }

      setupDestinationAutocomplete();
    }

    function setupDestinationAutocomplete() {
      if (googleMapsLoadFailed) return;
      if (!window.google || !google.maps || !google.maps.places) return;
      if (!destAutocomplete && window.google && google.maps.places) {
        destAutocomplete = new google.maps.places.Autocomplete(destinationEl, {
          types: ["geocode"],
          componentRestrictions: { country: "us" }
        });

        destAutocomplete.addListener("place_changed", () => {
          const place = destAutocomplete.getPlace();
          if (!place || !place.geometry || !place.geometry.location) return;

          lastDestinationPlace = place;
          lastDestinationIsFayetteville = isFayettevilleFromPlace(place);

          destinationLatLng = place.geometry.location;

          destMarker.setPosition(destinationLatLng);
          destMarker.setVisible(true);

          updateTripPreviewMap();
          updateRouteAndFare();
        });
      }
    }

    function updateAddStopAvailability() {
      if (!addStopButton) return;
      const isFull = extraStopsState.length >= MAX_EXTRA_STOPS;
      addStopButton.disabled = isFull;
      addStopButton.setAttribute("aria-disabled", isFull ? "true" : "false");
    }

    function renderFareExtraStops() {
      if (!fareExtraStops) return;
      fareExtraStops.innerHTML = "";
      const visibleStops = extraStopsState.filter((stop) =>
        stop.inputEl && stop.inputEl.value.trim()
      );
      if (!visibleStops.length) {
        fareExtraStops.style.display = "none";
        return;
      }
      fareExtraStops.style.display = "block";
      visibleStops.forEach((stop, index) => {
        const row = document.createElement("div");
        row.className = "fare-row";
        const label = document.createElement("div");
        label.className = "fare-label";
        label.textContent = `Extra stop ${index + 1}`;
        const value = document.createElement("div");
        value.className = "fare-value";
        value.textContent = stop.inputEl.value.trim();
        row.appendChild(label);
        row.appendChild(value);
        fareExtraStops.appendChild(row);
      });
    }

    function setupExtraStopAutocomplete(stopEntry) {
      if (!stopEntry || stopEntry.autocomplete) return;
      if (googleMapsLoadFailed) return;
      if (!window.google || !google.maps || !google.maps.places) return;
      stopEntry.autocomplete = new google.maps.places.Autocomplete(stopEntry.inputEl, {
        types: ["geocode"],
        componentRestrictions: { country: "us" }
      });
      stopEntry.autocomplete.addListener("place_changed", () => {
        const place = stopEntry.autocomplete?.getPlace();
        if (!place || !place.geometry || !place.geometry.location) {
          stopEntry.location = null;
          return;
        }
        const literal = latLngToLiteral(place.geometry.location);
        stopEntry.location = literal;
        stopEntry.label =
          place.formatted_address || place.name || stopEntry.inputEl.value.trim();
        stopEntry.inputEl.value = stopEntry.label;
        renderFareExtraStops();
        updateRouteAndFare();
      });
    }

    function addExtraStopField(options = {}) {
      if (!extraStopsContainer) return null;
      if (extraStopsState.length >= MAX_EXTRA_STOPS) return null;
      extraStopIdCounter += 1;
      const stopId = `extra-stop-${extraStopIdCounter}`;
      const wrapper = document.createElement("div");
      wrapper.className = "extra-stop-field";
      wrapper.dataset.stopId = stopId;

      const input = document.createElement("input");
      input.type = "text";
      input.className = "extra-stop-input";
      input.placeholder = "Extra stop address";
      input.setAttribute("aria-label", `Extra stop ${extraStopsState.length + 1}`);

      const removeButton = document.createElement("button");
      removeButton.type = "button";
      removeButton.className = "remove-stop-btn";
      removeButton.setAttribute("aria-label", "Remove stop");
      removeButton.textContent = "x";

      wrapper.appendChild(input);
      wrapper.appendChild(removeButton);
      extraStopsContainer.appendChild(wrapper);

      const stopEntry = {
        id: stopId,
        wrapper,
        inputEl: input,
        removeButton,
        autocomplete: null,
        location: null,
        label: ""
      };
      extraStopsState.push(stopEntry);

      input.addEventListener("input", () => {
        stopEntry.location = null;
        stopEntry.label = input.value.trim();
        renderFareExtraStops();
        updateRouteAndFare();
      });
      removeButton.addEventListener("click", () => removeExtraStop(stopEntry.id));

      setupExtraStopAutocomplete(stopEntry);
      updateAddStopAvailability();
      renderFareExtraStops();

      if (options.focus !== false) {
        setTimeout(() => input.focus(), 0);
      }

      return stopEntry;
    }

    function removeExtraStop(stopId) {
      const targetIndex = extraStopsState.findIndex((stop) => stop.id === stopId);
      if (targetIndex === -1) return;
      const [entry] = extraStopsState.splice(targetIndex, 1);
      if (entry?.wrapper?.parentNode) {
        entry.wrapper.parentNode.removeChild(entry.wrapper);
      }
      if (entry) {
        entry.autocomplete = null;
      }
      updateAddStopAvailability();
      renderFareExtraStops();
      updateRouteAndFare();
    }

    function getExtraStopWaypoints() {
      return extraStopsState
        .map((stop) => stop.location)
        .filter((loc) => isLatLngLiteral(loc));
    }

    function collectExtraStopsForRide() {
      const collected = [];
      extraStopsState.forEach((stop, index) => {
        if (!stop.inputEl) {
          return;
        }
        const label = stop.inputEl.value.trim();
        if (!label) {
          return;
        }
        const literal = latLngToLiteral(stop.location);
        if (!isLatLngLiteral(literal)) {
          throw new Error(
            `Confirm extra stop ${index + 1} by selecting an address from the list.`
          );
        }
        collected.push({
          order: index + 1,
          label,
          location: literal
        });
      });
      return collected;
    }

    function latLngToLiteral(value) {
      if (!value) return null;
      if (typeof value.lat === "function" && typeof value.lng === "function") {
        return { lat: value.lat(), lng: value.lng() };
      }
      if (typeof value.lat === "number" && typeof value.lng === "number") {
        return value;
      }
      return null;
    }

    function isLatLngLiteral(value) {
      return (
        !!value &&
        Number.isFinite(value.lat) &&
        Number.isFinite(value.lng)
      );
    }

    function ensureDestinationPreviewMap() {
      if (googleMapsLoadFailed) return;
      if (!destinationPreviewMapEl || destinationPreviewMap) return;
      if (!window.google || !google.maps) return;
      destinationPreviewMap = new google.maps.Map(destinationPreviewMapEl, {
        center: { lat: 36.06, lng: -94.16 },
        zoom: 13,
        disableDefaultUI: true,
        draggable: false,
        keyboardShortcuts: false,
        gestureHandling: "none",
        mapTypeControl: false,
        clickableIcons: false,
        styles: [
          { featureType: "poi", stylers: [{ visibility: "off" }] },
          { featureType: "transit", stylers: [{ visibility: "off" }] }
        ]
      });

      destinationPreviewPickupMarker = new google.maps.Marker({
        map: destinationPreviewMap,
        title: "Pickup",
        icon: {
          path: google.maps.SymbolPath.CIRCLE,
          scale: 6,
          fillColor: "#22c55e",
          fillOpacity: 1,
          strokeColor: "#022c22",
          strokeWeight: 2
        },
        visible: false
      });

      destinationPreviewDestMarker = new google.maps.Marker({
        map: destinationPreviewMap,
        title: "Destination",
        icon: "https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png",
        visible: false
      });
    }

    function hideTripPreviewMap() {
      if (tripMapPreviewEl) {
        tripMapPreviewEl.classList.remove("has-destination");
        tripMapPreviewEl.setAttribute("aria-hidden", "true");
      }
      if (destinationPreviewPickupMarker) {
        destinationPreviewPickupMarker.setVisible(false);
      }
      if (destinationPreviewDestMarker) {
        destinationPreviewDestMarker.setVisible(false);
      }
      if (destinationPreviewEmptyEl) {
        destinationPreviewEmptyEl.style.opacity = "";
      }
    }

    function updateTripPreviewMap() {
      if (!tripMapPreviewEl || !destinationLatLng) {
        hideTripPreviewMap();
        return;
      }
      if (googleMapsLoadFailed) return;
      if (!window.google || !google.maps) {
        setTimeout(updateTripPreviewMap, 700);
        return;
      }
      ensureDestinationPreviewMap();
      if (!destinationPreviewMap) return;

      const destLiteral = latLngToLiteral(destinationLatLng);
      if (!destLiteral) return;

      destinationPreviewDestMarker.setPosition(destLiteral);
      destinationPreviewDestMarker.setVisible(true);

      const bounds = new google.maps.LatLngBounds();
      bounds.extend(destLiteral);

      if (currentLocation && typeof currentLocation.lat === "number" && typeof currentLocation.lng === "number") {
        destinationPreviewPickupMarker.setPosition(currentLocation);
        destinationPreviewPickupMarker.setVisible(true);
        bounds.extend(currentLocation);
      } else if (destinationPreviewPickupMarker) {
        destinationPreviewPickupMarker.setVisible(false);
      }

      if (destinationPreviewPickupMarker?.getVisible()) {
        destinationPreviewMap.fitBounds(bounds);
      } else {
        destinationPreviewMap.setCenter(destLiteral);
        destinationPreviewMap.setZoom(14);
      }

      tripMapPreviewEl.classList.add("has-destination");
      tripMapPreviewEl.setAttribute("aria-hidden", "false");
    }

    async function updateRouteAndFare() {
      if (googleMapsLoadFailed) return;
      if (!window.google || !google.maps) return;
      profileError.textContent = "";
      if (!currentLocation || !destinationLatLng || !directionsService) {
        return;
      }

      const request = {
        origin: currentLocation,
        destination: destinationLatLng,
        travelMode: google.maps.TravelMode.DRIVING
      };
      const waypointLocations = getExtraStopWaypoints();
      if (waypointLocations.length) {
        request.waypoints = waypointLocations.map((loc) => ({
          location: loc,
          stopover: true
        }));
      }

      directionsService.route(request, (result, status) => {
        if (status !== "OK" || !result?.routes?.length) {
          console.warn("Directions failed", status);
          return;
        }
        directionsRenderer.setDirections(result);

        const legs = result.routes[0].legs || [];
        const totalDurationSec = legs.reduce(
          (sum, leg) => sum + (leg?.duration?.value || 0),
          0
        );
        const totalDistanceMeters = legs.reduce(
          (sum, leg) => sum + (leg?.distance?.value || 0),
          0
        );

        const minutes = totalDurationSec / 60;
        const plan = normalizePlanKey(
          currentUserProfile?.membershipType || currentUserProfile?.membership || "basic"
        );

        let inHomeZone = false;

        if (plan === "uofa_unlimited") {
          inHomeZone = lastDestinationIsFayetteville === true;
        } else if (plan === "nwa_unlimited") {
          if (currentLocation && destinationLatLng) {
            const distFromCenterPickup = haversineDistanceMiles(
              NWA_CENTER.lat, NWA_CENTER.lng,
              currentLocation.lat, currentLocation.lng
            );
            const destLat = destinationLatLng.lat();
            const destLng = destinationLatLng.lng();
            const distFromCenterDest = haversineDistanceMiles(
              NWA_CENTER.lat, NWA_CENTER.lng,
              destLat, destLng
            );
            inHomeZone =
              distFromCenterPickup <= NWA_RADIUS_MILES &&
              distFromCenterDest <= NWA_RADIUS_MILES &&
              waypointLocations.every((loc) => {
                if (!loc) return false;
                return (
                  haversineDistanceMiles(
                    NWA_CENTER.lat,
                    NWA_CENTER.lng,
                    Number(loc.lat),
                    Number(loc.lng)
                  ) <= NWA_RADIUS_MILES
                );
              });
          }
        }

        const fareInfo = computeFareForMembership(plan, minutes, inHomeZone);

        lastRideMetrics = {
          durationMinutes: minutes,
          distanceMeters: totalDistanceMeters,
          inHomeZone,
          fareBreakdown: fareInfo,
          membershipLabel: fareInfo.membershipLabel
        };

        if (fareNotReady) {
          fareNotReady.style.display = "none";
        }
        if (fareReady) {
          fareReady.style.display = "block";
        }
        if (fareTime) {
          fareTime.textContent = `${minutes.toFixed(1)} min`;
        }
        if (fareDistance) {
          fareDistance.textContent = `${(totalDistanceMeters / 1609.34).toFixed(2)} mi`;
        }
        if (fareMembership) {
          fareMembership.textContent = fareInfo.membershipLabel;
        }
        if (fareTotal) {
          fareTotal.textContent = `$${fareInfo.total.toFixed(2)}`;
        }

        updateSyncButtonLabel();
        updateTripPreviewMap();
      });
    }

    function clearDestinationSelection(options = {}) {
      const { resetInput = false } = options;
      lastDestinationPlace = null;
      lastDestinationIsFayetteville = false;
      destinationLatLng = null;
      lastRideMetrics = null;
      hideTripPreviewMap();
      if (resetInput && destinationEl) {
        destinationEl.value = "";
      }
      if (fareReady) {
        fareReady.style.display = "none";
      }
      if (fareNotReady) {
        fareNotReady.style.display = "block";
      }
      fareTime.textContent = "";
      fareDistance.textContent = "";
      fareMembership.textContent = "";
      fareTotal.textContent = "";
      if (destMarker) {
        destMarker.setVisible(false);
      }
      if (directionsRenderer) {
        directionsRenderer.set("directions", null);
      }
    }

    function resetTripPlanner() {
      clearDestinationSelection({ resetInput: true });
      if (numRidersEl) {
        numRidersEl.value = "1";
        numRidersEl.disabled = false;
      }
      [...extraStopsState].forEach((stop) => removeExtraStop(stop.id));
      updateAddStopAvailability();
      renderFareExtraStops();
    }

    function clearPoolGroupUI() {
      poolGroupTitle.style.display = "none";
      poolGroupBox.style.display = "none";
      poolGroupStatus.textContent = "";
      poolGroupList.innerHTML = "";
    }

    function renderPoolGroup(riders) {
      if (!riders || riders.length === 0) {
        poolGroupTitle.style.display = "block";
        poolGroupBox.style.display = "block";
        poolGroupStatus.textContent = "Searching for other U of A riders…";
        poolGroupList.innerHTML = "";
        return;
      }

      poolGroupTitle.style.display = "block";
      poolGroupBox.style.display = "block";
      poolGroupStatus.textContent = `You are pooled with ${riders.length} other U of A rider${riders.length > 1 ? "s" : ""}.`;

      poolGroupList.innerHTML = riders
        .map((r) => {
          const name = r.riderName || "U of A rider";
          const phone = r.riderPhone || "";
          const membership =
            r.membershipType === "uofa_unlimited"
              ? "U of A Unlimited"
              : r.membershipType === "nwa_unlimited"
              ? "NWA Unlimited"
              : "Basic";
          const initials = (name || "RS")
            .split(" ")
            .map((s) => s[0])
            .join("")
            .slice(0, 2)
            .toUpperCase();

          return `
            <div class="fare-row" style="align-items:center; gap:8px;">
              <div style="display:flex; align-items:center; gap:8px;">
                <div style="
                  width:28px;
                  height:28px;
                  border-radius:999px;
                  border:1px solid rgba(148,163,184,0.7);
                  background:#020617;
                  display:flex;
                  align-items:center;
                  justify-content:center;
                  font-size:0.7rem;
                  color:#9ca3af;
                ">
                  ${initials}
                </div>
                <div>
                  <div class="fare-label" style="margin-bottom:1px;">${name}</div>
                  <div class="fare-value" style="font-size:0.7rem;">
                    ${membership}${phone ? " • " + phone : ""}
                  </div>
                </div>
              </div>
            </div>
          `;
        })
        .join("");
    }

    function startPoolGroupWatcher(rideId) {
      clearPoolGroupUI();

      if (activeRideUnsub) {
        activeRideUnsub();
        activeRideUnsub = null;
      }
      if (activeGroupUnsub) {
        activeGroupUnsub();
        activeGroupUnsub = null;
      }

      const rideRef = doc(db, "rideRequests", rideId);
      activeRideUnsub = onSnapshot(rideRef, (snap) => {
        if (!snap.exists()) return;
        const data = snap.data();
        if (data.groupId) {
          subscribeToPoolGroup(data.groupId, rideId);
        }
      });
    }

    function subscribeToPoolGroup(groupId, myRideId) {
      if (activeGroupUnsub) {
        activeGroupUnsub();
        activeGroupUnsub = null;
      }

      const qRef = query(
        collection(db, "rideRequests"),
        where("groupId", "==", groupId)
      );

      const myGender = normalizePoolGender(currentUserProfile?.gender);

      activeGroupUnsub = onSnapshot(qRef, (qsnap) => {
        const otherRiders = [];

        qsnap.forEach((docSnap) => {
          if (docSnap.id === myRideId) return;
          const data = docSnap.data();
          const otherGender = normalizePoolGender(data.gender);
          if (!myGender || !otherGender || otherGender !== myGender) {
            return;
          }
          otherRiders.push(data);
        });

        renderPoolGroup(otherRiders);
      });
    }

    function computeFareForMembership(plan, minutes, inHomeZone) {
      const {
        BASIC_RATE_PER_MIN,
        BASIC_PLATFORM_FEE,
        BASIC_PROCESSING_FEE_RATE,
        UNLIMITED_OUT_RATE,
        UNLIMITED_PROCESSING_FEE_RATE
      } = FARE_SETTINGS;
      const normalizedPlan = normalizePlanKey(plan);
      const minutesValue = Number(minutes);
      const safeMinutes = Number.isFinite(minutesValue) ? Math.max(0, minutesValue) : 0;

      let membershipLabel = "";
      let rideSubtotal = 0;
      let processingFee = 0;
      let total = 0;

      if (normalizedPlan === "basic") {
        rideSubtotal = safeMinutes * BASIC_RATE_PER_MIN + BASIC_PLATFORM_FEE;
        processingFee = rideSubtotal * BASIC_PROCESSING_FEE_RATE;
        total = rideSubtotal + processingFee;
        membershipLabel = "Basic (pay per ride)";
      } else if (normalizedPlan === "uofa_unlimited") {
        if (inHomeZone) {
          rideSubtotal = 0;
          processingFee = 0;
          total = 0;
          membershipLabel = "U of A Unlimited – in Fayetteville (included)";
        } else {
          rideSubtotal = safeMinutes * UNLIMITED_OUT_RATE;
          processingFee = rideSubtotal * UNLIMITED_PROCESSING_FEE_RATE;
          total = rideSubtotal + processingFee;
          membershipLabel = "U of A Unlimited – out of Fayetteville (extra per-minute)";
        }
      } else if (normalizedPlan === "nwa_unlimited") {
        if (inHomeZone) {
          rideSubtotal = 0;
          processingFee = 0;
          total = 0;
          membershipLabel = "NWA Unlimited – in zone (included)";
        } else {
          rideSubtotal = safeMinutes * UNLIMITED_OUT_RATE;
          processingFee = rideSubtotal * UNLIMITED_PROCESSING_FEE_RATE;
          total = rideSubtotal + processingFee;
          membershipLabel = "NWA Unlimited – out of zone (extra per-minute)";
        }
      } else {
        rideSubtotal = safeMinutes * BASIC_RATE_PER_MIN + BASIC_PLATFORM_FEE;
        processingFee = rideSubtotal * BASIC_PROCESSING_FEE_RATE;
        total = rideSubtotal + processingFee;
        membershipLabel = "Basic (default)";
      }

      return {
        rideSubtotal,
        processingFee,
        total,
        membershipLabel
      };
    }

    async function checkCooldown(userId, plan) {
      const normalizedPlan = normalizePlanKey(plan);
      if (normalizedPlan !== "uofa_unlimited" && normalizedPlan !== "nwa_unlimited") {
        return { allowed: true };
      }

      const coolMinutes = SURGE_MODE ? SURGE_COOLDOWN_MINUTES : UNLIMITED_COOLDOWN_MINUTES;

      const ridesRef = collection(db, "rideRequests");
      const qRef = query(
        ridesRef,
        where("userId", "==", userId),
        orderBy("createdAt", "desc"),
        limit(10)
      );

      const snap = await getDocs(qRef);
      if (snap.empty) return { allowed: true };

      let lastCompleted = null;
      snap.forEach((docSnap) => {
        if (lastCompleted) return;
        const data = docSnap.data();
        if (
          data.status === "completed" &&
          normalizePlanKey(data.membershipType) === normalizedPlan &&
          data.completedAt &&
          typeof data.completedAt.toDate === "function"
        ) {
          lastCompleted = data;
        }
      });

      if (!lastCompleted) return { allowed: true };

      const completedAt = lastCompleted.completedAt.toDate();
      const diffMs = Date.now() - completedAt.getTime();
      const diffMin = diffMs / 60000;
      if (diffMin >= coolMinutes) return { allowed: true };

      return {
        allowed: false,
        remainingMinutes: Math.ceil(coolMinutes - diffMin)
      };
    }

    function formatTripEstimate(data) {
      const estMinutes =
        data && typeof data.estimatedDurationMinutes === "number"
          ? data.estimatedDurationMinutes
          : null;
      if (!estMinutes) return "";
      if (estMinutes < 1) return "Trip under 1 minute.";
      if (estMinutes < 10) return `Estimated trip: ~${estMinutes.toFixed(1)} min.`;
      return `Estimated trip: about ${Math.round(estMinutes)} min.`;
    }

    function normalizeRiderStatus(data) {
      const status = (data?.status || "").toLowerCase();
      if (status === "driver_arrived") return "arrived_at_pickup";
      if (status === "in_progress") return "pickup_code_verified";
      return status;
    }

    function getStateElementByState(state) {
      switch (state) {
        case RIDER_STATES.SEARCHING:
          return riderStateElements.searching;
        case RIDER_STATES.DRIVER_TO_PICKUP:
          return riderStateElements.driverEta;
        case RIDER_STATES.PICKUP_PIN:
          return riderStateElements.pickupPin;
        case RIDER_STATES.IN_TRIP:
          return riderStateElements.inTrip;
        case RIDER_STATES.DROPOFF_PIN:
          return riderStateElements.dropoffPin;
        case RIDER_STATES.RATE_TIP:
          return riderStateElements.rateTip;
        case RIDER_STATES.THANKS:
          return riderStateElements.thanks;
        default:
          return null;
      }
    }

    function setRiderOverlayState(state) {
      riderOverlayState = state;
      if (state === RIDER_STATES.HIDDEN) {
        if (driverInfoStack) {
          driverInfoStack.style.display = "none";
        }
        if (driverMiniMapShell) {
          driverMiniMapShell.style.display = "none";
          setDriverMiniMapStatus("");
        }
        riderOverlay?.classList.remove("active");
        return;
      }

      Object.values(riderStateElements).forEach((el) => el?.classList.remove("active"));
      const target = getStateElementByState(state);
      if (target) {
        target.classList.add("active");
      }

      riderOverlay?.classList.add("active");

      if (driverInfoStack) {
        const needsDriverInfo =
          state === RIDER_STATES.DRIVER_TO_PICKUP || state === RIDER_STATES.IN_TRIP;
        if (needsDriverInfo) {
          const slot =
            state === RIDER_STATES.DRIVER_TO_PICKUP ? driverInfoSlotPickup : driverInfoSlotTrip;
          if (slot) {
            slot.appendChild(driverInfoStack);
            driverInfoStack.style.display = "flex";
            refreshDriverMiniMap();
          }
        } else {
          driverInfoStack.style.display = "none";
          if (driverMiniMapShell) {
            driverMiniMapShell.style.display = "none";
            setDriverMiniMapStatus("");
          }
        }
      }
      maybeToggleWaitlistPanel();
    }

    function setOverlayCopy(title, subtitle) {
      if (riderOverlayTitle) riderOverlayTitle.textContent = title || "RideSync";
      if (riderOverlaySubtitle) riderOverlaySubtitle.textContent = subtitle || "";
    }

    function activateWaitlistPanel() {
      if (!riderWaitlistPanel) return;
      if (!waitlistState.active) {
        waitlistState.active = true;
        if (!waitlistState.startedAt) {
          waitlistState.startedAt = Date.now();
        }
      }
      riderWaitlistPanel.classList.add("active");
      riderWaitlistPanel.setAttribute("aria-hidden", "false");
      if (!waitlistState.timerId) {
        waitlistState.timerId = window.setInterval(tickWaitlistTimer, 1000);
      }
      tickWaitlistTimer();
    }

    function deactivateWaitlistPanel() {
      if (waitlistState.timerId) {
        clearInterval(waitlistState.timerId);
        waitlistState.timerId = null;
      }
      waitlistState.active = false;
      waitlistState.startedAt = null;
      if (riderWaitlistPanel) {
        riderWaitlistPanel.classList.remove("active");
        riderWaitlistPanel.setAttribute("aria-hidden", "true");
      }
      if (riderWaitlistTimerEl) {
        riderWaitlistTimerEl.textContent = "00:00";
      }
      if (riderWaitlistBadgeEl) {
        riderWaitlistBadgeEl.textContent = "";
        riderWaitlistBadgeEl.style.display = "none";
      }
    }

    function tickWaitlistTimer() {
      if (!waitlistState.active || !waitlistState.startedAt || !riderWaitlistTimerEl) {
        return;
      }
      const elapsedSeconds = Math.max(
        0,
        Math.floor((Date.now() - waitlistState.startedAt) / 1000)
      );
      const minutes = String(Math.floor(elapsedSeconds / 60)).padStart(2, "0");
      const seconds = String(elapsedSeconds % 60).padStart(2, "0");
      riderWaitlistTimerEl.textContent = `${minutes}:${seconds}`;
    }

    function getBusyOnlineDriverCount() {
      if (!driverAvailability.onlineIds || !driverAvailability.onlineIds.size) {
        return Math.min(driverAvailability.busyDriverIds.size, driverAvailability.onlineCount);
      }
      let count = 0;
      driverAvailability.busyDriverIds.forEach((driverId) => {
        if (driverAvailability.onlineIds.has(driverId)) {
          count += 1;
        }
      });
      return count;
    }

    function updateWaitlistCopy() {
      if (riderWaitlistStatusEl) {
        const online = driverAvailability.onlineCount;
        const busy = Math.min(getBusyOnlineDriverCount(), online);
        if (online > 0) {
          const label = online === 1 ? "driver is" : "drivers are";
          if (busy >= online) {
            riderWaitlistStatusEl.textContent = `All ${online} online ${label} currently on trips. We’ll connect you as soon as one finishes.`;
          } else {
            const available = online - busy;
            const availLabel = available === 1 ? "driver" : "drivers";
            riderWaitlistStatusEl.textContent = `${available} ${availLabel} getting ready now.`;
          }
        } else {
          riderWaitlistStatusEl.textContent = "Checking for online drivers nearby…";
        }
      }
      if (riderWaitlistBadgeEl) {
        const online = driverAvailability.onlineCount;
        const busy = Math.min(getBusyOnlineDriverCount(), online);
        if (online > 0) {
          riderWaitlistBadgeEl.textContent = `${busy} / ${online} drivers busy`;
          riderWaitlistBadgeEl.style.display = "inline-flex";
        } else {
          riderWaitlistBadgeEl.textContent = "";
          riderWaitlistBadgeEl.style.display = "none";
        }
      }
    }

    function maybeToggleWaitlistPanel() {
      if (!riderWaitlistPanel) return;
      const waitingOnDrivers =
        WAITLIST_RIDE_STATUSES.has(currentRideStatus) ||
        riderOverlayState === RIDER_STATES.SEARCHING;
      const online = driverAvailability.onlineCount;
      const busy = getBusyOnlineDriverCount();
      const available = online - busy;
      const shouldShow = waitingOnDrivers && online > 0 && available <= 0;
      if (shouldShow) {
        if (!waitlistState.startedAt) {
          waitlistState.startedAt = Date.now();
        }
        updateWaitlistCopy();
        activateWaitlistPanel();
      } else if (waitlistState.active) {
        deactivateWaitlistPanel();
      }
    }

    function startDriverAvailabilityWatchers() {
      if (driverOnlineUnsub || driverBusyUnsub) return;
      try {
        const onlineQuery = query(collection(db, "drivers"), where("isOnline", "==", true));
        driverOnlineUnsub = onSnapshot(
          onlineQuery,
          (snap) => {
            stopDriverAvailabilityPolling();
            const ids = new Set();
            snap.forEach((docSnap) => ids.add(docSnap.id));
            driverAvailability.onlineIds = ids;
            driverAvailability.onlineCount = ids.size;
            updateWaitlistCopy();
            maybeToggleWaitlistPanel();
          },
          (err) => {
            console.warn("driver availability watcher error", err);
            driverOnlineUnsub = null;
            handleDriverAvailabilityPermissionError(err);
          }
        );
      } catch (err) {
        console.warn("driver availability query error", err);
        handleDriverAvailabilityPermissionError(err);
      }

      try {
        const busyQuery = query(
          collection(db, "rideRequests"),
          where("status", "in", DRIVER_BUSY_STATUSES)
        );
        driverBusyUnsub = onSnapshot(
          busyQuery,
          (snap) => {
            stopDriverAvailabilityPolling();
            const ids = new Set();
            snap.forEach((docSnap) => {
              const data = docSnap.data();
              const driverId = data?.driverId || data?.assignedDriverId || null;
              if (driverId) {
                ids.add(driverId);
              }
            });
            driverAvailability.busyDriverIds = ids;
            updateWaitlistCopy();
            maybeToggleWaitlistPanel();
          },
          (err) => {
            console.warn("driver busy watcher error", err);
            driverBusyUnsub = null;
            handleDriverAvailabilityPermissionError(err);
          }
        );
      } catch (err) {
        console.warn("driver busy query error", err);
        handleDriverAvailabilityPermissionError(err);
      }
    }

    function stopDriverAvailabilityWatchers() {
      if (driverAvailabilityUnsub) {
        driverAvailabilityUnsub();
        driverAvailabilityUnsub = null;
      }
      setDriverAvailabilityState(false);
      if (driverOnlineUnsub) {
        driverOnlineUnsub();
        driverOnlineUnsub = null;
      }
      if (driverBusyUnsub) {
        driverBusyUnsub();
        driverBusyUnsub = null;
      }
      driverAvailability.onlineCount = 0;
      driverAvailability.onlineIds = new Set();
      driverAvailability.busyDriverIds = new Set();
      deactivateWaitlistPanel();
      stopDriverAvailabilityPolling();
    }

    function updateDriverModules(data) {
      renderDriverIdentity(data);
      renderVehicleSection(data);
      renderLicenseSection(data);
      updateDriverMiniMap(data);
      supportPanel?.classList.remove("active");
    }

    function formatPinValue(value) {
      if (value == null) return "----";
      const str = String(value).trim().toUpperCase();
      if (!str) return "----";
      return str.split("").join(" ");
    }

    function updatePickupPinDisplay(code) {
      if (riderPickupPinValue) {
        riderPickupPinValue.textContent = formatPinValue(code);
      }
    }

    function updateDropoffPinDisplay(code) {
      if (riderDropoffPinValue) {
        riderDropoffPinValue.textContent = formatPinValue(code);
      }
    }

    function hasRiderRating(data) {
      return (
        typeof data?.rating === "number" ||
        typeof data?.riderRating === "number"
      );
    }

    function handleRideSnapshot(rideId, data) {
      latestRideForOverlay = { rideId, data };
      const status = normalizeRiderStatus(data);
      rememberRideCompletionContext(status, data);
      const destinationLabel =
        data.toDestination || data.toAddress || data.destAddress || "Destination";

      // If we were showing the loading screen after syncing, switch back so the overlay can appear.
      showRideView();

      if (status === "canceled_by_driver" || status === "driver_declined") {
        const declineCopy =
          status === "driver_declined"
            ? "Driver declined your ride. Choose a destination to try again."
            : "Driver canceled your ride. You're back on the home screen.";
        returnToHomeAfterRide(declineCopy, true);
        return;
      }

      if (status === "canceled_by_rider") {
        returnToHomeAfterRide("Ride canceled.");
        return;
      }

      switch (status) {
        case "pending_driver":
        case "pending":
        case "pool_searching":
        case "pooled_pending_driver":
          setOverlayCopy("Syncing your ride", "Looking for a verified driver…");
          setRiderOverlayState(RIDER_STATES.SEARCHING);
          break;
        case "driver_assigned":
          updateDriverModules(data);
          setOverlayCopy("Driver en route", destinationLabel);
          setRiderOverlayState(RIDER_STATES.DRIVER_TO_PICKUP);
          break;
        case "arrived_at_pickup":
          updatePickupPinDisplay(getPickupCodeFromRide(data));
          setOverlayCopy("Share your pickup code", "Only give this to your driver.");
          setRiderOverlayState(RIDER_STATES.PICKUP_PIN);
          break;
        case "pickup_code_verified":
          updateDriverModules(data);
          riderTripEtaText.textContent =
            formatTripEstimate(data) || "Sit back and relax.";
          setOverlayCopy("On the way", destinationLabel);
          setRiderOverlayState(RIDER_STATES.IN_TRIP);
          break;
        case "arrived_at_dropoff":
          updateDropoffPinDisplay(getDropoffCodeFromRide(data));
          setOverlayCopy("Share your dropoff code", "Tell your driver to finish the ride.");
          setRiderOverlayState(RIDER_STATES.DROPOFF_PIN);
          break;
        case "dropoff_code_verified":
        case "completed":
          maybePromptRideFareOverlay(rideId, data);
          if (rideRequiresFarePayment(data) > 0) {
            setOverlayCopy(
              "Payment required",
              "Complete the fare overlay to finish this ride."
            );
            setRiderOverlayState(RIDER_STATES.THANKS);
            break;
          }
          if (hasRiderRating(data)) {
            setOverlayCopy("All set", "Thanks for riding with RideSync.");
            setRiderOverlayState(RIDER_STATES.THANKS);
            setTimeout(() => returnToHomeAfterRide("Thanks for riding!"), 1800);
          } else {
            resetRatingForm();
            setOverlayCopy("Rate your ride", "Let us know how it went.");
            setRiderOverlayState(RIDER_STATES.RATE_TIP);
          }
          break;
        default:
          updateDriverModules(data);
          setOverlayCopy("Ride update", destinationLabel);
          setRiderOverlayState(RIDER_STATES.DRIVER_TO_PICKUP);
      }
      maybeToggleWaitlistPanel();
    }

    function resetRatingForm() {
      selectedRating = 0;
      ratingSubmitting = false;
      ratingError.textContent = "";
      riderFeedbackInput.value = "";
      updateRatingButtons();
    }

    function updateRatingButtons() {
      if (!ratingStarsContainer) return;
      ratingStarsContainer.querySelectorAll("button[data-rating]").forEach((btn) => {
        const value = Number(btn.dataset.rating);
        btn.classList.toggle("active", value <= selectedRating);
      });
    }

    function handleRatingStarClick(event) {
      const button = event.target.closest("button[data-rating]");
      if (!button) return;
      const value = Number(button.dataset.rating);
      if (Number.isNaN(value)) return;
      selectedRating = value;
      updateRatingButtons();
    }

    async function submitRideRating() {
      ratingError.textContent = "";
      if (ratingSubmitting) return;
      if (!currentRideId) {
        ratingError.textContent = "Ride not found.";
        return;
      }
      if (selectedRating < 1) {
        ratingError.textContent = "Select a rating.";
        return;
      }
      ratingSubmitting = true;
      submitRatingButton.disabled = true;
      try {
        await submitRideRatingFn({
          rideId: currentRideId,
          rating: selectedRating,
          feedback: riderFeedbackInput.value.trim() || null,
        });
        setOverlayCopy("Thank you!", "Sending your feedback now.");
        setRiderOverlayState(RIDER_STATES.THANKS, { forceReveal: true });
        setTimeout(() => returnToHomeAfterRide("Thanks for riding!"), 2000);
      } catch (err) {
        console.error("submitRating error", err);
        ratingError.textContent = err.message || "Could not submit rating.";
      } finally {
        ratingSubmitting = false;
        submitRatingButton.disabled = false;
      }
    }

    function getPickupCodeFromRide(ride) {
      return (
        ride?.pickupCode ??
        ride?.pickup_code ??
        ride?.pickupPin ??
        ride?.pickupPIN ??
        ride?.boardingCode ??
        null
      );
    }

    function getDropoffCodeFromRide(ride) {
      return (
        ride?.dropoffCode ??
        ride?.dropoff_code ??
        ride?.dropoffPin ??
        ride?.dropoffPIN ??
        ride?.dropoffBoardingCode ??
        null
      );
    }

    function startRideStatusWatcher(rideId) {
      if (currentRideWatcher) {
        currentRideWatcher();
        currentRideWatcher = null;
      }
      const rideRef = doc(db, "rideRequests", rideId);
      currentRideWatcher = onSnapshot(rideRef, (snap) => {
        if (!snap.exists()) return;
        const data = snap.data();
        currentRideStatus = data.status || null;
        updateCancelButtonVisibility();
        handleRideSnapshot(rideId, data);
      });
    }
      
      function hideGroupQr() {
      if (groupQrSection) {
        groupQrSection.style.display = "none";
      }
      if (groupOccupancyLabel) {
        groupOccupancyLabel.textContent = "";
      }
      if (groupOccupancyUnsub) {
        groupOccupancyUnsub();
        groupOccupancyUnsub = null;
      }
    }

    function showGroupQr(rideId) {
      if (!groupQrSection || !groupQrCanvas) return;
      const joinUrl = `${window.location.origin}?join=${encodeURIComponent(rideId)}`;
      if (!groupQr) {
        groupQr = new QRious({
          element: groupQrCanvas,
          size: 140,
          value: joinUrl
        });
      } else {
        groupQr.set({ value: joinUrl });
      }
      groupQrSection.style.display = "block";
      startGroupOccupancyWatcher(rideId);
    }

    function startGroupOccupancyWatcher(rideId) {
      if (groupOccupancyUnsub) {
        groupOccupancyUnsub();
        groupOccupancyUnsub = null;
      }
      const rideRef = doc(db, "rideRequests", rideId);
      groupOccupancyUnsub = onSnapshot(rideRef, (snap) => {
        if (!snap.exists()) return;
        const data = snap.data();
        const cur = data.currentRiderCount || 1;
        const max = data.maxRiders || 1;
        if (groupOccupancyLabel) {
          groupOccupancyLabel.textContent = `Group: ${cur} of ${max} riders.`;
        }
      });
    }

      cancelRideButton.addEventListener("click", async () => {
        cancelError.textContent = "";
        profileMessage.textContent = "";
        if (!currentRideId) {
          cancelError.textContent = "No active ride to cancel.";
          return;
        }

        if (currentRideStatus && !riderCancelableStatuses.has(currentRideStatus)) {
          cancelError.textContent = "Ride can no longer be canceled.";
          return;
        }

        try {
          await cancelRideRequestFn({ rideId: currentRideId });
          returnToHomeAfterRide("Ride canceled, you won't be charged.");
        } catch (err) {
          console.error(err);
          cancelError.textContent = err.message || "Could not cancel ride.";
        }
      });

    // Rider overlay buttons
    if (ratingStarsContainer) {
      ratingStarsContainer.addEventListener("click", handleRatingStarClick);
    }
    if (submitRatingButton) {
      submitRatingButton.addEventListener("click", submitRideRating);
    }
    if (rideTipOptions) {
      rideTipOptions.addEventListener("click", handleRideTipButtonClick);
    }
    if (rideTipCustomInput) {
      rideTipCustomInput.addEventListener("input", handleRideTipCustomInput);
    }
    if (rideCardSubmit) {
      rideCardSubmit.addEventListener("click", handleRideCardSubmit);
    }

    if (cooldownDismissButton) {
      cooldownDismissButton.addEventListener("click", () => {
        hideCooldownOverlay();
      });
    }
    if (cooldownOverlay) {
      cooldownOverlay.addEventListener("click", (event) => {
        if (event.target === cooldownOverlay) {
          hideCooldownOverlay();
        }
      });
    }

    if (supportCallButton) {
      supportCallButton.href = SUPPORT_TEL_LINK;
    }
    if (supportTextButton) {
      supportTextButton.href = SUPPORT_SMS_LINK;
    }

    if (contactDriverBtn) {
      contactDriverBtn.addEventListener("click", () => {
        if (!supportPanel) return;
        supportPanel.classList.add("active");
        supportPanel.scrollIntoView({ behavior: "smooth", block: "start" });
      });
    }

    if (supportBackButton) {
      supportBackButton.addEventListener("click", () => {
        supportPanel?.classList.remove("active");
      });
    }

    // === RIDE SYNC STRIPE: START membership overlay logic ===
    const overlayFocusMemory = new WeakMap();
    const focusableOverlaySelector =
      "[data-default-focus], button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex='-1'])";

    function setMembershipMessage(text) {
      if (membershipCardMessage) {
        membershipCardMessage.textContent = text || "";
      }
    }

    function toggleOverlay(el, show, focusTarget) {
      if (!el) return;
      if (show) {
        if (document.activeElement instanceof HTMLElement) {
          overlayFocusMemory.set(el, document.activeElement);
        } else {
          overlayFocusMemory.delete(el);
        }
        el.classList.add("active");
        el.setAttribute("aria-hidden", "false");
        el.removeAttribute("inert");
        const preferredTarget =
          (focusTarget && typeof focusTarget.focus === "function" && focusTarget) ||
          el.querySelector("[data-default-focus]") ||
          el.querySelector(focusableOverlaySelector);
        if (preferredTarget && typeof preferredTarget.focus === "function") {
          requestAnimationFrame(() => preferredTarget.focus());
        }
      } else {
        el.classList.remove("active");
        el.setAttribute("aria-hidden", "true");
        el.setAttribute("inert", "");
        if (
          el.contains(document.activeElement) &&
          document.activeElement instanceof HTMLElement &&
          typeof document.activeElement.blur === "function"
        ) {
          document.activeElement.blur();
        }
        const previousFocus = overlayFocusMemory.get(el);
        overlayFocusMemory.delete(el);
        if (previousFocus && typeof previousFocus.focus === "function") {
          previousFocus.focus();
        }
      }
    }

    function openPaymentStatusOverlay(title, message) {
      if (!paymentStatusOverlay) return;
      if (paymentStatusTitle) {
        paymentStatusTitle.textContent = title || "";
      }
      if (paymentStatusMessage) {
        paymentStatusMessage.textContent = message || "";
      }
      toggleOverlay(paymentStatusOverlay, true, paymentStatusBackButton);
    }

    function closePaymentStatusOverlay() {
      toggleOverlay(paymentStatusOverlay, false);
    }

    function updateRideFareStatus(message, isError = false) {
      if (!rideFareStatus) return;
      rideFareStatus.textContent = message || "";
      rideFareStatus.classList.toggle("error", Boolean(message) && isError);
    }

    function renderRideFareDetails(summary = {}) {
      if (!rideFareDetails) return;
      const parts = [];
      if (summary.pickup) {
        parts.push(`Pickup: ${summary.pickup}`);
      }
      if (summary.dropoff) {
        parts.push(`Dropoff: ${summary.dropoff}`);
      }
      if (Number.isFinite(summary.distanceMiles)) {
        parts.push(`Distance: ${summary.distanceMiles.toFixed(2)} miles`);
      }
      if (Number.isFinite(summary.durationMinutes)) {
        parts.push(`Duration: ${Math.round(summary.durationMinutes)} min`);
      }
      rideFareDetails.textContent = parts.join(" • ");
    }

    function resetRideTipUi() {
      if (rideTipOptions) {
        rideTipOptions.querySelectorAll(".tip-button").forEach((btn, idx) => {
          btn.classList.toggle("active", idx === 0);
        });
      }
      if (rideTipCustomInput) {
        rideTipCustomInput.value = "";
        rideTipCustomInput.style.display = "none";
      }
      ridePaymentState.tipAmountCents = 0;
    }

    function updateRidePaymentTotalsDisplay() {
      ridePaymentState.totalAmountCents = Math.max(
        0,
        ridePaymentState.baseAmountCents + ridePaymentState.tipAmountCents
      );
      if (rideFareBaseAmount) {
        rideFareBaseAmount.textContent = formatCurrencyFromCents(
          ridePaymentState.baseAmountCents,
          "usd"
        );
      }
      if (rideFareTipAmount) {
        rideFareTipAmount.textContent = formatCurrencyFromCents(
          ridePaymentState.tipAmountCents,
          "usd"
        );
      }
      if (rideFareAmount) {
        rideFareAmount.textContent = formatCurrencyFromCents(
          ridePaymentState.totalAmountCents,
          "usd"
        );
      }
      if (rideCardSubmit) {
        rideCardSubmit.textContent =
          ridePaymentState.totalAmountCents > 0
            ? `Pay ${formatCurrencyFromCents(
                ridePaymentState.totalAmountCents,
                "usd"
              )} with card`
            : "Pay with card";
        if (ridePaymentState.totalAmountCents <= 0) {
          rideCardSubmit.disabled = true;
        }
      }
    }

    function scheduleRidePaymentIntentRefresh() {
      if (!ridePaymentState.showing) return;
      if (rideTipRefreshTimer) {
        clearTimeout(rideTipRefreshTimer);
        rideTipRefreshTimer = null;
      }
      rideTipRefreshTimer = setTimeout(() => {
        rideTipRefreshTimer = null;
        refreshRidePaymentIntent();
      }, 350);
    }

    function handleRideTipButtonClick(event) {
      if (!rideTipOptions) return;
      const button = event.target.closest(".tip-button");
      if (!button) return;
      rideTipOptions.querySelectorAll(".tip-button").forEach((btn) => {
        btn.classList.toggle("active", btn === button);
      });
      const value = button.dataset.tip;
      if (value === "custom") {
        if (rideTipCustomInput) {
          rideTipCustomInput.style.display = "block";
          rideTipCustomInput.focus();
          rideTipCustomInput.value = "";
        }
        ridePaymentState.tipAmountCents = 0;
        updateRidePaymentTotalsDisplay();
        scheduleRidePaymentIntentRefresh();
        return;
      }
      if (rideTipCustomInput) {
        rideTipCustomInput.style.display = "none";
        rideTipCustomInput.value = "";
      }
      const dollars = Number(value);
      ridePaymentState.tipAmountCents = Number.isFinite(dollars)
        ? Math.max(0, Math.round(dollars * 100))
        : 0;
      updateRidePaymentTotalsDisplay();
      scheduleRidePaymentIntentRefresh();
    }

    function handleRideTipCustomInput() {
      if (!rideTipCustomInput) return;
      const dollars = Number(rideTipCustomInput.value);
      if (!Number.isFinite(dollars) || dollars < 0) {
        ridePaymentState.tipAmountCents = 0;
      } else {
        ridePaymentState.tipAmountCents = Math.round(dollars * 100);
      }
      updateRidePaymentTotalsDisplay();
      scheduleRidePaymentIntentRefresh();
    }

    function teardownRidePaymentResources() {
      if (ridePaymentState.paymentRequestElement) {
        ridePaymentState.paymentRequestElement.unmount();
        ridePaymentState.paymentRequestElement = null;
      }
      ridePaymentState.paymentRequest = null;
      ridePaymentState.paymentRequestElementsInstance = null;
      if (rideFarePaymentRequest) {
        rideFarePaymentRequest.innerHTML = "";
      }
      if (ridePaymentState.paymentElement) {
        ridePaymentState.paymentElement.unmount();
        ridePaymentState.paymentElement = null;
      }
      ridePaymentState.paymentElements = null;
      if (rideCardElement) {
        rideCardElement.innerHTML = "";
      }
      if (rideCardSubmit) {
        rideCardSubmit.disabled = true;
      }
      if (rideCardMessage) {
        rideCardMessage.textContent = "";
      }
    }

    function resetRidePaymentState() {
      teardownRidePaymentResources();
      ridePaymentState.rideId = null;
      ridePaymentState.baseAmountCents = 0;
      ridePaymentState.tipAmountCents = 0;
      ridePaymentState.totalAmountCents = 0;
      ridePaymentState.clientSecret = null;
      ridePaymentState.summary = null;
      ridePaymentState.processing = false;
      ridePaymentState.completed = false;
      ridePaymentState.showing = false;
      ridePaymentState.livemode = null;
      ridePaymentState.intentRequestId = 0;
      ridePaymentState.clientSecretContext = null;
      if (rideTipRefreshTimer) {
        clearTimeout(rideTipRefreshTimer);
        rideTipRefreshTimer = null;
      }
      resetRideTipUi();
      updateRidePaymentTotalsDisplay();
      if (rideFareUnavailable) {
        rideFareUnavailable.textContent = "";
      }
      updateRideFareStatus("");
      if (rideFareClose) {
        rideFareClose.disabled = true;
      }
    }

    function closeRideFareOverlay(force = false) {
      if (!rideFareOverlay) return;
      const hasActivePayment =
        Boolean(ridePaymentState.paymentRequest) ||
        Boolean(ridePaymentState.paymentElement);
      if (!force && !ridePaymentState.completed && hasActivePayment) {
        return;
      }
      toggleOverlay(rideFareOverlay, false);
      ridePaymentState.showing = false;
      if (force || ridePaymentState.completed) {
        resetRidePaymentState();
      }
    }

    async function openRideFareOverlay({ rideId, amountCents, summary }) {
      if (!rideFareOverlay) return;
      resetRidePaymentState();
      ridePaymentState.rideId = rideId || null;
      ridePaymentState.baseAmountCents = Math.max(0, Math.round(amountCents));
      ridePaymentState.summary = summary || null;
      ridePaymentState.completed = false;
      ridePaymentState.processing = true;
      ridePaymentState.clientSecret = null;
      ridePaymentState.showing = true;
      if (rideFareSubtitle) {
        rideFareSubtitle.textContent = summary?.dropoff
          ? `Destination: ${summary.dropoff}`
          : "Complete your fare to finish this ride.";
      }
      renderRideFareDetails(summary);
      resetRideTipUi();
      updateRidePaymentTotalsDisplay();
      updateRideFareStatus("Preparing payment options…", false);
      if (rideFareUnavailable) {
        rideFareUnavailable.textContent = "";
      }
      if (rideFareClose) {
        rideFareClose.disabled = true;
      }
      toggleOverlay(rideFareOverlay, true, rideFareClose);
      await refreshRidePaymentIntent();
      ridePaymentState.processing = false;
    }

    async function createRidePaymentClientSecret({
      rideId,
      amountCents,
      tipAmountCents,
    }) {
      try {
        const response = await createRidePaymentIntentFn({
          amount: Math.round(amountCents),
          currency: "usd",
          rideId: rideId || null,
          tipAmountCents: Math.max(0, Math.round(tipAmountCents || 0)),
        });
        const clientSecret = response?.data?.clientSecret;
        if (typeof clientSecret !== "string" || !clientSecret) {
          throw new Error("Unable to start ride payment.");
        }
        return {
          clientSecret,
          livemode: response?.data?.livemode ?? null,
        };
      } catch (err) {
        throw handleCallableError(
          "createRidePaymentIntent",
          err,
          PAYMENT_ERROR_FALLBACK
        );
      }
    }

    async function refreshRidePaymentIntent() {
      if (!ridePaymentState.rideId) {
        updateRideFareStatus("Ride reference missing for payment.", true);
        return;
      }
      if (!ridePaymentState.totalAmountCents) {
        updateRideFareStatus("Fare total unavailable. Contact support.", true);
        return;
      }
      ridePaymentState.intentRequestId += 1;
      const currentRequestId = ridePaymentState.intentRequestId;
      ridePaymentState.processing = true;
      teardownRidePaymentResources();
      updateRideFareStatus("Preparing payment options…", false);
      try {
        const { clientSecret, livemode } = await createRidePaymentClientSecret({
          rideId: ridePaymentState.rideId,
          amountCents: ridePaymentState.totalAmountCents,
          tipAmountCents: ridePaymentState.tipAmountCents,
        });
        if (ridePaymentState.intentRequestId !== currentRequestId) {
          return;
        }
        ridePaymentState.clientSecret = clientSecret;
        ridePaymentState.livemode = livemode;
        ridePaymentState.clientSecretContext = {
          clientSecret,
          livemode,
          totalAmountCents: ridePaymentState.totalAmountCents,
          baseAmountCents: ridePaymentState.baseAmountCents,
          tipAmountCents: ridePaymentState.tipAmountCents,
        };
        await mountRidePaymentElement(clientSecret, livemode);
        await mountRidePaymentRequestButton(
          clientSecret,
          ridePaymentState.totalAmountCents,
          livemode
        );
        if (!ridePaymentState.paymentRequest && rideFareUnavailable) {
          rideFareUnavailable.textContent =
            "Apple Pay / Google Pay are unavailable on this device.";
        }
        updateRideFareStatus("Choose a payment method to finish.", false);
        if (rideFareClose) {
          rideFareClose.disabled = false;
        }
      } catch (err) {
        if (ridePaymentState.intentRequestId !== currentRequestId) {
          return;
        }
        updateRideFareStatus(err?.message || PAYMENT_ERROR_FALLBACK, true);
        if (rideFareUnavailable) {
          rideFareUnavailable.textContent =
            "Contact RideSync support if you need help completing this payment.";
        }
        if (rideCardMessage) {
          rideCardMessage.textContent = err?.message || "";
        }
      } finally {
        if (ridePaymentState.intentRequestId === currentRequestId) {
          ridePaymentState.processing = false;
        }
      }
    }

    async function mountRidePaymentRequestButton(clientSecret, amountCents, livemode) {
      if (!rideFarePaymentRequest) return;
      const stripe = await ensureStripeInstance(livemode);
      const paymentRequest = stripe.paymentRequest({
        country: "US",
        currency: "usd",
        total: {
          label: "RideSync Fare",
          amount: Math.round(amountCents),
        },
        requestPayerName: true,
        requestPayerEmail: true,
      });
      const canPay = await paymentRequest.canMakePayment();
      if (!canPay) {
        if (rideFareUnavailable) {
          rideFareUnavailable.textContent =
            "Apple Pay / Google Pay is not available on this device.";
        }
        if (rideFareClose) {
          rideFareClose.disabled = false;
        }
        return;
      }
      const elements = stripe.elements();
      const buttonElement = elements.create("paymentRequestButton", {
        paymentRequest,
        style: {
          paymentRequestButton: {
            theme: "dark",
            height: "48px",
          },
        },
      });
      paymentRequest.on("paymentmethod", (event) => {
        handleRidePaymentRequest(event);
      });
      rideFarePaymentRequest.innerHTML = "";
      buttonElement.mount(rideFarePaymentRequest);
      ridePaymentState.paymentRequest = paymentRequest;
      ridePaymentState.paymentRequestElement = buttonElement;
      ridePaymentState.paymentRequestElementsInstance = elements;
      if (rideFareClose) {
        rideFareClose.disabled = false;
      }
    }

    async function mountRidePaymentElement(clientSecret, livemode) {
      if (!rideCardElement || !clientSecret) {
        return;
      }
      if (ridePaymentState.paymentElement) {
        ridePaymentState.paymentElement.unmount();
        ridePaymentState.paymentElement = null;
      }
      const stripe = await ensureStripeInstance(livemode);
      const elements = stripe.elements({ clientSecret });
      const paymentElement = elements.create("payment");
      rideCardElement.innerHTML = "";
      paymentElement.mount(rideCardElement);
      ridePaymentState.paymentElements = elements;
      ridePaymentState.paymentElement = paymentElement;
      if (rideCardSubmit) {
        rideCardSubmit.disabled = false;
      }
      if (rideCardMessage) {
        rideCardMessage.textContent = "";
      }
    }

    function buildRideFareSummary(ride = {}) {
      const pickupCandidate =
        ride.pickupAddress ||
        ride.fromAddress ||
        ride.pickupLabel ||
        ride.pickupDescription ||
        ride.fromLocationLabel ||
        "";
      const dropoffCandidate =
        ride.toDestination ||
        ride.dropoffAddress ||
        ride.destination ||
        ride.dropoffDescription ||
        "";
      const distanceMeters =
        ride.distanceMeters ||
        ride.metrics?.distanceMeters ||
        ride.rideMetrics?.distanceMeters;
      const durationMinutes =
        ride.durationMinutes ||
        ride.estimatedDurationMinutes ||
        ride.metrics?.durationMinutes ||
        ride.rideMetrics?.durationMinutes;
      return {
        pickup: pickupCandidate ? sanitizeDestinationLabel(pickupCandidate) : "",
        dropoff: dropoffCandidate ? sanitizeDestinationLabel(dropoffCandidate) : "",
        distanceMiles: Number.isFinite(distanceMeters)
          ? distanceMeters * METERS_TO_MILES
          : null,
        durationMinutes: Number.isFinite(durationMinutes)
          ? durationMinutes
          : null,
      };
    }

    const PAYMENT_STATUSES_REQUIRING_COLLECTION = new Set([
      "fare_due",
      "preauthorized",
      "pending", // basic plan rides start as pending until paid
      "pending_payment",
    ]);

    function rideRequiresFarePayment(rideData = {}) {
      const status = (rideData.paymentStatus || "").toLowerCase();
      if (!PAYMENT_STATUSES_REQUIRING_COLLECTION.has(status)) {
        return 0;
      }
      const amountCents = resolveRideCheckoutAmountCents(rideData);
      if (!amountCents || amountCents <= 0) {
        return 0;
      }
      return amountCents;
    }

    async function handleRidePaymentRequest(event) {
      const paymentIntentContext = snapshotActivePaymentIntentContext();
      if (!paymentIntentContext) {
        event.complete("fail");
        updateRideFareStatus("Payment is still being prepared. Try again.", true);
        return;
      }
      ridePaymentState.processing = true;
      updateRideFareStatus("Processing payment…", false);
      try {
        const stripe = await ensureStripeInstance(
          paymentIntentContext.livemode ?? ridePaymentState.livemode
        );
        const { error, paymentIntent } = await stripe.confirmCardPayment(
          paymentIntentContext.clientSecret,
          {
            payment_method: event.paymentMethod.id,
          },
          { handleActions: false }
        );
        if (error) {
          event.complete("fail");
          updateRideFareStatus(error.message || PAYMENT_ERROR_FALLBACK, true);
          ridePaymentState.processing = false;
          return;
        }
        event.complete("success");
        if (paymentIntent && paymentIntent.status === "requires_action") {
          const { error: actionError } = await stripe.confirmCardPayment(
            paymentIntentContext.clientSecret
          );
          if (actionError) {
            updateRideFareStatus(actionError.message || PAYMENT_ERROR_FALLBACK, true);
            ridePaymentState.processing = false;
            return;
          }
        }
        await markRideFarePaid(paymentIntent?.id || null);
        ridePaymentState.completed = true;
        ridePaymentState.processing = false;
        updateRideFareStatus(
          "Payment complete. Thank you for riding with RideSync!",
          false
        );
        if (rideFareClose) {
          rideFareClose.disabled = false;
        }
        setTimeout(() => {
          closeRideFareOverlay();
        }, 1800);
      } catch (err) {
        event.complete("fail");
        ridePaymentState.processing = false;
        updateRideFareStatus(err?.message || PAYMENT_ERROR_FALLBACK, true);
      }
    }

    async function handleRideCardSubmit() {
      const paymentElementsInstance = ridePaymentState.paymentElements;
      if (!paymentElementsInstance) {
        if (rideCardMessage) {
          rideCardMessage.textContent =
            "Payment is still being prepared. Please try again.";
        }
        return;
      }
      const paymentIntentContext = snapshotActivePaymentIntentContext();
      if (!paymentIntentContext) {
        if (rideCardMessage) {
          rideCardMessage.textContent =
            "Payment is still being prepared. Please try again.";
        }
        return;
      }
      if (rideCardMessage) {
        rideCardMessage.textContent = "";
      }
      if (rideCardSubmit) {
        rideCardSubmit.disabled = true;
      }
      ridePaymentState.processing = true;
      updateRideFareStatus("Processing card payment…", false);
      try {
        const stripe = await ensureStripeInstance(
          paymentIntentContext.livemode ?? ridePaymentState.livemode
        );
        const result = await stripe.confirmPayment({
          elements: paymentElementsInstance,
          clientSecret: paymentIntentContext.clientSecret,
          redirect: "if_required",
        });
        if (result.error) {
          throw new Error(result.error.message || PAYMENT_ERROR_FALLBACK);
        }
        if (!result.paymentIntent || result.paymentIntent.status !== "succeeded") {
          throw new Error("Payment did not complete.");
        }
        await markRideFarePaid(result.paymentIntent.id);
        ridePaymentState.completed = true;
        updateRideFareStatus(
          "Payment complete. Thank you for riding with RideSync!",
          false
        );
        setTimeout(() => {
          closeRideFareOverlay();
        }, 1800);
      } catch (err) {
        updateRideFareStatus(err?.message || PAYMENT_ERROR_FALLBACK, true);
        if (rideCardMessage) {
          rideCardMessage.textContent = err?.message || PAYMENT_ERROR_FALLBACK;
        }
      } finally {
        ridePaymentState.processing = false;
        if (rideCardSubmit && !ridePaymentState.completed) {
          rideCardSubmit.disabled = false;
        }
      }
    }

    function snapshotActivePaymentIntentContext() {
      const context = ridePaymentState.clientSecretContext;
      if (!context || !context.clientSecret) {
        return null;
      }
      return {
        clientSecret: context.clientSecret,
        livemode: context.livemode ?? null,
        totalAmountCents: context.totalAmountCents,
        baseAmountCents: context.baseAmountCents,
        tipAmountCents: context.tipAmountCents,
      };
    }

    async function markRideFarePaid(paymentIntentId) {
      if (!ridePaymentState.rideId) {
        return;
      }
      try {
        await confirmRidePaymentIntentFn({
          rideId: ridePaymentState.rideId,
          paymentIntentId,
        });
        profileMessage.textContent = "Payment received. Thanks for riding!";
      } catch (err) {
        console.warn("Failed to update ride payment status", err);
        showErrorBanner(err.message || PAYMENT_ERROR_FALLBACK);
      }
    }

    function maybePromptRideFareOverlay(rideId, rideData) {
      const amountCents = rideRequiresFarePayment(rideData);
      if (!amountCents) {
        if (ridePaymentState.showing && ridePaymentState.rideId === rideId) {
          closeRideFareOverlay(true);
        }
        return;
      }
      if (ridePaymentState.processing) {
        return;
      }
      if (ridePaymentState.showing && ridePaymentState.rideId === rideId) {
        return;
      }
      const summary = buildRideFareSummary(rideData);
      openRideFareOverlay({
        rideId,
        amountCents,
        summary,
      }).catch((err) => {
        console.error("Ride payment overlay error", err);
      });
    }

    async function showPaymentResultFromLocation() {
      // Ride fares now complete entirely inside the PWA; no redirect handling required.
    }

    function setMembershipTermsAcknowledged(value) {
      membershipTermsAcknowledged = Boolean(value);
      if (!membershipTermsAcknowledged) {
        membershipTermsScrollComplete = false;
      }
      updateMembershipTermsButtonState();
    }

    function updateMembershipTermsButtonState() {
      if (!membershipTermsButton) return;
      const hasPlan = Boolean(pendingMembershipPlanId);
      const nextLabel = membershipTermsAcknowledged ? "Accept & Pay" : "Terms of Agreement";
      membershipTermsButton.textContent = nextLabel;
      membershipTermsButton.disabled = !hasPlan || membershipTermsProcessing;
      membershipTermsButton.classList.toggle("btn-success", membershipTermsAcknowledged);
      membershipTermsButton.classList.toggle("btn-danger", !membershipTermsAcknowledged);
    }

    function resetMembershipTermsScrollState() {
      membershipTermsScrollComplete = false;
      if (membershipTermsCheckbox) {
        membershipTermsCheckbox.checked = false;
        membershipTermsCheckbox.disabled = true;
      }
      if (membershipTermsContent) {
        membershipTermsContent.scrollTop = 0;
      }
    }

    function maybeUnlockMembershipTermsCheckbox() {
      if (!membershipTermsContent || !membershipTermsCheckbox) return;
      if (membershipTermsScrollComplete) return;
      const remaining =
        membershipTermsContent.scrollHeight -
        membershipTermsContent.scrollTop -
        membershipTermsContent.clientHeight;
      if (remaining <= 4 || membershipTermsContent.scrollHeight <= membershipTermsContent.clientHeight + 1) {
        membershipTermsScrollComplete = true;
        membershipTermsCheckbox.disabled = false;
      }
    }

    updateMembershipTermsButtonState();

    function resetMembershipSelectionState() {
      membershipSelectionOptions?.forEach?.((node) => {
        node.classList.remove("active");
      });
      pendingMembershipPlanId = null;
      if (membershipSelectionError) {
        membershipSelectionError.textContent = "";
      }
      if (membershipTermsError) {
        membershipTermsError.textContent = "";
      }
      setMembershipTermsAcknowledged(false);
    }

    function openMembershipSelectionOverlayUI() {
      if (!auth.currentUser) {
        setMembershipMessage("Log in to manage your membership.");
        return;
      }
      resetMembershipSelectionState();
      updateMembershipTermsButtonState();
      toggleOverlay(membershipSelectionOverlay, true, membershipSelectionClose);
    }

    function closeMembershipSelectionOverlayUI() {
      toggleOverlay(membershipSelectionOverlay, false);
      if (membershipSelectionError) {
        membershipSelectionError.textContent = "";
      }
    }

    function selectMembershipPlan(planId) {
      pendingMembershipPlanId = planId;
      membershipSelectionOptions?.forEach?.((node) => {
        const isActive = node.dataset.membershipOption === planId;
        node.classList.toggle("active", isActive);
      });
      if (membershipSelectionError) {
        membershipSelectionError.textContent = "";
      }
      if (membershipTermsError) {
        membershipTermsError.textContent = "";
      }
      setMembershipTermsAcknowledged(false);
    }

    function openMembershipTermsOverlayUI() {
      if (!pendingMembershipPlanId) return;
      resetMembershipTermsScrollState();
      if (membershipTermsError) {
        membershipTermsError.textContent = "";
      }
      toggleOverlay(membershipTermsOverlay, true, membershipTermsClose);
      requestAnimationFrame(() => {
        maybeUnlockMembershipTermsCheckbox();
      });
    }

    function closeMembershipTermsOverlayUI() {
      toggleOverlay(membershipTermsOverlay, false);
    }

    function handleMembershipTermsScroll() {
      maybeUnlockMembershipTermsCheckbox();
    }

    function handleMembershipTermsCheckboxChange(event) {
      if (!event?.target?.checked) {
        return;
      }
      setMembershipTermsAcknowledged(true);
      if (membershipTermsError) {
        membershipTermsError.textContent = "";
      }
      closeMembershipTermsOverlayUI();
      requestAnimationFrame(() => {
        membershipTermsButton?.focus?.();
      });
    }

    async function recordMembershipTermsAcceptance() {
      // Record that the user has viewed and accepted the membership terms.
      const user = auth.currentUser;
      if (!user) {
        throw new Error("Log in to continue.");
      }
      await saveUserProfileFn({
        email: user.email || null,
        membershipTermsAccepted: true,
        membershipTermsVersion: "v1"
      });
    }

    async function startMembershipPaymentFlow(planId) {
      if (!STRIPE_ENABLED) {
        throw new Error("Stripe payments are not available right now.");
      }
      let data;
      try {
        const response = await createMembershipPaymentIntentFn({ plan: planId });
        data = response?.data || {};
      } catch (err) {
        throw handleCallableError("createMembershipPaymentIntent", err);
      }
      const clientSecret = resolveClientSecret(data);
      if (!clientSecret || !data.paymentIntentId) {
        throw new Error("Unable to start Stripe payment.");
      }
      const planLabel = formatMembershipPlanLabel(planId);
      const amountLabel = formatCurrencyFromCents(
        data.amountCents,
        data.currency
      );
      const paymentLivemode =
        typeof data.livemode === "boolean"
          ? data.livemode
          : typeof data.liveMode === "boolean"
          ? data.liveMode
          : null;
      await openPaymentOverlay({
        title: `Activate ${planLabel}`,
        subtitle: `Pay ${amountLabel} to activate this membership.`,
        confirmLabel: `Pay ${amountLabel}`,
        clientSecret,
        livemode: paymentLivemode,
        context: {
          type: "membership",
          plan: planId,
          paymentIntentId: data.paymentIntentId,
        },
      });
      setMembershipMessage("Complete the payment to finish upgrading.");
    }

    async function startMembershipSubscriptionFlow(planId) {
      if (!STRIPE_ENABLED) {
        throw new Error("Stripe payments are not available right now.");
      }
      let data;
      try {
        const response = await createMembershipSubscriptionIntentFn({ planId });
        data = response?.data || {};
      } catch (err) {
        throw handleCallableError("createMembershipSubscriptionIntent", err);
      }
      const clientSecret = resolveClientSecret(data);
      if (!clientSecret || !data.subscriptionId) {
        throw new Error("Unable to start Stripe subscription.");
      }
      const planLabel =
        MEMBERSHIP_PLAN_COPY[planId]?.label || formatMembershipPlanLabel(planId);
      const paymentLivemode =
        typeof data.livemode === "boolean"
          ? data.livemode
          : typeof data.liveMode === "boolean"
          ? data.liveMode
          : null;
      await openPaymentOverlay({
        title: `Activate ${planLabel}`,
        subtitle: "Enter payment details to start your subscription.",
        confirmLabel: "Start subscription",
        clientSecret,
        livemode: paymentLivemode,
        context: {
          type: "membershipSubscription",
          subscriptionId: data.subscriptionId,
          planId,
        },
      });
      setMembershipMessage("Complete the payment to finish upgrading.");
    }

    async function handleMembershipAcceptAndPay() {
      if (!pendingMembershipPlanId) {
        if (membershipSelectionError) {
          membershipSelectionError.textContent = "Choose a membership first.";
        }
        return;
      }
      if (!membershipTermsAcknowledged) {
        openMembershipTermsOverlayUI();
        return;
      }
      if (membershipTermsProcessing) return;
      membershipTermsProcessing = true;
      updateMembershipTermsButtonState();
      if (membershipTermsError) {
        membershipTermsError.textContent = "";
      }
      try {
        const planId = pendingMembershipPlanId;
        await recordMembershipTermsAcceptance();
        const planMode = getMembershipPlanMode(planId);
        if (planMode === "subscription") {
          await startMembershipSubscriptionFlow(planId);
        } else if (planMode === "payment") {
          await startMembershipPaymentFlow(planId);
        } else {
          await callApplyMembershipPlan({ plan: planId });
          setMembershipMessage("Membership updated!");
          const user = auth.currentUser;
          if (user) {
            await loadUserProfile(user.uid, user.email);
          }
        }
        closeMembershipSelectionOverlayUI();
      } catch (err) {
        console.error("Membership accept & pay", err);
        if (membershipTermsError) {
          membershipTermsError.textContent =
            err.message || "Could not continue to payment.";
        }
      } finally {
        membershipTermsProcessing = false;
        updateMembershipTermsButtonState();
      }
    }


    membershipChangeButton?.addEventListener("click", () => {
      openMembershipSelectionOverlayUI();
    });
    membershipSelectionClose?.addEventListener("click", closeMembershipSelectionOverlayUI);
    membershipSelectionOverlay?.addEventListener("click", (evt) => {
      if (evt.target === membershipSelectionOverlay) {
        closeMembershipSelectionOverlayUI();
      }
    });
    membershipSelectionOptions?.forEach?.((node) => {
      node.addEventListener("click", () => {
        selectMembershipPlan(node.dataset.membershipOption);
      });
    });
    membershipTermsButton?.addEventListener("click", () => {
      if (!pendingMembershipPlanId) {
        if (membershipSelectionError) {
          membershipSelectionError.textContent = "Choose a membership first.";
        }
        return;
      }
      if (membershipTermsAcknowledged) {
        handleMembershipAcceptAndPay();
      } else {
        openMembershipTermsOverlayUI();
      }
    });
    membershipTermsClose?.addEventListener("click", closeMembershipTermsOverlayUI);
    membershipTermsOverlay?.addEventListener("click", (evt) => {
      if (evt.target === membershipTermsOverlay) {
        closeMembershipTermsOverlayUI();
      }
    });
    membershipTermsContent?.addEventListener("scroll", handleMembershipTermsScroll);
    membershipTermsCheckbox?.addEventListener("change", handleMembershipTermsCheckboxChange);
    // === RIDE SYNC STRIPE: END membership overlay logic ===

    if (paymentOverlayClose) {
      paymentOverlayClose.addEventListener("click", () => {
        const context = activePaymentContext;
        hidePaymentRedirectOverlay();
        closePaymentOverlay();
        if (context?.type === "ride") {
          profileMessage.textContent = "Ride payment canceled. Ride not requested.";
        } else if (context?.type === "membership" && membershipCardMessage) {
          membershipCardMessage.textContent = "Membership payment canceled.";
        }
      });
    }

    if (paymentOverlayConfirm) {
      paymentOverlayConfirm.addEventListener("click", confirmActivePayment);
    }

    if (paymentOverlay) {
      paymentOverlay.addEventListener("click", (event) => {
        if (event.target === paymentOverlay) {
          const context = activePaymentContext;
          hidePaymentRedirectOverlay();
          closePaymentOverlay();
          if (context?.type === "ride") {
            profileMessage.textContent = "Ride payment canceled. Ride not requested.";
          } else if (context?.type === "membership" && membershipCardMessage) {
            membershipCardMessage.textContent = "Membership payment canceled.";
          }
        }
      });
    }

    if (rideFareClose) {
      rideFareClose.addEventListener("click", () => {
        closeRideFareOverlay();
      });
    }
    if (rideFareOverlay) {
      rideFareOverlay.addEventListener("click", (event) => {
        if (event.target === rideFareOverlay) {
          closeRideFareOverlay();
        }
      });
    }

    if (paymentStatusBackButton) {
      paymentStatusBackButton.addEventListener("click", () => {
        closePaymentStatusOverlay();
        window.location.href = "/";
      });
    }

    async function ensureStripeInstance(livemode = null) {
      if (!STRIPE_ENABLED) {
        throw new Error("Stripe payments are not available right now.");
      }
      const publishableKey = resolveStripePublishableKeyForMode(livemode);
      logStripeDebug("ensureStripeInstance", {
        livemode,
        publishableKeyTail: publishableKey
          ? publishableKey.slice(0, 10) + "..." + publishableKey.slice(-6)
          : null,
      });
      if (!publishableKey) {
        const modeLabel = livemode === false ? "test" : "live";
        const guidance =
          modeLabel === "test"
            ? "Set stripe.publishableKeyTest (test mode) in app-config.json."
            : "Set stripe.publishableKey or stripe.publishableKeyLive in app-config.json.";
        throw new Error(
          `Stripe ${modeLabel} publishable key is not configured. ${guidance}`
        );
      }
      await loadStripeJs();
      if (!window.Stripe) {
        throw new Error("Stripe.js is not available.");
      }
      if (!stripeInstancesByKey.has(publishableKey)) {
        stripeInstancesByKey.set(publishableKey, window.Stripe(publishableKey));
      }
      return stripeInstancesByKey.get(publishableKey);
    }

    async function mountStripePaymentElement(clientSecret, livemode = null) {
      if (!paymentElementContainer) {
        throw new Error("Payment UI is unavailable.");
      }
      logStripeDebug("mountStripePaymentElement: before ensureStripeInstance", {
        livemode,
        clientSecretTail: clientSecret
          ? clientSecret.slice(0, 10) + "..." + clientSecret.slice(-6)
          : null,
      });
      const stripe = await ensureStripeInstance(livemode);
      if (stripePaymentElement) {
        stripePaymentElement.unmount();
        stripePaymentElement = null;
      }
      const elementOptions = { clientSecret };
      if (FORCE_DISABLE_GOOGLE_PAY) {
        elementOptions.wallets = { googlePay: "never" };
      }
      logStripeDebug("mountStripePaymentElement: creating elements", {
        elementOptions,
      });
      try {
        stripeElements = stripe.elements(elementOptions);
        stripePaymentElement = stripeElements.create("payment");
        stripePaymentElement.mount(paymentElementContainer);
        logStripeDebug("mountStripePaymentElement: mounted", {});
      } catch (err) {
        console.error("Stripe PaymentElement mount failed", err);
        throw err;
      }
    }

    async function openPaymentOverlay(options = {}) {
      const useStripePaymentElement =
        options.useStripePaymentElement !== false;
      const livemode = options.livemode ?? null;
      if (useStripePaymentElement && !options.clientSecret) {
        throw new Error("Stripe client secret missing.");
      }
      logStripeDebug("openPaymentOverlay", {
        title: options.title,
        contextType: options.context?.type,
        livemode,
        useStripePaymentElement,
        clientSecretTail:
          options.clientSecret && useStripePaymentElement
            ? options.clientSecret.slice(0, 10) +
              "..." +
              options.clientSecret.slice(-6)
            : null,
      });
      if (useStripePaymentElement) {
        if (paymentElementContainer) {
          paymentElementContainer.style.display = "";
        }
        await mountStripePaymentElement(options.clientSecret, livemode);
        activePaymentLivemode = livemode;
      } else {
        if (paymentElementContainer) {
          paymentElementContainer.style.display = "none";
        }
        if (stripePaymentElement) {
          stripePaymentElement.unmount();
          stripePaymentElement = null;
        }
        stripeElements = null;
        activePaymentLivemode = null;
      }
      activePaymentContext = {
        ...(options.context || {}),
        useStripePaymentElement,
        checkoutAmountCents: options.checkoutAmountCents ?? null,
        checkoutDescription: options.checkoutDescription || null,
      };
      if (paymentOverlayTitle) {
        paymentOverlayTitle.textContent = options.title || "Complete payment";
      }
      if (paymentOverlaySubtitle) {
        paymentOverlaySubtitle.textContent = options.subtitle || "";
      }
      if (paymentOverlayConfirm) {
        paymentOverlayConfirm.textContent = options.confirmLabel || "Pay now";
        paymentOverlayConfirm.disabled = false;
      }
      if (paymentOverlayMessage) {
        paymentOverlayMessage.textContent = "";
      }
      paymentOverlay?.classList.add("active");
      paymentOverlay?.setAttribute("aria-hidden", "false");
      if (paymentFareSummary) {
        paymentFareSummary.style.display =
          options.context?.type === "ride" ? "" : "none";
      }
    }

    function closePaymentOverlay() {
      if (stripePaymentElement) {
        stripePaymentElement.unmount();
        stripePaymentElement = null;
      }
      stripeElements = null;
      activePaymentContext = null;
      activePaymentLivemode = null;
      paymentOverlay?.classList.remove("active");
      paymentOverlay?.setAttribute("aria-hidden", "true");
      if (paymentOverlayMessage) {
        paymentOverlayMessage.textContent = "";
      }
    }

    function showPaymentRedirectOverlay(message) {
      if (!paymentRedirectOverlay) return;
      if (paymentRedirectSubtitle && message) {
        paymentRedirectSubtitle.textContent = message;
      }
      paymentRedirectOverlay.classList.add("active");
      paymentRedirectOverlay.setAttribute("aria-hidden", "false");
    }

    function hidePaymentRedirectOverlay() {
      if (!paymentRedirectOverlay) return;
      paymentRedirectOverlay.classList.remove("active");
      paymentRedirectOverlay.setAttribute("aria-hidden", "true");
    }

    function buildRideCheckoutSessionEndpoints() {
      const endpoints = [];
      const configuredUrl = normalizeCheckoutEndpoint(
        functionsConfig.createRideCheckoutSessionUrl
      );
      if (configuredUrl) {
        endpoints.push(configuredUrl);
      }
      const defaultRelative = normalizeCheckoutEndpoint(
        "/createRideCheckoutSession"
      );
      if (defaultRelative) {
        endpoints.push(defaultRelative);
      }
      if (firebaseConfig?.projectId) {
        const functionUrl = normalizeCheckoutEndpoint(
          `https://us-central1-${firebaseConfig.projectId}.cloudfunctions.net/createRideCheckoutSession`
        );
        if (functionUrl) {
          endpoints.push(functionUrl);
        }
      }
      const deduped = [];
      const seen = new Set();
      for (const endpoint of endpoints) {
        if (!endpoint || seen.has(endpoint)) {
          continue;
        }
        seen.add(endpoint);
        deduped.push(endpoint);
      }
      return deduped;
    }

    function normalizeCheckoutEndpoint(value) {
      if (typeof value !== "string") {
        return "";
      }
      const trimmed = value.trim();
      if (!trimmed) {
        return "";
      }
      if (trimmed.startsWith("http://") || trimmed.startsWith("https://")) {
        return trimmed;
      }
      if (trimmed.startsWith("/")) {
        return trimmed;
      }
      return "";
    }

    async function confirmActivePayment() {
      if (!activePaymentContext) return;
      if (paymentOverlayMessage) {
        paymentOverlayMessage.textContent = "";
      }
      if (paymentOverlayConfirm) {
        paymentOverlayConfirm.disabled = true;
      }

      try {
        const isCheckoutRedirectRide =
          activePaymentContext?.type === "ride" &&
          activePaymentContext.useStripePaymentElement === false;
        if (isCheckoutRedirectRide) {
          await startRideCheckoutRedirect(activePaymentContext);
          return;
        }

        const stripe = await ensureStripeInstance(activePaymentLivemode);
        const result = await stripe.confirmPayment({
          elements: stripeElements,
          redirect: "if_required",
        });
        if (result.error) {
          throw new Error(result.error.message || "Payment failed.");
        }
        if (!result.paymentIntent || result.paymentIntent.status !== "succeeded") {
          throw new Error("Payment did not complete.");
        }
        await handlePaymentSuccess(result.paymentIntent, activePaymentContext);
        closePaymentOverlay();
      } catch (err) {
        console.error("confirmActivePayment", err);
        if (paymentOverlayMessage) {
          paymentOverlayMessage.textContent =
            err.message || "Unable to process payment.";
        }
        if (activePaymentContext?.type === "ride") {
          showErrorBanner(err.message || PAYMENT_ERROR_FALLBACK);
        }
        if (paymentOverlayConfirm) {
          paymentOverlayConfirm.disabled = false;
        }
        if (activePaymentContext?.type === "ride") {
          hidePaymentRedirectOverlay();
        }
      }
    }

    async function activateRideAfterCreation(rideId, ridePayload) {
      currentRideId = rideId;
      startRideStatusWatcher(rideId);
      updateCancelButtonVisibility();
      if (ridePayload?.isGroupRide) {
        showGroupQr(rideId);
      } else {
        hideGroupQr();
      }
      if (ridePayload?.poolType === "uofa") {
        startPoolGroupWatcher(rideId);
      }
      profileMessage.textContent = "Syncing your ride.";
      profileError.textContent = "";
      showLoadingView();
    }

    async function handlePaymentSuccess(paymentIntent, context) {
      if (context?.type === "membershipSubscription") {
        let finalizeResponse;
        try {
          finalizeResponse = await finalizeMembershipSubscriptionFn({
            subscriptionId: context.subscriptionId,
          });
        } catch (err) {
          throw handleCallableError("finalizeMembershipSubscription", err);
        }
        const status = finalizeResponse?.data?.status || "active";
        if (status === "active") {
          setMembershipMessage("Membership updated!");
        } else {
          setMembershipMessage(`Subscription status: ${status}`);
        }
        const user = auth.currentUser;
        if (user) {
          await loadUserProfile(user.uid, user.email);
        }
        return;
      }

      if (context?.type === "membership") {
        await callApplyMembershipPlan({
          plan: context.plan,
          paymentIntentId: paymentIntent.id,
        });
        setMembershipMessage("Membership updated!");
        const user = auth.currentUser;
        if (user) {
          await loadUserProfile(user.uid, user.email);
        }
        return;
      }
    }

    function buildRidePaymentPayload(rawPayload = {}) {
      const payload = { ...rawPayload };
      payload.pickupLocation =
        latLngToLiteral(payload.pickupLocation) ||
        latLngToLiteral(payload.fromLocation) ||
        null;
      payload.dropoffLocation =
        latLngToLiteral(payload.dropoffLocation) ||
        latLngToLiteral(payload.toLocation) ||
        latLngToLiteral(payload.destinationLocation) ||
        null;
      if (Array.isArray(payload.extraStops)) {
        payload.extraStops = payload.extraStops
          .map((stop, index) => {
            if (!stop) return null;
            const label = typeof stop.label === "string" ? stop.label.trim() : "";
            const location = latLngToLiteral(stop.location);
            if (!label || !isLatLngLiteral(location)) {
              return null;
            }
            return {
              order: Number.isFinite(stop.order) ? stop.order : index + 1,
              label,
              location
            };
          })
          .filter(Boolean);
        if (!payload.extraStops.length) {
          delete payload.extraStops;
        }
      }
      payload.totalCents = Number(payload.totalCents);
      payload.estimatedDurationMinutes = Number(payload.estimatedDurationMinutes);
      delete payload.createdAt;
      delete payload.updatedAt;

      if (!isLatLngLiteral(payload.pickupLocation) || !isLatLngLiteral(payload.dropoffLocation)) {
        throw new Error("Pickup and dropoff locations are required. Please refresh your route.");
      }

      if (!Number.isFinite(payload.totalCents)) {
        throw new Error("Fare estimate missing. Please refresh the fare and try again.");
      }

      if (
        !Number.isFinite(payload.estimatedDurationMinutes) ||
        payload.estimatedDurationMinutes <= 0
      ) {
        throw new Error(
          "Estimated ride duration missing. Please refresh the fare and try again."
        );
      }

      payload.totalCents = Math.max(0, Math.round(payload.totalCents));
      payload.estimatedDurationMinutes =
        Math.round(payload.estimatedDurationMinutes * 10) / 10;

      return payload;
    }

    function resolveRideCheckoutAmountCents(ride = {}) {
      const centCandidates = [
        ride.totalCents,
        ride.totalFareCents,
        ride.estimatedFareCents,
        ride.stripeAmountCents,
        ride.totalFareEstimateCents,
      ];
      for (const candidate of centCandidates) {
        const value = Number(candidate);
        if (Number.isFinite(value) && value > 0) {
          return Math.round(value);
        }
      }
      const dollarCandidates = [
        ride.total,
        ride.totalFare,
        ride.quotedTotal,
        ride.fare?.total,
        ride.fare?.totalFare,
      ];
      for (const candidate of dollarCandidates) {
        const value = Number(candidate);
        if (Number.isFinite(value) && value > 0) {
          return Math.round(value * 100);
        }
      }
      return null;
    }

    async function startRideCheckoutRedirect(context = {}) {
      const amountCents = Number(context.checkoutAmountCents || 0);
      if (!Number.isFinite(amountCents) || amountCents <= 0) {
        throw new Error("Ride fare is unavailable. Please refresh and try again.");
      }
      const description =
        context.checkoutDescription ||
        context.ridePayload?.toDestination ||
        "RideSync ride fare";
      const user = auth.currentUser;
      let idToken = null;
      if (user) {
        try {
          idToken = await user.getIdToken();
        } catch (err) {
          console.warn("Failed to read auth token for checkout session", err);
        }
      }
      showPaymentRedirectOverlay("Redirecting you to Stripe Checkout…");
      const headers = {
        "Content-Type": "application/json",
      };
      if (idToken) {
        headers.Authorization = `Bearer ${idToken}`;
      }
      const redirectBaseUrl =
        typeof window !== "undefined" && window.location?.origin
          ? window.location.origin
          : null;
      const requestPayload = {
        amountCents: Math.round(amountCents),
        description,
        ridePayload: context.ridePayload || null,
        redirectBaseUrl,
      };
      const requestBody = JSON.stringify(requestPayload);
      try {
        const sessionUrl = await requestRideCheckoutSession(headers, requestBody);
        window.location.href = sessionUrl;
        return;
      } catch (httpErr) {
        logStripeDebug("createRideCheckoutSession HTTP flow failed", {
          message:
            httpErr instanceof Error ? httpErr.message : String(httpErr ?? ""),
        });
      }
      try {
        const sessionUrl = await requestRideCheckoutSessionViaCallable(
          requestPayload
        );
        window.location.href = sessionUrl;
      } catch (err) {
        hidePaymentRedirectOverlay();
        throw err instanceof Error
          ? err
          : new Error(PAYMENT_ERROR_FALLBACK);
      }
    }

    async function requestRideCheckoutSession(headers, body) {
      let lastFailure = null;
      for (const endpoint of rideCheckoutSessionEndpoints) {
        if (!endpoint) continue;
        try {
          const response = await fetch(endpoint, {
            method: "POST",
            headers,
            body,
          });
          let data = null;
          try {
            data = await response.json();
          } catch (_) {
            data = null;
          }
          if (response.ok && data?.url) {
            return data.url;
          }
          lastFailure = {
            endpoint,
            status: response.status,
            body: data,
          };
          logStripeDebug(
            "createRideCheckoutSession endpoint rejected",
            lastFailure
          );
        } catch (err) {
          lastFailure = {
            endpoint,
            error: err instanceof Error ? err.message : String(err),
          };
          logStripeDebug(
            "createRideCheckoutSession endpoint error",
            lastFailure
          );
        }
      }
      console.error(
        "[RideSync][Stripe] Failed to create checkout session",
        lastFailure
      );
      throw new Error(PAYMENT_ERROR_FALLBACK);
    }

    async function requestRideCheckoutSessionViaCallable(payload) {
      try {
        const response = await createRideCheckoutSessionCallableFn(payload);
        const url = response?.data?.url;
        if (typeof url === "string" && url) {
          return url;
        }
        logStripeDebug("createRideCheckoutSession callable missing url", {
          payloadSummary: {
            hasData: !!response,
          },
        });
        throw new Error(PAYMENT_ERROR_FALLBACK);
      } catch (err) {
        throw handleCallableError(
          "createRideCheckoutSessionCallable",
          err,
          PAYMENT_ERROR_FALLBACK
        );
      }
    }

    async function startRidePaymentFlow(ridePayload) {
      const sanitizedRidePayload = buildRidePaymentPayload(ridePayload);
      logStripeDebug("startRidePaymentFlow: payload", {
        ridePayload,
        sanitizedRidePayload,
      });
      if (!STRIPE_ENABLED) {
        throw new Error("Stripe payments are not available right now.");
      }
      const amountCents = resolveRideCheckoutAmountCents(sanitizedRidePayload);
      if (!amountCents || amountCents <= 0) {
        throw new Error(
          "Fare estimate missing. Please refresh the fare and try again."
        );
      }
      const formattedTotal = formatCurrencyFromCents(amountCents, "usd");
      const suffix = sanitizedRidePayload.fare?.membershipLabel
        ? `${sanitizedRidePayload.fare.membershipLabel}.`
        : "Ride synced.";
      profileMessage.textContent = `${suffix} Pay ${formattedTotal} when the ride ends.`;
      profileError.textContent = "";
      logStripeDebug(
        "startRidePaymentFlow: checkout redirect disabled, fare will be collected post-ride.",
        {
          amountCents,
        }
      );
      return {
        amountCents,
        ridePayload: sanitizedRidePayload,
      };
    }

    async function handleNewRide() {
      const user = auth.currentUser;
      if (!user) return;
      if (!hasOnlineDrivers) {
        profileMessage.textContent =
          "Drivers look offline right now. We'll notify them as soon as you sync.";
      } else {
        profileMessage.textContent = "";
      }
      profileError.textContent = "";
      clearPoolGroupUI();
      hideGroupQr();

      if (!destinationLatLng || !lastRideMetrics || !lastRideMetrics.fareBreakdown) {
        profileError.textContent = "Set destination and wait for fare estimate first.";
        updateRouteAndFare();
        return;
      }

      const plan = normalizePlanKey(
        currentUserProfile?.membershipType || currentUserProfile?.membership || "basic"
      );
      const planIsBasic = plan === "basic";
      const membershipStatus = currentUserProfile?.membershipStatus || "none";
      const isStudent = !!currentUserProfile?.isStudent;
      const uofaVerified = !!currentUserProfile?.uofaVerified;
      const poolGender = normalizePoolGender(currentUserProfile?.gender);
      const genderPoolEligible = !!poolGender;
      const numRiders = parseInt(numRidersEl.value || "1", 10);
      const inHomeZone = !!lastRideMetrics.inHomeZone;

      const uofaPoolEligible =
        plan === "uofa_unlimited" &&
        isStudent &&
        uofaVerified &&
        genderPoolEligible &&
        inHomeZone;

      const fare = lastRideMetrics.fareBreakdown;
      const totalValue = Number.isFinite(fare.total) ? fare.total : 0;
      const totalCents = Math.max(0, Math.round(totalValue * 100));

      const cd = await checkCooldown(user.uid, plan);
      if (cd.allowed === false) {
        profileError.textContent = `You can request another ride in about ${cd.remainingMinutes} min.`;
        return;
      }

      let poolType = null;
      let status = "pending_driver";

      if (uofaPoolEligible && numRiders === 1) {
        poolType = "uofa";
        status = "pool_searching";
      }

      const destAddress =
        destinationEl.value.trim() ||
        lastDestinationPlace?.formatted_address ||
        "";

      const riderName =
        currentUserProfile?.fullName ||
        currentUserProfile?.name ||
        currentUserProfile?.displayName ||
        (currentUserProfile?.email
          ? currentUserProfile.email.split("@")[0]
          : "Rider");

      const riderPhone =
        currentUserProfile?.phone || currentUserProfile?.phoneNumber || "";
      const riderPhotoUrl =
        currentUserProfile?.profilePicUrl ||
        currentUserProfile?.photoURL ||
        null;

      const maxRiders = numRiders;
      const isGroupRide = maxRiders > 1;
      const pickupCode = generateRidePin();
      const dropoffCode = generateRidePin();
      const pickupLocationLiteral = currentLocation
        ? { lat: currentLocation.lat, lng: currentLocation.lng }
        : null;
      const dropoffLocationLiteral = latLngToLiteral(destinationLatLng);
      if (!pickupLocationLiteral || !dropoffLocationLiteral) {
        profileError.textContent = "Missing pickup or dropoff location.";
        return;
      }
      let extraStopsPayload = [];
      try {
        extraStopsPayload = collectExtraStopsForRide();
      } catch (stopErr) {
        profileError.textContent = stopErr.message;
        return;
      }

      const rideBase = {
        isGroupRide,
        maxRiders,
        poolType,
        numRiders,
        pickupLocation: pickupLocationLiteral,
        dropoffLocation: dropoffLocationLiteral,
        toDestination: destAddress || null,
        inHomeZone,
        estimatedDurationMinutes: lastRideMetrics.durationMinutes
          ? +lastRideMetrics.durationMinutes.toFixed(1)
          : null,
        distanceMeters: lastRideMetrics.distanceMeters || null,
        fare,
        totalCents,
        extraStops: extraStopsPayload,
        status
      };
      try {
        if (syncButton) {
          syncButton.disabled = true;
          syncButton.textContent = "Syncing...";
        }
        const response = await createRideRequestFn({
          ride: {
            ...rideBase,
            fromLocation: currentLocation || pickupLocationLiteral,
            pickupCity: currentUserProfile?.city || null,
            riderContext: {
              name: riderName,
              phone: riderPhone,
              photoUrl: riderPhotoUrl
            }
          }
        });
        const result = response?.data || {};
        if (!result.rideId) {
          throw new Error(result?.message || "Ride was not created.");
        }
        const requiresPayment = Number(result.amountCents || 0) > 0;
        profileMessage.textContent = requiresPayment
          ? "Ride synced! Pay when the ride ends."
          : "Ride synced! Your membership covers this fare.";
        profileError.textContent = "";
        activateRideAfterCreation(result.rideId, result.ride || rideBase);
      } catch (err) {
        console.error("New ride error", err);
        profileError.textContent = err.message || "Could not start this ride.";
      } finally {
        if (syncButton) {
          syncButton.disabled = false;
          updateSyncButtonLabel();
        }
      }
    }

    async function handleJoinRide() {
      const user = auth.currentUser;
      if (!user || !joinTargetRide) {
        profileError.textContent = "Unable to join this ride.";
        return;
      }
      if (!hasOnlineDrivers) {
        profileMessage.textContent =
          "Drivers look offline right now. We'll notify them as soon as you join.";
      } else {
        profileMessage.textContent = "";
      }
      profileError.textContent = "";
      cancelError.textContent = "";

      try {
        const plan = normalizePlanKey(
          currentUserProfile?.membershipType ||
            currentUserProfile?.membership ||
            "basic"
        );
        const riderGender = normalizePoolGender(currentUserProfile?.gender);
        if (!riderGender) {
          profileError.textContent =
            "Set your profile gender to Male or Female to join pooling rides.";
          return;
        }
        const targetGender = normalizePoolGender(joinTargetRide?.gender);
        if (!targetGender || targetGender !== riderGender) {
          profileError.textContent =
            "You can only join riders who share your gender.";
          return;
        }

        const cooldown = await checkCooldown(user.uid, plan);
        if (cooldown.allowed === false) {
          profileError.textContent = `You can request another ride in about ${cooldown.remainingMinutes} min.`;
          return;
        }

        if (syncButton) {
          syncButton.disabled = true;
          syncButton.textContent = "Joining…";
        }

        const response = await joinRideGroupFn({ hostRideId: joinTargetRide.id });
        const rideId = response?.data?.rideId;
        if (!rideId) {
          throw new Error("This group ride is no longer available.");
        }

        currentRideId = rideId;
        joinMode = false;
        joinTargetRide = null;
        startRideStatusWatcher(rideId);
        updateCancelButtonVisibility();
        hideGroupQr();
        showLoadingView();
      } catch (err) {
        console.error("Join ride error", err);
        profileError.textContent = err.message || "Could not join group ride.";
      } finally {
        if (syncButton) {
          syncButton.disabled = false;
          updateSyncButtonLabel();
        }
      }
    }

    syncButton.addEventListener("click", async () => {
      if (joinMode && joinTargetRide) {
        await handleJoinRide();
      } else {
        await handleNewRide();
      }
    });

    showPaymentResultFromLocation();

    async function enterJoinMode(rideId) {
      try {
        const hostRef = doc(db, "rideRequests", rideId);
        const snap = await getDoc(hostRef);
        if (!snap.exists()) {
          console.warn("Join ride not found");
          return;
        }
        const host = snap.data();
        joinMode = true;
        joinTargetRide = { id: snap.id, ...host };

        joinBanner.style.display = "block";
        const cur = host.currentRiderCount || 1;
        const max = host.maxRiders || 1;
        joinBannerText.textContent = `Joining group ride to "${host.toDestination || "destination"}". Group: ${cur} of ${max} riders. You will join as 1 rider. If you need an extra stop, tell your driver when picked up.`;

        ridersSection.style.display = "none";
        numRidersEl.value = "1";
        numRidersEl.disabled = true;

        if (host.toDestination) {
          destinationEl.value = host.toDestination;
        }
        updateSyncButtonLabel();
      } catch (err) {
        console.error("Failed to enter join mode", err);
      }
    }

      function ensureBackgroundMapReady() {
        if (googleMapsLoadFailed) return;
        if (map) return;
        if (window.google && google.maps) {
          initMapOnce();
          return;
        }
        setTimeout(ensureBackgroundMapReady, 600);
      }

      function trySetupAutocompleteEarly() {
        if (googleMapsLoadFailed) return;
        if (!window.google || !google.maps || !google.maps.places) {
          setTimeout(trySetupAutocompleteEarly, 800);
          return;
        }
        setupDestinationAutocomplete();
        extraStopsState.forEach((stop) => setupExtraStopAutocomplete(stop));
      }

    window.addEventListener("beforeunload", () => {
      if (driverAvailabilityUnsub) {
        driverAvailabilityUnsub();
        driverAvailabilityUnsub = null;
      }
    });

      ensureBackgroundMapReady();
      trySetupAutocompleteEarly();
  </script>
</body>
</html>